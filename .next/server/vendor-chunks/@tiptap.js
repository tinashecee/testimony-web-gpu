"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tiptap";
exports.ids = ["vendor-chunks/@tiptap"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tiptap/core/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@tiptap/core/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommandManager: () => (/* binding */ CommandManager),\n/* harmony export */   Editor: () => (/* binding */ Editor),\n/* harmony export */   Extendable: () => (/* binding */ Extendable),\n/* harmony export */   Extension: () => (/* binding */ Extension),\n/* harmony export */   Fragment: () => (/* binding */ Fragment6),\n/* harmony export */   InputRule: () => (/* binding */ InputRule),\n/* harmony export */   Mark: () => (/* binding */ Mark),\n/* harmony export */   MarkView: () => (/* binding */ MarkView),\n/* harmony export */   Node: () => (/* binding */ Node3),\n/* harmony export */   NodePos: () => (/* binding */ NodePos),\n/* harmony export */   NodeView: () => (/* binding */ NodeView),\n/* harmony export */   PasteRule: () => (/* binding */ PasteRule),\n/* harmony export */   Tracker: () => (/* binding */ Tracker),\n/* harmony export */   callOrReturn: () => (/* binding */ callOrReturn),\n/* harmony export */   canInsertNode: () => (/* binding */ canInsertNode),\n/* harmony export */   combineTransactionSteps: () => (/* binding */ combineTransactionSteps),\n/* harmony export */   commands: () => (/* binding */ commands_exports),\n/* harmony export */   createAtomBlockMarkdownSpec: () => (/* binding */ createAtomBlockMarkdownSpec),\n/* harmony export */   createBlockMarkdownSpec: () => (/* binding */ createBlockMarkdownSpec),\n/* harmony export */   createChainableState: () => (/* binding */ createChainableState),\n/* harmony export */   createDocument: () => (/* binding */ createDocument),\n/* harmony export */   createElement: () => (/* binding */ h),\n/* harmony export */   createInlineMarkdownSpec: () => (/* binding */ createInlineMarkdownSpec),\n/* harmony export */   createNodeFromContent: () => (/* binding */ createNodeFromContent),\n/* harmony export */   createStyleTag: () => (/* binding */ createStyleTag),\n/* harmony export */   defaultBlockAt: () => (/* binding */ defaultBlockAt),\n/* harmony export */   deleteProps: () => (/* binding */ deleteProps),\n/* harmony export */   elementFromString: () => (/* binding */ elementFromString),\n/* harmony export */   escapeForRegEx: () => (/* binding */ escapeForRegEx),\n/* harmony export */   extensions: () => (/* binding */ extensions_exports),\n/* harmony export */   findChildren: () => (/* binding */ findChildren),\n/* harmony export */   findChildrenInRange: () => (/* binding */ findChildrenInRange),\n/* harmony export */   findDuplicates: () => (/* binding */ findDuplicates),\n/* harmony export */   findParentNode: () => (/* binding */ findParentNode),\n/* harmony export */   findParentNodeClosestToPos: () => (/* binding */ findParentNodeClosestToPos),\n/* harmony export */   flattenExtensions: () => (/* binding */ flattenExtensions),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   generateHTML: () => (/* binding */ generateHTML),\n/* harmony export */   generateJSON: () => (/* binding */ generateJSON),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   getAttributes: () => (/* binding */ getAttributes),\n/* harmony export */   getAttributesFromExtensions: () => (/* binding */ getAttributesFromExtensions),\n/* harmony export */   getChangedRanges: () => (/* binding */ getChangedRanges),\n/* harmony export */   getDebugJSON: () => (/* binding */ getDebugJSON),\n/* harmony export */   getExtensionField: () => (/* binding */ getExtensionField),\n/* harmony export */   getHTMLFromFragment: () => (/* binding */ getHTMLFromFragment),\n/* harmony export */   getMarkAttributes: () => (/* binding */ getMarkAttributes),\n/* harmony export */   getMarkRange: () => (/* binding */ getMarkRange),\n/* harmony export */   getMarkType: () => (/* binding */ getMarkType),\n/* harmony export */   getMarksBetween: () => (/* binding */ getMarksBetween),\n/* harmony export */   getNodeAtPosition: () => (/* binding */ getNodeAtPosition),\n/* harmony export */   getNodeAttributes: () => (/* binding */ getNodeAttributes),\n/* harmony export */   getNodeType: () => (/* binding */ getNodeType),\n/* harmony export */   getRenderedAttributes: () => (/* binding */ getRenderedAttributes),\n/* harmony export */   getSchema: () => (/* binding */ getSchema),\n/* harmony export */   getSchemaByResolvedExtensions: () => (/* binding */ getSchemaByResolvedExtensions),\n/* harmony export */   getSchemaTypeByName: () => (/* binding */ getSchemaTypeByName),\n/* harmony export */   getSchemaTypeNameByName: () => (/* binding */ getSchemaTypeNameByName),\n/* harmony export */   getSplittedAttributes: () => (/* binding */ getSplittedAttributes),\n/* harmony export */   getText: () => (/* binding */ getText),\n/* harmony export */   getTextBetween: () => (/* binding */ getTextBetween),\n/* harmony export */   getTextContentFromNodes: () => (/* binding */ getTextContentFromNodes),\n/* harmony export */   getTextSerializersFromSchema: () => (/* binding */ getTextSerializersFromSchema),\n/* harmony export */   h: () => (/* binding */ h),\n/* harmony export */   injectExtensionAttributesToParseRule: () => (/* binding */ injectExtensionAttributesToParseRule),\n/* harmony export */   inputRulesPlugin: () => (/* binding */ inputRulesPlugin),\n/* harmony export */   isActive: () => (/* binding */ isActive),\n/* harmony export */   isAndroid: () => (/* binding */ isAndroid),\n/* harmony export */   isAtEndOfNode: () => (/* binding */ isAtEndOfNode),\n/* harmony export */   isAtStartOfNode: () => (/* binding */ isAtStartOfNode),\n/* harmony export */   isEmptyObject: () => (/* binding */ isEmptyObject),\n/* harmony export */   isExtensionRulesEnabled: () => (/* binding */ isExtensionRulesEnabled),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isList: () => (/* binding */ isList),\n/* harmony export */   isMacOS: () => (/* binding */ isMacOS),\n/* harmony export */   isMarkActive: () => (/* binding */ isMarkActive),\n/* harmony export */   isNodeActive: () => (/* binding */ isNodeActive),\n/* harmony export */   isNodeEmpty: () => (/* binding */ isNodeEmpty),\n/* harmony export */   isNodeSelection: () => (/* binding */ isNodeSelection),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRegExp: () => (/* binding */ isRegExp),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isTextSelection: () => (/* binding */ isTextSelection),\n/* harmony export */   isiOS: () => (/* binding */ isiOS),\n/* harmony export */   markInputRule: () => (/* binding */ markInputRule),\n/* harmony export */   markPasteRule: () => (/* binding */ markPasteRule),\n/* harmony export */   markdown: () => (/* binding */ markdown_exports),\n/* harmony export */   mergeAttributes: () => (/* binding */ mergeAttributes),\n/* harmony export */   mergeDeep: () => (/* binding */ mergeDeep),\n/* harmony export */   minMax: () => (/* binding */ minMax),\n/* harmony export */   nodeInputRule: () => (/* binding */ nodeInputRule),\n/* harmony export */   nodePasteRule: () => (/* binding */ nodePasteRule),\n/* harmony export */   objectIncludes: () => (/* binding */ objectIncludes),\n/* harmony export */   parseAttributes: () => (/* binding */ parseAttributes),\n/* harmony export */   parseIndentedBlocks: () => (/* binding */ parseIndentedBlocks),\n/* harmony export */   pasteRulesPlugin: () => (/* binding */ pasteRulesPlugin),\n/* harmony export */   posToDOMRect: () => (/* binding */ posToDOMRect),\n/* harmony export */   removeDuplicates: () => (/* binding */ removeDuplicates),\n/* harmony export */   renderNestedMarkdownContent: () => (/* binding */ renderNestedMarkdownContent),\n/* harmony export */   resolveExtensions: () => (/* binding */ resolveExtensions),\n/* harmony export */   resolveFocusPosition: () => (/* binding */ resolveFocusPosition),\n/* harmony export */   rewriteUnknownContent: () => (/* binding */ rewriteUnknownContent),\n/* harmony export */   selectionToInsertionEnd: () => (/* binding */ selectionToInsertionEnd),\n/* harmony export */   serializeAttributes: () => (/* binding */ serializeAttributes),\n/* harmony export */   sortExtensions: () => (/* binding */ sortExtensions),\n/* harmony export */   splitExtensions: () => (/* binding */ splitExtensions),\n/* harmony export */   textInputRule: () => (/* binding */ textInputRule),\n/* harmony export */   textPasteRule: () => (/* binding */ textPasteRule),\n/* harmony export */   textblockTypeInputRule: () => (/* binding */ textblockTypeInputRule),\n/* harmony export */   updateMarkViewAttributes: () => (/* binding */ updateMarkViewAttributes),\n/* harmony export */   wrappingInputRule: () => (/* binding */ wrappingInputRule)\n/* harmony export */ });\n/* harmony import */ var _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/transform */ \"(ssr)/./node_modules/@tiptap/pm/dist/transform/index.js\");\n/* harmony import */ var _tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/commands */ \"(ssr)/./node_modules/@tiptap/pm/dist/commands/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\");\n/* harmony import */ var _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/pm/model */ \"(ssr)/./node_modules/@tiptap/pm/dist/model/index.js\");\n/* harmony import */ var _tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/pm/schema-list */ \"(ssr)/./node_modules/@tiptap/pm/dist/schema-list/index.js\");\n/* harmony import */ var _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/pm/view */ \"(ssr)/./node_modules/@tiptap/pm/dist/view/index.js\");\n/* harmony import */ var _tiptap_pm_keymap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/pm/keymap */ \"(ssr)/./node_modules/@tiptap/pm/dist/keymap/index.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/helpers/createChainableState.ts\nfunction createChainableState(config) {\n  const { state, transaction } = config;\n  let { selection } = transaction;\n  let { doc } = transaction;\n  let { storedMarks } = transaction;\n  return {\n    ...state,\n    apply: state.apply.bind(state),\n    applyTransaction: state.applyTransaction.bind(state),\n    plugins: state.plugins,\n    schema: state.schema,\n    reconfigure: state.reconfigure.bind(state),\n    toJSON: state.toJSON.bind(state),\n    get storedMarks() {\n      return storedMarks;\n    },\n    get selection() {\n      return selection;\n    },\n    get doc() {\n      return doc;\n    },\n    get tr() {\n      selection = transaction.selection;\n      doc = transaction.doc;\n      storedMarks = transaction.storedMarks;\n      return transaction;\n    }\n  };\n}\n\n// src/CommandManager.ts\nvar CommandManager = class {\n  constructor(props) {\n    this.editor = props.editor;\n    this.rawCommands = this.editor.extensionManager.commands;\n    this.customState = props.state;\n  }\n  get hasCustomState() {\n    return !!this.customState;\n  }\n  get state() {\n    return this.customState || this.editor.state;\n  }\n  get commands() {\n    const { rawCommands, editor, state } = this;\n    const { view } = editor;\n    const { tr } = state;\n    const props = this.buildProps(tr);\n    return Object.fromEntries(\n      Object.entries(rawCommands).map(([name, command2]) => {\n        const method = (...args) => {\n          const callback = command2(...args)(props);\n          if (!tr.getMeta(\"preventDispatch\") && !this.hasCustomState) {\n            view.dispatch(tr);\n          }\n          return callback;\n        };\n        return [name, method];\n      })\n    );\n  }\n  get chain() {\n    return () => this.createChain();\n  }\n  get can() {\n    return () => this.createCan();\n  }\n  createChain(startTr, shouldDispatch = true) {\n    const { rawCommands, editor, state } = this;\n    const { view } = editor;\n    const callbacks = [];\n    const hasStartTransaction = !!startTr;\n    const tr = startTr || state.tr;\n    const run3 = () => {\n      if (!hasStartTransaction && shouldDispatch && !tr.getMeta(\"preventDispatch\") && !this.hasCustomState) {\n        view.dispatch(tr);\n      }\n      return callbacks.every((callback) => callback === true);\n    };\n    const chain = {\n      ...Object.fromEntries(\n        Object.entries(rawCommands).map(([name, command2]) => {\n          const chainedCommand = (...args) => {\n            const props = this.buildProps(tr, shouldDispatch);\n            const callback = command2(...args)(props);\n            callbacks.push(callback);\n            return chain;\n          };\n          return [name, chainedCommand];\n        })\n      ),\n      run: run3\n    };\n    return chain;\n  }\n  createCan(startTr) {\n    const { rawCommands, state } = this;\n    const dispatch = false;\n    const tr = startTr || state.tr;\n    const props = this.buildProps(tr, dispatch);\n    const formattedCommands = Object.fromEntries(\n      Object.entries(rawCommands).map(([name, command2]) => {\n        return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];\n      })\n    );\n    return {\n      ...formattedCommands,\n      chain: () => this.createChain(tr, dispatch)\n    };\n  }\n  buildProps(tr, shouldDispatch = true) {\n    const { rawCommands, editor, state } = this;\n    const { view } = editor;\n    const props = {\n      tr,\n      editor,\n      view,\n      state: createChainableState({\n        state,\n        transaction: tr\n      }),\n      dispatch: shouldDispatch ? () => void 0 : void 0,\n      chain: () => this.createChain(tr, shouldDispatch),\n      can: () => this.createCan(tr),\n      get commands() {\n        return Object.fromEntries(\n          Object.entries(rawCommands).map(([name, command2]) => {\n            return [name, (...args) => command2(...args)(props)];\n          })\n        );\n      }\n    };\n    return props;\n  }\n};\n\n// src/commands/index.ts\nvar commands_exports = {};\n__export(commands_exports, {\n  blur: () => blur,\n  clearContent: () => clearContent,\n  clearNodes: () => clearNodes,\n  command: () => command,\n  createParagraphNear: () => createParagraphNear,\n  cut: () => cut,\n  deleteCurrentNode: () => deleteCurrentNode,\n  deleteNode: () => deleteNode,\n  deleteRange: () => deleteRange,\n  deleteSelection: () => deleteSelection,\n  enter: () => enter,\n  exitCode: () => exitCode,\n  extendMarkRange: () => extendMarkRange,\n  first: () => first,\n  focus: () => focus,\n  forEach: () => forEach,\n  insertContent: () => insertContent,\n  insertContentAt: () => insertContentAt,\n  joinBackward: () => joinBackward,\n  joinDown: () => joinDown,\n  joinForward: () => joinForward,\n  joinItemBackward: () => joinItemBackward,\n  joinItemForward: () => joinItemForward,\n  joinTextblockBackward: () => joinTextblockBackward,\n  joinTextblockForward: () => joinTextblockForward,\n  joinUp: () => joinUp,\n  keyboardShortcut: () => keyboardShortcut,\n  lift: () => lift,\n  liftEmptyBlock: () => liftEmptyBlock,\n  liftListItem: () => liftListItem,\n  newlineInCode: () => newlineInCode,\n  resetAttributes: () => resetAttributes,\n  scrollIntoView: () => scrollIntoView,\n  selectAll: () => selectAll,\n  selectNodeBackward: () => selectNodeBackward,\n  selectNodeForward: () => selectNodeForward,\n  selectParentNode: () => selectParentNode,\n  selectTextblockEnd: () => selectTextblockEnd,\n  selectTextblockStart: () => selectTextblockStart,\n  setContent: () => setContent,\n  setMark: () => setMark,\n  setMeta: () => setMeta,\n  setNode: () => setNode,\n  setNodeSelection: () => setNodeSelection,\n  setTextSelection: () => setTextSelection,\n  sinkListItem: () => sinkListItem,\n  splitBlock: () => splitBlock,\n  splitListItem: () => splitListItem,\n  toggleList: () => toggleList,\n  toggleMark: () => toggleMark,\n  toggleNode: () => toggleNode,\n  toggleWrap: () => toggleWrap,\n  undoInputRule: () => undoInputRule,\n  unsetAllMarks: () => unsetAllMarks,\n  unsetMark: () => unsetMark,\n  updateAttributes: () => updateAttributes,\n  wrapIn: () => wrapIn,\n  wrapInList: () => wrapInList\n});\n\n// src/commands/blur.ts\nvar blur = () => ({ editor, view }) => {\n  requestAnimationFrame(() => {\n    var _a;\n    if (!editor.isDestroyed) {\n      ;\n      view.dom.blur();\n      (_a = window == null ? void 0 : window.getSelection()) == null ? void 0 : _a.removeAllRanges();\n    }\n  });\n  return true;\n};\n\n// src/commands/clearContent.ts\nvar clearContent = (emitUpdate = true) => ({ commands }) => {\n  return commands.setContent(\"\", { emitUpdate });\n};\n\n// src/commands/clearNodes.ts\n\nvar clearNodes = () => ({ state, tr, dispatch }) => {\n  const { selection } = tr;\n  const { ranges } = selection;\n  if (!dispatch) {\n    return true;\n  }\n  ranges.forEach(({ $from, $to }) => {\n    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n      if (node.type.isText) {\n        return;\n      }\n      const { doc, mapping } = tr;\n      const $mappedFrom = doc.resolve(mapping.map(pos));\n      const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));\n      const nodeRange = $mappedFrom.blockRange($mappedTo);\n      if (!nodeRange) {\n        return;\n      }\n      const targetLiftDepth = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(nodeRange);\n      if (node.type.isTextblock) {\n        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());\n        tr.setNodeMarkup(nodeRange.start, defaultType);\n      }\n      if (targetLiftDepth || targetLiftDepth === 0) {\n        tr.lift(nodeRange, targetLiftDepth);\n      }\n    });\n  });\n  return true;\n};\n\n// src/commands/command.ts\nvar command = (fn) => (props) => {\n  return fn(props);\n};\n\n// src/commands/createParagraphNear.ts\n\nvar createParagraphNear = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.createParagraphNear)(state, dispatch);\n};\n\n// src/commands/cut.ts\n\nvar cut = (originRange, targetPos) => ({ editor, tr }) => {\n  const { state } = editor;\n  const contentSlice = state.doc.slice(originRange.from, originRange.to);\n  tr.deleteRange(originRange.from, originRange.to);\n  const newPos = tr.mapping.map(targetPos);\n  tr.insert(newPos, contentSlice.content);\n  tr.setSelection(new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection(tr.doc.resolve(Math.max(newPos - 1, 0))));\n  return true;\n};\n\n// src/commands/deleteCurrentNode.ts\nvar deleteCurrentNode = () => ({ tr, dispatch }) => {\n  const { selection } = tr;\n  const currentNode = selection.$anchor.node();\n  if (currentNode.content.size > 0) {\n    return false;\n  }\n  const $pos = tr.selection.$anchor;\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth);\n    if (node.type === currentNode.type) {\n      if (dispatch) {\n        const from = $pos.before(depth);\n        const to = $pos.after(depth);\n        tr.delete(from, to).scrollIntoView();\n      }\n      return true;\n    }\n  }\n  return false;\n};\n\n// src/helpers/getNodeType.ts\nfunction getNodeType(nameOrType, schema) {\n  if (typeof nameOrType === \"string\") {\n    if (!schema.nodes[nameOrType]) {\n      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n    }\n    return schema.nodes[nameOrType];\n  }\n  return nameOrType;\n}\n\n// src/commands/deleteNode.ts\nvar deleteNode = (typeOrName) => ({ tr, state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const $pos = tr.selection.$anchor;\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth);\n    if (node.type === type) {\n      if (dispatch) {\n        const from = $pos.before(depth);\n        const to = $pos.after(depth);\n        tr.delete(from, to).scrollIntoView();\n      }\n      return true;\n    }\n  }\n  return false;\n};\n\n// src/commands/deleteRange.ts\nvar deleteRange = (range) => ({ tr, dispatch }) => {\n  const { from, to } = range;\n  if (dispatch) {\n    tr.delete(from, to);\n  }\n  return true;\n};\n\n// src/commands/deleteSelection.ts\n\nvar deleteSelection = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.deleteSelection)(state, dispatch);\n};\n\n// src/commands/enter.ts\nvar enter = () => ({ commands }) => {\n  return commands.keyboardShortcut(\"Enter\");\n};\n\n// src/commands/exitCode.ts\n\nvar exitCode = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.exitCode)(state, dispatch);\n};\n\n// src/commands/extendMarkRange.ts\n\n\n// src/utilities/isRegExp.ts\nfunction isRegExp(value) {\n  return Object.prototype.toString.call(value) === \"[object RegExp]\";\n}\n\n// src/utilities/objectIncludes.ts\nfunction objectIncludes(object1, object2, options = { strict: true }) {\n  const keys = Object.keys(object2);\n  if (!keys.length) {\n    return true;\n  }\n  return keys.every((key) => {\n    if (options.strict) {\n      return object2[key] === object1[key];\n    }\n    if (isRegExp(object2[key])) {\n      return object2[key].test(object1[key]);\n    }\n    return object2[key] === object1[key];\n  });\n}\n\n// src/helpers/getMarkRange.ts\nfunction findMarkInSet(marks, type, attributes = {}) {\n  return marks.find((item) => {\n    return item.type === type && objectIncludes(\n      // Only check equality for the attributes that are provided\n      Object.fromEntries(Object.keys(attributes).map((k) => [k, item.attrs[k]])),\n      attributes\n    );\n  });\n}\nfunction isMarkInSet(marks, type, attributes = {}) {\n  return !!findMarkInSet(marks, type, attributes);\n}\nfunction getMarkRange($pos, type, attributes) {\n  var _a;\n  if (!$pos || !type) {\n    return;\n  }\n  let start = $pos.parent.childAfter($pos.parentOffset);\n  if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {\n    start = $pos.parent.childBefore($pos.parentOffset);\n  }\n  if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {\n    return;\n  }\n  attributes = attributes || ((_a = start.node.marks[0]) == null ? void 0 : _a.attrs);\n  const mark = findMarkInSet([...start.node.marks], type, attributes);\n  if (!mark) {\n    return;\n  }\n  let startIndex = start.index;\n  let startPos = $pos.start() + start.offset;\n  let endIndex = startIndex + 1;\n  let endPos = startPos + start.node.nodeSize;\n  while (startIndex > 0 && isMarkInSet([...$pos.parent.child(startIndex - 1).marks], type, attributes)) {\n    startIndex -= 1;\n    startPos -= $pos.parent.child(startIndex).nodeSize;\n  }\n  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {\n    endPos += $pos.parent.child(endIndex).nodeSize;\n    endIndex += 1;\n  }\n  return {\n    from: startPos,\n    to: endPos\n  };\n}\n\n// src/helpers/getMarkType.ts\nfunction getMarkType(nameOrType, schema) {\n  if (typeof nameOrType === \"string\") {\n    if (!schema.marks[nameOrType]) {\n      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n    }\n    return schema.marks[nameOrType];\n  }\n  return nameOrType;\n}\n\n// src/commands/extendMarkRange.ts\nvar extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  const type = getMarkType(typeOrName, state.schema);\n  const { doc, selection } = tr;\n  const { $from, from, to } = selection;\n  if (dispatch) {\n    const range = getMarkRange($from, type, attributes);\n    if (range && range.from <= from && range.to >= to) {\n      const newSelection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.create(doc, range.from, range.to);\n      tr.setSelection(newSelection);\n    }\n  }\n  return true;\n};\n\n// src/commands/first.ts\nvar first = (commands) => (props) => {\n  const items = typeof commands === \"function\" ? commands(props) : commands;\n  for (let i = 0; i < items.length; i += 1) {\n    if (items[i](props)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n// src/helpers/isTextSelection.ts\n\nfunction isTextSelection(value) {\n  return value instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection;\n}\n\n// src/helpers/resolveFocusPosition.ts\n\n\n// src/utilities/minMax.ts\nfunction minMax(value = 0, min = 0, max = 0) {\n  return Math.min(Math.max(value, min), max);\n}\n\n// src/helpers/resolveFocusPosition.ts\nfunction resolveFocusPosition(doc, position = null) {\n  if (!position) {\n    return null;\n  }\n  const selectionAtStart = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Selection.atStart(doc);\n  const selectionAtEnd = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Selection.atEnd(doc);\n  if (position === \"start\" || position === true) {\n    return selectionAtStart;\n  }\n  if (position === \"end\") {\n    return selectionAtEnd;\n  }\n  const minPos = selectionAtStart.from;\n  const maxPos = selectionAtEnd.to;\n  if (position === \"all\") {\n    return _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.create(doc, minMax(0, minPos, maxPos), minMax(doc.content.size, minPos, maxPos));\n  }\n  return _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.create(doc, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));\n}\n\n// src/utilities/isAndroid.ts\nfunction isAndroid() {\n  return navigator.platform === \"Android\" || /android/i.test(navigator.userAgent);\n}\n\n// src/utilities/isiOS.ts\nfunction isiOS() {\n  return [\"iPad Simulator\", \"iPhone Simulator\", \"iPod Simulator\", \"iPad\", \"iPhone\", \"iPod\"].includes(navigator.platform) || // iPad on iOS 13 detection\n  navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document;\n}\n\n// src/commands/focus.ts\nvar focus = (position = null, options = {}) => ({ editor, view, tr, dispatch }) => {\n  options = {\n    scrollIntoView: true,\n    ...options\n  };\n  const delayedFocus = () => {\n    if (isiOS() || isAndroid()) {\n      ;\n      view.dom.focus();\n    }\n    requestAnimationFrame(() => {\n      if (!editor.isDestroyed) {\n        view.focus();\n        if (options == null ? void 0 : options.scrollIntoView) {\n          editor.commands.scrollIntoView();\n        }\n      }\n    });\n  };\n  if (view.hasFocus() && position === null || position === false) {\n    return true;\n  }\n  if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n    delayedFocus();\n    return true;\n  }\n  const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;\n  const isSameSelection = editor.state.selection.eq(selection);\n  if (dispatch) {\n    if (!isSameSelection) {\n      tr.setSelection(selection);\n    }\n    if (isSameSelection && tr.storedMarks) {\n      tr.setStoredMarks(tr.storedMarks);\n    }\n    delayedFocus();\n  }\n  return true;\n};\n\n// src/commands/forEach.ts\nvar forEach = (items, fn) => (props) => {\n  return items.every((item, index) => fn(item, { ...props, index }));\n};\n\n// src/commands/insertContent.ts\nvar insertContent = (value, options) => ({ tr, commands }) => {\n  return commands.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);\n};\n\n// src/commands/insertContentAt.ts\n\n\n// src/helpers/createNodeFromContent.ts\n\n\n// src/utilities/elementFromString.ts\nvar removeWhitespaces = (node) => {\n  const children = node.childNodes;\n  for (let i = children.length - 1; i >= 0; i -= 1) {\n    const child = children[i];\n    if (child.nodeType === 3 && child.nodeValue && /^(\\n\\s\\s|\\n)$/.test(child.nodeValue)) {\n      node.removeChild(child);\n    } else if (child.nodeType === 1) {\n      removeWhitespaces(child);\n    }\n  }\n  return node;\n};\nfunction elementFromString(value) {\n  if (typeof window === \"undefined\") {\n    throw new Error(\"[tiptap error]: there is no window object available, so this function cannot be used\");\n  }\n  const wrappedValue = `<body>${value}</body>`;\n  const html = new window.DOMParser().parseFromString(wrappedValue, \"text/html\").body;\n  return removeWhitespaces(html);\n}\n\n// src/helpers/createNodeFromContent.ts\nfunction createNodeFromContent(content, schema, options) {\n  if (content instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node || content instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment) {\n    return content;\n  }\n  options = {\n    slice: true,\n    parseOptions: {},\n    ...options\n  };\n  const isJSONContent = typeof content === \"object\" && content !== null;\n  const isTextContent = typeof content === \"string\";\n  if (isJSONContent) {\n    try {\n      const isArrayContent = Array.isArray(content) && content.length > 0;\n      if (isArrayContent) {\n        return _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));\n      }\n      const node = schema.nodeFromJSON(content);\n      if (options.errorOnInvalidContent) {\n        node.check();\n      }\n      return node;\n    } catch (error) {\n      if (options.errorOnInvalidContent) {\n        throw new Error(\"[tiptap error]: Invalid JSON content\", { cause: error });\n      }\n      console.warn(\"[tiptap warn]: Invalid content.\", \"Passed value:\", content, \"Error:\", error);\n      return createNodeFromContent(\"\", schema, options);\n    }\n  }\n  if (isTextContent) {\n    if (options.errorOnInvalidContent) {\n      let hasInvalidContent = false;\n      let invalidContent = \"\";\n      const contentCheckSchema = new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Schema({\n        topNode: schema.spec.topNode,\n        marks: schema.spec.marks,\n        // Prosemirror's schemas are executed such that: the last to execute, matches last\n        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle\n        nodes: schema.spec.nodes.append({\n          __tiptap__private__unknown__catch__all__node: {\n            content: \"inline*\",\n            group: \"block\",\n            parseDOM: [\n              {\n                tag: \"*\",\n                getAttrs: (e) => {\n                  hasInvalidContent = true;\n                  invalidContent = typeof e === \"string\" ? e : e.outerHTML;\n                  return null;\n                }\n              }\n            ]\n          }\n        })\n      });\n      if (options.slice) {\n        _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options.parseOptions);\n      } else {\n        _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(contentCheckSchema).parse(elementFromString(content), options.parseOptions);\n      }\n      if (options.errorOnInvalidContent && hasInvalidContent) {\n        throw new Error(\"[tiptap error]: Invalid HTML content\", {\n          cause: new Error(`Invalid element found: ${invalidContent}`)\n        });\n      }\n    }\n    const parser = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(schema);\n    if (options.slice) {\n      return parser.parseSlice(elementFromString(content), options.parseOptions).content;\n    }\n    return parser.parse(elementFromString(content), options.parseOptions);\n  }\n  return createNodeFromContent(\"\", schema, options);\n}\n\n// src/helpers/selectionToInsertionEnd.ts\n\n\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  const last = tr.steps.length - 1;\n  if (last < startLen) {\n    return;\n  }\n  const step = tr.steps[last];\n  if (!(step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceStep || step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep)) {\n    return;\n  }\n  const map = tr.mapping.maps[last];\n  let end = 0;\n  map.forEach((_from, _to, _newFrom, newTo) => {\n    if (end === 0) {\n      end = newTo;\n    }\n  });\n  tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Selection.near(tr.doc.resolve(end), bias));\n}\n\n// src/commands/insertContentAt.ts\nvar isFragment = (nodeOrFragment) => {\n  return !(\"type\" in nodeOrFragment);\n};\nvar insertContentAt = (position, value, options) => ({ tr, dispatch, editor }) => {\n  var _a;\n  if (dispatch) {\n    options = {\n      parseOptions: editor.options.parseOptions,\n      updateSelection: true,\n      applyInputRules: false,\n      applyPasteRules: false,\n      ...options\n    };\n    let content;\n    const emitContentError = (error) => {\n      editor.emit(\"contentError\", {\n        editor,\n        error,\n        disableCollaboration: () => {\n          if (\"collaboration\" in editor.storage && typeof editor.storage.collaboration === \"object\" && editor.storage.collaboration) {\n            ;\n            editor.storage.collaboration.isDisabled = true;\n          }\n        }\n      });\n    };\n    const parseOptions = {\n      preserveWhitespace: \"full\",\n      ...options.parseOptions\n    };\n    if (!options.errorOnInvalidContent && !editor.options.enableContentCheck && editor.options.emitContentError) {\n      try {\n        createNodeFromContent(value, editor.schema, {\n          parseOptions,\n          errorOnInvalidContent: true\n        });\n      } catch (e) {\n        emitContentError(e);\n      }\n    }\n    try {\n      content = createNodeFromContent(value, editor.schema, {\n        parseOptions,\n        errorOnInvalidContent: (_a = options.errorOnInvalidContent) != null ? _a : editor.options.enableContentCheck\n      });\n    } catch (e) {\n      emitContentError(e);\n      return false;\n    }\n    let { from, to } = typeof position === \"number\" ? { from: position, to: position } : { from: position.from, to: position.to };\n    let isOnlyTextContent = true;\n    let isOnlyBlockContent = true;\n    const nodes = isFragment(content) ? content : [content];\n    nodes.forEach((node) => {\n      node.check();\n      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;\n      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;\n    });\n    if (from === to && isOnlyBlockContent) {\n      const { parent } = tr.doc.resolve(from);\n      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;\n      if (isEmptyTextBlock) {\n        from -= 1;\n        to += 1;\n      }\n    }\n    let newContent;\n    if (isOnlyTextContent) {\n      if (Array.isArray(value)) {\n        newContent = value.map((v) => v.text || \"\").join(\"\");\n      } else if (value instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment) {\n        let text = \"\";\n        value.forEach((node) => {\n          if (node.text) {\n            text += node.text;\n          }\n        });\n        newContent = text;\n      } else if (typeof value === \"object\" && !!value && !!value.text) {\n        newContent = value.text;\n      } else {\n        newContent = value;\n      }\n      tr.insertText(newContent, from, to);\n    } else {\n      newContent = content;\n      const $from = tr.doc.resolve(from);\n      const $fromNode = $from.node();\n      const fromSelectionAtStart = $from.parentOffset === 0;\n      const isTextSelection2 = $fromNode.isText || $fromNode.isTextblock;\n      const hasContent = $fromNode.content.size > 0;\n      if (fromSelectionAtStart && isTextSelection2 && hasContent) {\n        from = Math.max(0, from - 1);\n      }\n      tr.replaceWith(from, to, newContent);\n    }\n    if (options.updateSelection) {\n      selectionToInsertionEnd(tr, tr.steps.length - 1, -1);\n    }\n    if (options.applyInputRules) {\n      tr.setMeta(\"applyInputRules\", { from, text: newContent });\n    }\n    if (options.applyPasteRules) {\n      tr.setMeta(\"applyPasteRules\", { from, text: newContent });\n    }\n  }\n  return true;\n};\n\n// src/commands/join.ts\n\nvar joinUp = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.joinUp)(state, dispatch);\n};\nvar joinDown = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.joinDown)(state, dispatch);\n};\nvar joinBackward = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.joinBackward)(state, dispatch);\n};\nvar joinForward = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.joinForward)(state, dispatch);\n};\n\n// src/commands/joinItemBackward.ts\n\nvar joinItemBackward = () => ({ state, dispatch, tr }) => {\n  try {\n    const point = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, state.selection.$from.pos, -1);\n    if (point === null || point === void 0) {\n      return false;\n    }\n    tr.join(point, 2);\n    if (dispatch) {\n      dispatch(tr);\n    }\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n// src/commands/joinItemForward.ts\n\nvar joinItemForward = () => ({ state, dispatch, tr }) => {\n  try {\n    const point = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, state.selection.$from.pos, 1);\n    if (point === null || point === void 0) {\n      return false;\n    }\n    tr.join(point, 2);\n    if (dispatch) {\n      dispatch(tr);\n    }\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n// src/commands/joinTextblockBackward.ts\n\nvar joinTextblockBackward = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.joinTextblockBackward)(state, dispatch);\n};\n\n// src/commands/joinTextblockForward.ts\n\nvar joinTextblockForward = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.joinTextblockForward)(state, dispatch);\n};\n\n// src/utilities/isMacOS.ts\nfunction isMacOS() {\n  return typeof navigator !== \"undefined\" ? /Mac/.test(navigator.platform) : false;\n}\n\n// src/commands/keyboardShortcut.ts\nfunction normalizeKeyName(name) {\n  const parts = name.split(/-(?!$)/);\n  let result = parts[parts.length - 1];\n  if (result === \"Space\") {\n    result = \" \";\n  }\n  let alt;\n  let ctrl;\n  let shift;\n  let meta;\n  for (let i = 0; i < parts.length - 1; i += 1) {\n    const mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) {\n      meta = true;\n    } else if (/^a(lt)?$/i.test(mod)) {\n      alt = true;\n    } else if (/^(c|ctrl|control)$/i.test(mod)) {\n      ctrl = true;\n    } else if (/^s(hift)?$/i.test(mod)) {\n      shift = true;\n    } else if (/^mod$/i.test(mod)) {\n      if (isiOS() || isMacOS()) {\n        meta = true;\n      } else {\n        ctrl = true;\n      }\n    } else {\n      throw new Error(`Unrecognized modifier name: ${mod}`);\n    }\n  }\n  if (alt) {\n    result = `Alt-${result}`;\n  }\n  if (ctrl) {\n    result = `Ctrl-${result}`;\n  }\n  if (meta) {\n    result = `Meta-${result}`;\n  }\n  if (shift) {\n    result = `Shift-${result}`;\n  }\n  return result;\n}\nvar keyboardShortcut = (name) => ({ editor, view, tr, dispatch }) => {\n  const keys = normalizeKeyName(name).split(/-(?!$)/);\n  const key = keys.find((item) => ![\"Alt\", \"Ctrl\", \"Meta\", \"Shift\"].includes(item));\n  const event = new KeyboardEvent(\"keydown\", {\n    key: key === \"Space\" ? \" \" : key,\n    altKey: keys.includes(\"Alt\"),\n    ctrlKey: keys.includes(\"Ctrl\"),\n    metaKey: keys.includes(\"Meta\"),\n    shiftKey: keys.includes(\"Shift\"),\n    bubbles: true,\n    cancelable: true\n  });\n  const capturedTransaction = editor.captureTransaction(() => {\n    view.someProp(\"handleKeyDown\", (f) => f(view, event));\n  });\n  capturedTransaction == null ? void 0 : capturedTransaction.steps.forEach((step) => {\n    const newStep = step.map(tr.mapping);\n    if (newStep && dispatch) {\n      tr.maybeStep(newStep);\n    }\n  });\n  return true;\n};\n\n// src/commands/lift.ts\n\n\n// src/helpers/isNodeActive.ts\nfunction isNodeActive(state, typeOrName, attributes = {}) {\n  const { from, to, empty } = state.selection;\n  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;\n  const nodeRanges = [];\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isText) {\n      return;\n    }\n    const relativeFrom = Math.max(from, pos);\n    const relativeTo = Math.min(to, pos + node.nodeSize);\n    nodeRanges.push({\n      node,\n      from: relativeFrom,\n      to: relativeTo\n    });\n  });\n  const selectionRange = to - from;\n  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {\n    if (!type) {\n      return true;\n    }\n    return type.name === nodeRange.node.type.name;\n  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));\n  if (empty) {\n    return !!matchedNodeRanges.length;\n  }\n  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);\n  return range >= selectionRange;\n}\n\n// src/commands/lift.ts\nvar lift = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const isActive2 = isNodeActive(state, type, attributes);\n  if (!isActive2) {\n    return false;\n  }\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.lift)(state, dispatch);\n};\n\n// src/commands/liftEmptyBlock.ts\n\nvar liftEmptyBlock = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.liftEmptyBlock)(state, dispatch);\n};\n\n// src/commands/liftListItem.ts\n\nvar liftListItem = (typeOrName) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_4__.liftListItem)(type)(state, dispatch);\n};\n\n// src/commands/newlineInCode.ts\n\nvar newlineInCode = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.newlineInCode)(state, dispatch);\n};\n\n// src/helpers/getSchemaTypeNameByName.ts\nfunction getSchemaTypeNameByName(name, schema) {\n  if (schema.nodes[name]) {\n    return \"node\";\n  }\n  if (schema.marks[name]) {\n    return \"mark\";\n  }\n  return null;\n}\n\n// src/utilities/deleteProps.ts\nfunction deleteProps(obj, propOrProps) {\n  const props = typeof propOrProps === \"string\" ? [propOrProps] : propOrProps;\n  return Object.keys(obj).reduce((newObj, prop) => {\n    if (!props.includes(prop)) {\n      newObj[prop] = obj[prop];\n    }\n    return newObj;\n  }, {});\n}\n\n// src/commands/resetAttributes.ts\nvar resetAttributes = (typeOrName, attributes) => ({ tr, state, dispatch }) => {\n  let nodeType = null;\n  let markType = null;\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === \"string\" ? typeOrName : typeOrName.name,\n    state.schema\n  );\n  if (!schemaType) {\n    return false;\n  }\n  if (schemaType === \"node\") {\n    nodeType = getNodeType(typeOrName, state.schema);\n  }\n  if (schemaType === \"mark\") {\n    markType = getMarkType(typeOrName, state.schema);\n  }\n  if (dispatch) {\n    tr.selection.ranges.forEach((range) => {\n      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));\n        }\n        if (markType && node.marks.length) {\n          node.marks.forEach((mark) => {\n            if (markType === mark.type) {\n              tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));\n            }\n          });\n        }\n      });\n    });\n  }\n  return true;\n};\n\n// src/commands/scrollIntoView.ts\nvar scrollIntoView = () => ({ tr, dispatch }) => {\n  if (dispatch) {\n    tr.scrollIntoView();\n  }\n  return true;\n};\n\n// src/commands/selectAll.ts\n\nvar selectAll = () => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const selection = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.AllSelection(tr.doc);\n    tr.setSelection(selection);\n  }\n  return true;\n};\n\n// src/commands/selectNodeBackward.ts\n\nvar selectNodeBackward = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.selectNodeBackward)(state, dispatch);\n};\n\n// src/commands/selectNodeForward.ts\n\nvar selectNodeForward = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.selectNodeForward)(state, dispatch);\n};\n\n// src/commands/selectParentNode.ts\n\nvar selectParentNode = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.selectParentNode)(state, dispatch);\n};\n\n// src/commands/selectTextblockEnd.ts\n\nvar selectTextblockEnd = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.selectTextblockEnd)(state, dispatch);\n};\n\n// src/commands/selectTextblockStart.ts\n\nvar selectTextblockStart = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.selectTextblockStart)(state, dispatch);\n};\n\n// src/helpers/createDocument.ts\nfunction createDocument(content, schema, parseOptions = {}, options = {}) {\n  return createNodeFromContent(content, schema, {\n    slice: false,\n    parseOptions,\n    errorOnInvalidContent: options.errorOnInvalidContent\n  });\n}\n\n// src/commands/setContent.ts\nvar setContent = (content, { errorOnInvalidContent, emitUpdate = true, parseOptions = {} } = {}) => ({ editor, tr, dispatch, commands }) => {\n  const { doc } = tr;\n  if (parseOptions.preserveWhitespace !== \"full\") {\n    const document2 = createDocument(content, editor.schema, parseOptions, {\n      errorOnInvalidContent: errorOnInvalidContent != null ? errorOnInvalidContent : editor.options.enableContentCheck\n    });\n    if (dispatch) {\n      tr.replaceWith(0, doc.content.size, document2).setMeta(\"preventUpdate\", !emitUpdate);\n    }\n    return true;\n  }\n  if (dispatch) {\n    tr.setMeta(\"preventUpdate\", !emitUpdate);\n  }\n  return commands.insertContentAt({ from: 0, to: doc.content.size }, content, {\n    parseOptions,\n    errorOnInvalidContent: errorOnInvalidContent != null ? errorOnInvalidContent : editor.options.enableContentCheck\n  });\n};\n\n// src/helpers/getMarkAttributes.ts\nfunction getMarkAttributes(state, typeOrName) {\n  const type = getMarkType(typeOrName, state.schema);\n  const { from, to, empty } = state.selection;\n  const marks = [];\n  if (empty) {\n    if (state.storedMarks) {\n      marks.push(...state.storedMarks);\n    }\n    marks.push(...state.selection.$head.marks());\n  } else {\n    state.doc.nodesBetween(from, to, (node) => {\n      marks.push(...node.marks);\n    });\n  }\n  const mark = marks.find((markItem) => markItem.type.name === type.name);\n  if (!mark) {\n    return {};\n  }\n  return { ...mark.attrs };\n}\n\n// src/helpers/combineTransactionSteps.ts\n\nfunction combineTransactionSteps(oldDoc, transactions) {\n  const transform = new _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.Transform(oldDoc);\n  transactions.forEach((transaction) => {\n    transaction.steps.forEach((step) => {\n      transform.step(step);\n    });\n  });\n  return transform;\n}\n\n// src/helpers/defaultBlockAt.ts\nfunction defaultBlockAt(match) {\n  for (let i = 0; i < match.edgeCount; i += 1) {\n    const { type } = match.edge(i);\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type;\n    }\n  }\n  return null;\n}\n\n// src/helpers/findChildren.ts\nfunction findChildren(node, predicate) {\n  const nodesWithPos = [];\n  node.descendants((child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\n\n// src/helpers/findChildrenInRange.ts\nfunction findChildrenInRange(node, range, predicate) {\n  const nodesWithPos = [];\n  node.nodesBetween(range.from, range.to, (child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\n\n// src/helpers/findParentNodeClosestToPos.ts\nfunction findParentNodeClosestToPos($pos, predicate) {\n  for (let i = $pos.depth; i > 0; i -= 1) {\n    const node = $pos.node(i);\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node\n      };\n    }\n  }\n}\n\n// src/helpers/findParentNode.ts\nfunction findParentNode(predicate) {\n  return (selection) => findParentNodeClosestToPos(selection.$from, predicate);\n}\n\n// src/helpers/getExtensionField.ts\nfunction getExtensionField(extension, field, context) {\n  if (extension.config[field] === void 0 && extension.parent) {\n    return getExtensionField(extension.parent, field, context);\n  }\n  if (typeof extension.config[field] === \"function\") {\n    const value = extension.config[field].bind({\n      ...context,\n      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null\n    });\n    return value;\n  }\n  return extension.config[field];\n}\n\n// src/helpers/flattenExtensions.ts\nfunction flattenExtensions(extensions) {\n  return extensions.map((extension) => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const addExtensions = getExtensionField(extension, \"addExtensions\", context);\n    if (addExtensions) {\n      return [extension, ...flattenExtensions(addExtensions())];\n    }\n    return extension;\n  }).flat(10);\n}\n\n// src/helpers/generateHTML.ts\n\n\n// src/helpers/getHTMLFromFragment.ts\n\nfunction getHTMLFromFragment(fragment, schema) {\n  const documentFragment = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMSerializer.fromSchema(schema).serializeFragment(fragment);\n  const temporaryDocument = document.implementation.createHTMLDocument();\n  const container = temporaryDocument.createElement(\"div\");\n  container.appendChild(documentFragment);\n  return container.innerHTML;\n}\n\n// src/helpers/getSchemaByResolvedExtensions.ts\n\n\n// src/utilities/isFunction.ts\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\n\n// src/utilities/callOrReturn.ts\nfunction callOrReturn(value, context = void 0, ...props) {\n  if (isFunction(value)) {\n    if (context) {\n      return value.bind(context)(...props);\n    }\n    return value(...props);\n  }\n  return value;\n}\n\n// src/utilities/isEmptyObject.ts\nfunction isEmptyObject(value = {}) {\n  return Object.keys(value).length === 0 && value.constructor === Object;\n}\n\n// src/helpers/splitExtensions.ts\nfunction splitExtensions(extensions) {\n  const baseExtensions = extensions.filter((extension) => extension.type === \"extension\");\n  const nodeExtensions = extensions.filter((extension) => extension.type === \"node\");\n  const markExtensions = extensions.filter((extension) => extension.type === \"mark\");\n  return {\n    baseExtensions,\n    nodeExtensions,\n    markExtensions\n  };\n}\n\n// src/helpers/getAttributesFromExtensions.ts\nfunction getAttributesFromExtensions(extensions) {\n  const extensionAttributes = [];\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions);\n  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];\n  const defaultAttribute = {\n    default: null,\n    validate: void 0,\n    rendered: true,\n    renderHTML: null,\n    parseHTML: null,\n    keepOnSplit: true,\n    isRequired: false\n  };\n  extensions.forEach((extension) => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n      extensions: nodeAndMarkExtensions\n    };\n    const addGlobalAttributes = getExtensionField(\n      extension,\n      \"addGlobalAttributes\",\n      context\n    );\n    if (!addGlobalAttributes) {\n      return;\n    }\n    const globalAttributes = addGlobalAttributes();\n    globalAttributes.forEach((globalAttribute) => {\n      globalAttribute.types.forEach((type) => {\n        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {\n          extensionAttributes.push({\n            type,\n            name,\n            attribute: {\n              ...defaultAttribute,\n              ...attribute\n            }\n          });\n        });\n      });\n    });\n  });\n  nodeAndMarkExtensions.forEach((extension) => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const addAttributes = getExtensionField(\n      extension,\n      \"addAttributes\",\n      context\n    );\n    if (!addAttributes) {\n      return;\n    }\n    const attributes = addAttributes();\n    Object.entries(attributes).forEach(([name, attribute]) => {\n      const mergedAttr = {\n        ...defaultAttribute,\n        ...attribute\n      };\n      if (typeof (mergedAttr == null ? void 0 : mergedAttr.default) === \"function\") {\n        mergedAttr.default = mergedAttr.default();\n      }\n      if ((mergedAttr == null ? void 0 : mergedAttr.isRequired) && (mergedAttr == null ? void 0 : mergedAttr.default) === void 0) {\n        delete mergedAttr.default;\n      }\n      extensionAttributes.push({\n        type: extension.name,\n        name,\n        attribute: mergedAttr\n      });\n    });\n  });\n  return extensionAttributes;\n}\n\n// src/utilities/mergeAttributes.ts\nfunction mergeAttributes(...objects) {\n  return objects.filter((item) => !!item).reduce((items, item) => {\n    const mergedAttributes = { ...items };\n    Object.entries(item).forEach(([key, value]) => {\n      const exists = mergedAttributes[key];\n      if (!exists) {\n        mergedAttributes[key] = value;\n        return;\n      }\n      if (key === \"class\") {\n        const valueClasses = value ? String(value).split(\" \") : [];\n        const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(\" \") : [];\n        const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));\n        mergedAttributes[key] = [...existingClasses, ...insertClasses].join(\" \");\n      } else if (key === \"style\") {\n        const newStyles = value ? value.split(\";\").map((style2) => style2.trim()).filter(Boolean) : [];\n        const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(\";\").map((style2) => style2.trim()).filter(Boolean) : [];\n        const styleMap = /* @__PURE__ */ new Map();\n        existingStyles.forEach((style2) => {\n          const [property, val] = style2.split(\":\").map((part) => part.trim());\n          styleMap.set(property, val);\n        });\n        newStyles.forEach((style2) => {\n          const [property, val] = style2.split(\":\").map((part) => part.trim());\n          styleMap.set(property, val);\n        });\n        mergedAttributes[key] = Array.from(styleMap.entries()).map(([property, val]) => `${property}: ${val}`).join(\"; \");\n      } else {\n        mergedAttributes[key] = value;\n      }\n    });\n    return mergedAttributes;\n  }, {});\n}\n\n// src/helpers/getRenderedAttributes.ts\nfunction getRenderedAttributes(nodeOrMark, extensionAttributes) {\n  return extensionAttributes.filter((attribute) => attribute.type === nodeOrMark.type.name).filter((item) => item.attribute.rendered).map((item) => {\n    if (!item.attribute.renderHTML) {\n      return {\n        [item.name]: nodeOrMark.attrs[item.name]\n      };\n    }\n    return item.attribute.renderHTML(nodeOrMark.attrs) || {};\n  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});\n}\n\n// src/utilities/fromString.ts\nfunction fromString(value) {\n  if (typeof value !== \"string\") {\n    return value;\n  }\n  if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\n    return Number(value);\n  }\n  if (value === \"true\") {\n    return true;\n  }\n  if (value === \"false\") {\n    return false;\n  }\n  return value;\n}\n\n// src/helpers/injectExtensionAttributesToParseRule.ts\nfunction injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {\n  if (\"style\" in parseRule) {\n    return parseRule;\n  }\n  return {\n    ...parseRule,\n    getAttrs: (node) => {\n      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;\n      if (oldAttributes === false) {\n        return false;\n      }\n      const newAttributes = extensionAttributes.reduce((items, item) => {\n        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));\n        if (value === null || value === void 0) {\n          return items;\n        }\n        return {\n          ...items,\n          [item.name]: value\n        };\n      }, {});\n      return { ...oldAttributes, ...newAttributes };\n    }\n  };\n}\n\n// src/helpers/getSchemaByResolvedExtensions.ts\nfunction cleanUpSchemaItem(data) {\n  return Object.fromEntries(\n    // @ts-ignore\n    Object.entries(data).filter(([key, value]) => {\n      if (key === \"attrs\" && isEmptyObject(value)) {\n        return false;\n      }\n      return value !== null && value !== void 0;\n    })\n  );\n}\nfunction getSchemaByResolvedExtensions(extensions, editor) {\n  var _a;\n  const allAttributes = getAttributesFromExtensions(extensions);\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions);\n  const topNode = (_a = nodeExtensions.find((extension) => getExtensionField(extension, \"topNode\"))) == null ? void 0 : _a.name;\n  const nodes = Object.fromEntries(\n    nodeExtensions.map((extension) => {\n      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor\n      };\n      const extraNodeFields = extensions.reduce((fields, e) => {\n        const extendNodeSchema = getExtensionField(e, \"extendNodeSchema\", context);\n        return {\n          ...fields,\n          ...extendNodeSchema ? extendNodeSchema(extension) : {}\n        };\n      }, {});\n      const schema = cleanUpSchemaItem({\n        ...extraNodeFields,\n        content: callOrReturn(getExtensionField(extension, \"content\", context)),\n        marks: callOrReturn(getExtensionField(extension, \"marks\", context)),\n        group: callOrReturn(getExtensionField(extension, \"group\", context)),\n        inline: callOrReturn(getExtensionField(extension, \"inline\", context)),\n        atom: callOrReturn(getExtensionField(extension, \"atom\", context)),\n        selectable: callOrReturn(getExtensionField(extension, \"selectable\", context)),\n        draggable: callOrReturn(getExtensionField(extension, \"draggable\", context)),\n        code: callOrReturn(getExtensionField(extension, \"code\", context)),\n        whitespace: callOrReturn(getExtensionField(extension, \"whitespace\", context)),\n        linebreakReplacement: callOrReturn(\n          getExtensionField(extension, \"linebreakReplacement\", context)\n        ),\n        defining: callOrReturn(getExtensionField(extension, \"defining\", context)),\n        isolating: callOrReturn(getExtensionField(extension, \"isolating\", context)),\n        attrs: Object.fromEntries(\n          extensionAttributes.map((extensionAttribute) => {\n            var _a2, _b;\n            return [\n              extensionAttribute.name,\n              { default: (_a2 = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _a2.default, validate: (_b = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _b.validate }\n            ];\n          })\n        )\n      });\n      const parseHTML = callOrReturn(getExtensionField(extension, \"parseHTML\", context));\n      if (parseHTML) {\n        schema.parseDOM = parseHTML.map(\n          (parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes)\n        );\n      }\n      const renderHTML = getExtensionField(extension, \"renderHTML\", context);\n      if (renderHTML) {\n        schema.toDOM = (node) => renderHTML({\n          node,\n          HTMLAttributes: getRenderedAttributes(node, extensionAttributes)\n        });\n      }\n      const renderText = getExtensionField(extension, \"renderText\", context);\n      if (renderText) {\n        schema.toText = renderText;\n      }\n      return [extension.name, schema];\n    })\n  );\n  const marks = Object.fromEntries(\n    markExtensions.map((extension) => {\n      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor\n      };\n      const extraMarkFields = extensions.reduce((fields, e) => {\n        const extendMarkSchema = getExtensionField(e, \"extendMarkSchema\", context);\n        return {\n          ...fields,\n          ...extendMarkSchema ? extendMarkSchema(extension) : {}\n        };\n      }, {});\n      const schema = cleanUpSchemaItem({\n        ...extraMarkFields,\n        inclusive: callOrReturn(getExtensionField(extension, \"inclusive\", context)),\n        excludes: callOrReturn(getExtensionField(extension, \"excludes\", context)),\n        group: callOrReturn(getExtensionField(extension, \"group\", context)),\n        spanning: callOrReturn(getExtensionField(extension, \"spanning\", context)),\n        code: callOrReturn(getExtensionField(extension, \"code\", context)),\n        attrs: Object.fromEntries(\n          extensionAttributes.map((extensionAttribute) => {\n            var _a2, _b;\n            return [\n              extensionAttribute.name,\n              { default: (_a2 = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _a2.default, validate: (_b = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _b.validate }\n            ];\n          })\n        )\n      });\n      const parseHTML = callOrReturn(getExtensionField(extension, \"parseHTML\", context));\n      if (parseHTML) {\n        schema.parseDOM = parseHTML.map(\n          (parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes)\n        );\n      }\n      const renderHTML = getExtensionField(extension, \"renderHTML\", context);\n      if (renderHTML) {\n        schema.toDOM = (mark) => renderHTML({\n          mark,\n          HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)\n        });\n      }\n      return [extension.name, schema];\n    })\n  );\n  return new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Schema({\n    topNode,\n    nodes,\n    marks\n  });\n}\n\n// src/utilities/findDuplicates.ts\nfunction findDuplicates(items) {\n  const filtered = items.filter((el, index) => items.indexOf(el) !== index);\n  return Array.from(new Set(filtered));\n}\n\n// src/helpers/sortExtensions.ts\nfunction sortExtensions(extensions) {\n  const defaultPriority = 100;\n  return extensions.sort((a, b) => {\n    const priorityA = getExtensionField(a, \"priority\") || defaultPriority;\n    const priorityB = getExtensionField(b, \"priority\") || defaultPriority;\n    if (priorityA > priorityB) {\n      return -1;\n    }\n    if (priorityA < priorityB) {\n      return 1;\n    }\n    return 0;\n  });\n}\n\n// src/helpers/resolveExtensions.ts\nfunction resolveExtensions(extensions) {\n  const resolvedExtensions = sortExtensions(flattenExtensions(extensions));\n  const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));\n  if (duplicatedNames.length) {\n    console.warn(\n      `[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(\", \")}]. This can lead to issues.`\n    );\n  }\n  return resolvedExtensions;\n}\n\n// src/helpers/getSchema.ts\nfunction getSchema(extensions, editor) {\n  const resolvedExtensions = resolveExtensions(extensions);\n  return getSchemaByResolvedExtensions(resolvedExtensions, editor);\n}\n\n// src/helpers/generateHTML.ts\nfunction generateHTML(doc, extensions) {\n  const schema = getSchema(extensions);\n  const contentNode = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node.fromJSON(schema, doc);\n  return getHTMLFromFragment(contentNode.content, schema);\n}\n\n// src/helpers/generateJSON.ts\n\nfunction generateJSON(html, extensions) {\n  const schema = getSchema(extensions);\n  const dom = elementFromString(html);\n  return _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(schema).parse(dom).toJSON();\n}\n\n// src/helpers/generateText.ts\n\n\n// src/helpers/getTextBetween.ts\nfunction getTextBetween(startNode, range, options) {\n  const { from, to } = range;\n  const { blockSeparator = \"\\n\\n\", textSerializers = {} } = options || {};\n  let text = \"\";\n  startNode.nodesBetween(from, to, (node, pos, parent, index) => {\n    var _a;\n    if (node.isBlock && pos > from) {\n      text += blockSeparator;\n    }\n    const textSerializer = textSerializers == null ? void 0 : textSerializers[node.type.name];\n    if (textSerializer) {\n      if (parent) {\n        text += textSerializer({\n          node,\n          pos,\n          parent,\n          index,\n          range\n        });\n      }\n      return false;\n    }\n    if (node.isText) {\n      text += (_a = node == null ? void 0 : node.text) == null ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos);\n    }\n  });\n  return text;\n}\n\n// src/helpers/getText.ts\nfunction getText(node, options) {\n  const range = {\n    from: 0,\n    to: node.content.size\n  };\n  return getTextBetween(node, range, options);\n}\n\n// src/helpers/getTextSerializersFromSchema.ts\nfunction getTextSerializersFromSchema(schema) {\n  return Object.fromEntries(\n    Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText])\n  );\n}\n\n// src/helpers/generateText.ts\nfunction generateText(doc, extensions, options) {\n  const { blockSeparator = \"\\n\\n\", textSerializers = {} } = options || {};\n  const schema = getSchema(extensions);\n  const contentNode = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node.fromJSON(schema, doc);\n  return getText(contentNode, {\n    blockSeparator,\n    textSerializers: {\n      ...getTextSerializersFromSchema(schema),\n      ...textSerializers\n    }\n  });\n}\n\n// src/helpers/getNodeAttributes.ts\nfunction getNodeAttributes(state, typeOrName) {\n  const type = getNodeType(typeOrName, state.schema);\n  const { from, to } = state.selection;\n  const nodes = [];\n  state.doc.nodesBetween(from, to, (node2) => {\n    nodes.push(node2);\n  });\n  const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);\n  if (!node) {\n    return {};\n  }\n  return { ...node.attrs };\n}\n\n// src/helpers/getAttributes.ts\nfunction getAttributes(state, typeOrName) {\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === \"string\" ? typeOrName : typeOrName.name,\n    state.schema\n  );\n  if (schemaType === \"node\") {\n    return getNodeAttributes(state, typeOrName);\n  }\n  if (schemaType === \"mark\") {\n    return getMarkAttributes(state, typeOrName);\n  }\n  return {};\n}\n\n// src/utilities/removeDuplicates.ts\nfunction removeDuplicates(array, by = JSON.stringify) {\n  const seen = {};\n  return array.filter((item) => {\n    const key = by(item);\n    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;\n  });\n}\n\n// src/helpers/getChangedRanges.ts\nfunction simplifyChangedRanges(changes) {\n  const uniqueChanges = removeDuplicates(changes);\n  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index) => {\n    const rest = uniqueChanges.filter((_, i) => i !== index);\n    return !rest.some((otherChange) => {\n      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;\n    });\n  });\n}\nfunction getChangedRanges(transform) {\n  const { mapping, steps } = transform;\n  const changes = [];\n  mapping.maps.forEach((stepMap, index) => {\n    const ranges = [];\n    if (!stepMap.ranges.length) {\n      const { from, to } = steps[index];\n      if (from === void 0 || to === void 0) {\n        return;\n      }\n      ranges.push({ from, to });\n    } else {\n      stepMap.forEach((from, to) => {\n        ranges.push({ from, to });\n      });\n    }\n    ranges.forEach(({ from, to }) => {\n      const newStart = mapping.slice(index).map(from, -1);\n      const newEnd = mapping.slice(index).map(to);\n      const oldStart = mapping.invert().map(newStart, -1);\n      const oldEnd = mapping.invert().map(newEnd);\n      changes.push({\n        oldRange: {\n          from: oldStart,\n          to: oldEnd\n        },\n        newRange: {\n          from: newStart,\n          to: newEnd\n        }\n      });\n    });\n  });\n  return simplifyChangedRanges(changes);\n}\n\n// src/helpers/getDebugJSON.ts\nfunction getDebugJSON(node, startOffset = 0) {\n  const isTopNode = node.type === node.type.schema.topNodeType;\n  const increment = isTopNode ? 0 : 1;\n  const from = startOffset;\n  const to = from + node.nodeSize;\n  const marks = node.marks.map((mark) => {\n    const output2 = {\n      type: mark.type.name\n    };\n    if (Object.keys(mark.attrs).length) {\n      output2.attrs = { ...mark.attrs };\n    }\n    return output2;\n  });\n  const attrs = { ...node.attrs };\n  const output = {\n    type: node.type.name,\n    from,\n    to\n  };\n  if (Object.keys(attrs).length) {\n    output.attrs = attrs;\n  }\n  if (marks.length) {\n    output.marks = marks;\n  }\n  if (node.content.childCount) {\n    output.content = [];\n    node.forEach((child, offset) => {\n      var _a;\n      (_a = output.content) == null ? void 0 : _a.push(getDebugJSON(child, startOffset + offset + increment));\n    });\n  }\n  if (node.text) {\n    output.text = node.text;\n  }\n  return output;\n}\n\n// src/helpers/getMarksBetween.ts\nfunction getMarksBetween(from, to, doc) {\n  const marks = [];\n  if (from === to) {\n    doc.resolve(from).marks().forEach((mark) => {\n      const $pos = doc.resolve(from);\n      const range = getMarkRange($pos, mark.type);\n      if (!range) {\n        return;\n      }\n      marks.push({\n        mark,\n        ...range\n      });\n    });\n  } else {\n    doc.nodesBetween(from, to, (node, pos) => {\n      if (!node || (node == null ? void 0 : node.nodeSize) === void 0) {\n        return;\n      }\n      marks.push(\n        ...node.marks.map((mark) => ({\n          from: pos,\n          to: pos + node.nodeSize,\n          mark\n        }))\n      );\n    });\n  }\n  return marks;\n}\n\n// src/helpers/getNodeAtPosition.ts\nvar getNodeAtPosition = (state, typeOrName, pos, maxDepth = 20) => {\n  const $pos = state.doc.resolve(pos);\n  let currentDepth = maxDepth;\n  let node = null;\n  while (currentDepth > 0 && node === null) {\n    const currentNode = $pos.node(currentDepth);\n    if ((currentNode == null ? void 0 : currentNode.type.name) === typeOrName) {\n      node = currentNode;\n    } else {\n      currentDepth -= 1;\n    }\n  }\n  return [node, currentDepth];\n};\n\n// src/helpers/getSchemaTypeByName.ts\nfunction getSchemaTypeByName(name, schema) {\n  return schema.nodes[name] || schema.marks[name] || null;\n}\n\n// src/helpers/getSplittedAttributes.ts\nfunction getSplittedAttributes(extensionAttributes, typeName, attributes) {\n  return Object.fromEntries(\n    Object.entries(attributes).filter(([name]) => {\n      const extensionAttribute = extensionAttributes.find((item) => {\n        return item.type === typeName && item.name === name;\n      });\n      if (!extensionAttribute) {\n        return false;\n      }\n      return extensionAttribute.attribute.keepOnSplit;\n    })\n  );\n}\n\n// src/helpers/getTextContentFromNodes.ts\nvar getTextContentFromNodes = ($from, maxMatch = 500) => {\n  let textBefore = \"\";\n  const sliceEndPos = $from.parentOffset;\n  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {\n    var _a, _b;\n    const chunk = ((_b = (_a = node.type.spec).toText) == null ? void 0 : _b.call(_a, {\n      node,\n      pos,\n      parent,\n      index\n    })) || node.textContent || \"%leaf%\";\n    textBefore += node.isAtom && !node.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));\n  });\n  return textBefore;\n};\n\n// src/helpers/isMarkActive.ts\nfunction isMarkActive(state, typeOrName, attributes = {}) {\n  const { empty, ranges } = state.selection;\n  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;\n  if (empty) {\n    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {\n      if (!type) {\n        return true;\n      }\n      return type.name === mark.type.name;\n    }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));\n  }\n  let selectionRange = 0;\n  const markRanges = [];\n  ranges.forEach(({ $from, $to }) => {\n    const from = $from.pos;\n    const to = $to.pos;\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (!node.isText && !node.marks.length) {\n        return;\n      }\n      const relativeFrom = Math.max(from, pos);\n      const relativeTo = Math.min(to, pos + node.nodeSize);\n      const range2 = relativeTo - relativeFrom;\n      selectionRange += range2;\n      markRanges.push(\n        ...node.marks.map((mark) => ({\n          mark,\n          from: relativeFrom,\n          to: relativeTo\n        }))\n      );\n    });\n  });\n  if (selectionRange === 0) {\n    return false;\n  }\n  const matchedRange = markRanges.filter((markRange) => {\n    if (!type) {\n      return true;\n    }\n    return type.name === markRange.mark.type.name;\n  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\n  const excludedRange = markRanges.filter((markRange) => {\n    if (!type) {\n      return true;\n    }\n    return markRange.mark.type !== type && markRange.mark.type.excludes(type);\n  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\n  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;\n  return range >= selectionRange;\n}\n\n// src/helpers/isActive.ts\nfunction isActive(state, name, attributes = {}) {\n  if (!name) {\n    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);\n  }\n  const schemaType = getSchemaTypeNameByName(name, state.schema);\n  if (schemaType === \"node\") {\n    return isNodeActive(state, name, attributes);\n  }\n  if (schemaType === \"mark\") {\n    return isMarkActive(state, name, attributes);\n  }\n  return false;\n}\n\n// src/helpers/isAtEndOfNode.ts\nvar isAtEndOfNode = (state, nodeType) => {\n  const { $from, $to, $anchor } = state.selection;\n  if (nodeType) {\n    const parentNode = findParentNode((node) => node.type.name === nodeType)(state.selection);\n    if (!parentNode) {\n      return false;\n    }\n    const $parentPos = state.doc.resolve(parentNode.pos + 1);\n    if ($anchor.pos + 1 === $parentPos.end()) {\n      return true;\n    }\n    return false;\n  }\n  if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {\n    return false;\n  }\n  return true;\n};\n\n// src/helpers/isAtStartOfNode.ts\nvar isAtStartOfNode = (state) => {\n  const { $from, $to } = state.selection;\n  if ($from.parentOffset > 0 || $from.pos !== $to.pos) {\n    return false;\n  }\n  return true;\n};\n\n// src/helpers/isExtensionRulesEnabled.ts\nfunction isExtensionRulesEnabled(extension, enabled) {\n  if (Array.isArray(enabled)) {\n    return enabled.some((enabledExtension) => {\n      const name = typeof enabledExtension === \"string\" ? enabledExtension : enabledExtension.name;\n      return name === extension.name;\n    });\n  }\n  return enabled;\n}\n\n// src/helpers/isList.ts\nfunction isList(name, extensions) {\n  const { nodeExtensions } = splitExtensions(extensions);\n  const extension = nodeExtensions.find((item) => item.name === name);\n  if (!extension) {\n    return false;\n  }\n  const context = {\n    name: extension.name,\n    options: extension.options,\n    storage: extension.storage\n  };\n  const group = callOrReturn(getExtensionField(extension, \"group\", context));\n  if (typeof group !== \"string\") {\n    return false;\n  }\n  return group.split(\" \").includes(\"list\");\n}\n\n// src/helpers/isNodeEmpty.ts\nfunction isNodeEmpty(node, {\n  checkChildren = true,\n  ignoreWhitespace = false\n} = {}) {\n  var _a;\n  if (ignoreWhitespace) {\n    if (node.type.name === \"hardBreak\") {\n      return true;\n    }\n    if (node.isText) {\n      return /^\\s*$/m.test((_a = node.text) != null ? _a : \"\");\n    }\n  }\n  if (node.isText) {\n    return !node.text;\n  }\n  if (node.isAtom || node.isLeaf) {\n    return false;\n  }\n  if (node.content.childCount === 0) {\n    return true;\n  }\n  if (checkChildren) {\n    let isContentEmpty = true;\n    node.content.forEach((childNode) => {\n      if (isContentEmpty === false) {\n        return;\n      }\n      if (!isNodeEmpty(childNode, { ignoreWhitespace, checkChildren })) {\n        isContentEmpty = false;\n      }\n    });\n    return isContentEmpty;\n  }\n  return false;\n}\n\n// src/helpers/isNodeSelection.ts\n\nfunction isNodeSelection(value) {\n  return value instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection;\n}\n\n// src/helpers/posToDOMRect.ts\nfunction posToDOMRect(view, from, to) {\n  const minPos = 0;\n  const maxPos = view.state.doc.content.size;\n  const resolvedFrom = minMax(from, minPos, maxPos);\n  const resolvedEnd = minMax(to, minPos, maxPos);\n  const start = view.coordsAtPos(resolvedFrom);\n  const end = view.coordsAtPos(resolvedEnd, -1);\n  const top = Math.min(start.top, end.top);\n  const bottom = Math.max(start.bottom, end.bottom);\n  const left = Math.min(start.left, end.left);\n  const right = Math.max(start.right, end.right);\n  const width = right - left;\n  const height = bottom - top;\n  const x = left;\n  const y = top;\n  const data = {\n    top,\n    bottom,\n    left,\n    right,\n    width,\n    height,\n    x,\n    y\n  };\n  return {\n    ...data,\n    toJSON: () => data\n  };\n}\n\n// src/helpers/rewriteUnknownContent.ts\nfunction rewriteUnknownContentInner({\n  json,\n  validMarks,\n  validNodes,\n  options,\n  rewrittenContent = []\n}) {\n  if (json.marks && Array.isArray(json.marks)) {\n    json.marks = json.marks.filter((mark) => {\n      const name = typeof mark === \"string\" ? mark : mark.type;\n      if (validMarks.has(name)) {\n        return true;\n      }\n      rewrittenContent.push({\n        original: JSON.parse(JSON.stringify(mark)),\n        unsupported: name\n      });\n      return false;\n    });\n  }\n  if (json.content && Array.isArray(json.content)) {\n    json.content = json.content.map(\n      (value) => rewriteUnknownContentInner({\n        json: value,\n        validMarks,\n        validNodes,\n        options,\n        rewrittenContent\n      }).json\n    ).filter((a) => a !== null && a !== void 0);\n  }\n  if (json.type && !validNodes.has(json.type)) {\n    rewrittenContent.push({\n      original: JSON.parse(JSON.stringify(json)),\n      unsupported: json.type\n    });\n    if (json.content && Array.isArray(json.content) && (options == null ? void 0 : options.fallbackToParagraph) !== false) {\n      json.type = \"paragraph\";\n      return {\n        json,\n        rewrittenContent\n      };\n    }\n    return {\n      json: null,\n      rewrittenContent\n    };\n  }\n  return { json, rewrittenContent };\n}\nfunction rewriteUnknownContent(json, schema, options) {\n  return rewriteUnknownContentInner({\n    json,\n    validNodes: new Set(Object.keys(schema.nodes)),\n    validMarks: new Set(Object.keys(schema.marks)),\n    options\n  });\n}\n\n// src/commands/setMark.ts\nfunction canSetMark(state, tr, newMarkType) {\n  var _a;\n  const { selection } = tr;\n  let cursor = null;\n  if (isTextSelection(selection)) {\n    cursor = selection.$cursor;\n  }\n  if (cursor) {\n    const currentMarks = (_a = state.storedMarks) != null ? _a : cursor.marks();\n    const parentAllowsMarkType = cursor.parent.type.allowsMarkType(newMarkType);\n    return parentAllowsMarkType && (!!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType)));\n  }\n  const { ranges } = selection;\n  return ranges.some(({ $from, $to }) => {\n    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;\n    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {\n      if (someNodeSupportsMark) {\n        return false;\n      }\n      if (node.isInline) {\n        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);\n        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));\n        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;\n      }\n      return !someNodeSupportsMark;\n    });\n    return someNodeSupportsMark;\n  });\n}\nvar setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  const { selection } = tr;\n  const { empty, ranges } = selection;\n  const type = getMarkType(typeOrName, state.schema);\n  if (dispatch) {\n    if (empty) {\n      const oldAttributes = getMarkAttributes(state, type);\n      tr.addStoredMark(\n        type.create({\n          ...oldAttributes,\n          ...attributes\n        })\n      );\n    } else {\n      ranges.forEach((range) => {\n        const from = range.$from.pos;\n        const to = range.$to.pos;\n        state.doc.nodesBetween(from, to, (node, pos) => {\n          const trimmedFrom = Math.max(pos, from);\n          const trimmedTo = Math.min(pos + node.nodeSize, to);\n          const someHasMark = node.marks.find((mark) => mark.type === type);\n          if (someHasMark) {\n            node.marks.forEach((mark) => {\n              if (type === mark.type) {\n                tr.addMark(\n                  trimmedFrom,\n                  trimmedTo,\n                  type.create({\n                    ...mark.attrs,\n                    ...attributes\n                  })\n                );\n              }\n            });\n          } else {\n            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));\n          }\n        });\n      });\n    }\n  }\n  return canSetMark(state, tr, type);\n};\n\n// src/commands/setMeta.ts\nvar setMeta = (key, value) => ({ tr }) => {\n  tr.setMeta(key, value);\n  return true;\n};\n\n// src/commands/setNode.ts\n\nvar setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  let attributesToCopy;\n  if (state.selection.$anchor.sameParent(state.selection.$head)) {\n    attributesToCopy = state.selection.$anchor.parent.attrs;\n  }\n  if (!type.isTextblock) {\n    console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.');\n    return false;\n  }\n  return chain().command(({ commands }) => {\n    const canSetBlock = (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.setBlockType)(type, { ...attributesToCopy, ...attributes })(state);\n    if (canSetBlock) {\n      return true;\n    }\n    return commands.clearNodes();\n  }).command(({ state: updatedState }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.setBlockType)(type, { ...attributesToCopy, ...attributes })(updatedState, dispatch);\n  }).run();\n};\n\n// src/commands/setNodeSelection.ts\n\nvar setNodeSelection = (position) => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const { doc } = tr;\n    const from = minMax(position, 0, doc.content.size);\n    const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.create(doc, from);\n    tr.setSelection(selection);\n  }\n  return true;\n};\n\n// src/commands/setTextSelection.ts\n\nvar setTextSelection = (position) => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const { doc } = tr;\n    const { from, to } = typeof position === \"number\" ? { from: position, to: position } : position;\n    const minPos = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.atStart(doc).from;\n    const maxPos = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.atEnd(doc).to;\n    const resolvedFrom = minMax(from, minPos, maxPos);\n    const resolvedEnd = minMax(to, minPos, maxPos);\n    const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.create(doc, resolvedFrom, resolvedEnd);\n    tr.setSelection(selection);\n  }\n  return true;\n};\n\n// src/commands/sinkListItem.ts\n\nvar sinkListItem = (typeOrName) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_4__.sinkListItem)(type)(state, dispatch);\n};\n\n// src/commands/splitBlock.ts\n\n\nfunction ensureMarks(state, splittableMarks) {\n  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n  if (marks) {\n    const filteredMarks = marks.filter((mark) => splittableMarks == null ? void 0 : splittableMarks.includes(mark.type.name));\n    state.tr.ensureMarks(filteredMarks);\n  }\n}\nvar splitBlock = ({ keepMarks = true } = {}) => ({ tr, state, dispatch, editor }) => {\n  const { selection, doc } = tr;\n  const { $from, $to } = selection;\n  const extensionAttributes = editor.extensionManager.attributes;\n  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n  if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection && selection.node.isBlock) {\n    if (!$from.parentOffset || !(0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(doc, $from.pos)) {\n      return false;\n    }\n    if (dispatch) {\n      if (keepMarks) {\n        ensureMarks(state, editor.extensionManager.splittableMarks);\n      }\n      tr.split($from.pos).scrollIntoView();\n    }\n    return true;\n  }\n  if (!$from.parent.isBlock) {\n    return false;\n  }\n  const atEnd = $to.parentOffset === $to.parent.content.size;\n  const deflt = $from.depth === 0 ? void 0 : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n  let types = atEnd && deflt ? [\n    {\n      type: deflt,\n      attrs: newAttributes\n    }\n  ] : void 0;\n  let can = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, types);\n  if (!types && !can && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {\n    can = true;\n    types = deflt ? [\n      {\n        type: deflt,\n        attrs: newAttributes\n      }\n    ] : void 0;\n  }\n  if (dispatch) {\n    if (can) {\n      if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection) {\n        tr.deleteSelection();\n      }\n      tr.split(tr.mapping.map($from.pos), 1, types);\n      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n        const first2 = tr.mapping.map($from.before());\n        const $first = tr.doc.resolve(first2);\n        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n        }\n      }\n    }\n    if (keepMarks) {\n      ensureMarks(state, editor.extensionManager.splittableMarks);\n    }\n    tr.scrollIntoView();\n  }\n  return can;\n};\n\n// src/commands/splitListItem.ts\n\n\n\nvar splitListItem = (typeOrName, overrideAttrs = {}) => ({ tr, state, dispatch, editor }) => {\n  var _a;\n  const type = getNodeType(typeOrName, state.schema);\n  const { $from, $to } = state.selection;\n  const node = state.selection.node;\n  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {\n    return false;\n  }\n  const grandParent = $from.node(-1);\n  if (grandParent.type !== type) {\n    return false;\n  }\n  const extensionAttributes = editor.extensionManager.attributes;\n  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {\n      return false;\n    }\n    if (dispatch) {\n      let wrap = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.empty;\n      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {\n        wrap = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from($from.node(d).copy(wrap));\n      }\n      const depthAfter = (\n        // eslint-disable-next-line no-nested-ternary\n        $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3\n      );\n      const newNextTypeAttributes2 = {\n        ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),\n        ...overrideAttrs\n      };\n      const nextType2 = ((_a = type.contentMatch.defaultType) == null ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;\n      wrap = wrap.append(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from(type.createAndFill(null, nextType2) || void 0));\n      const start = $from.before($from.depth - (depthBefore - 1));\n      tr.replace(start, $from.after(-depthAfter), new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Slice(wrap, 4 - depthBefore, 0));\n      let sel = -1;\n      tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {\n        if (sel > -1) {\n          return false;\n        }\n        if (n.isTextblock && n.content.size === 0) {\n          sel = pos + 1;\n        }\n      });\n      if (sel > -1) {\n        tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.near(tr.doc.resolve(sel)));\n      }\n      tr.scrollIntoView();\n    }\n    return true;\n  }\n  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n  const newTypeAttributes = {\n    ...getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs),\n    ...overrideAttrs\n  };\n  const newNextTypeAttributes = {\n    ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),\n    ...overrideAttrs\n  };\n  tr.delete($from.pos, $to.pos);\n  const types = nextType ? [\n    { type, attrs: newTypeAttributes },\n    { type: nextType, attrs: newNextTypeAttributes }\n  ] : [{ type, attrs: newTypeAttributes }];\n  if (!(0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, $from.pos, 2)) {\n    return false;\n  }\n  if (dispatch) {\n    const { selection, storedMarks } = state;\n    const { splittableMarks } = editor.extensionManager;\n    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n    tr.split($from.pos, 2, types).scrollIntoView();\n    if (!marks || !dispatch) {\n      return true;\n    }\n    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));\n    tr.ensureMarks(filteredMarks);\n  }\n  return true;\n};\n\n// src/commands/toggleList.ts\n\nvar joinListBackwards = (tr, listType) => {\n  const list = findParentNode((node) => node.type === listType)(tr.selection);\n  if (!list) {\n    return true;\n  }\n  const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);\n  if (before === void 0) {\n    return true;\n  }\n  const nodeBefore = tr.doc.nodeAt(before);\n  const canJoinBackwards = list.node.type === (nodeBefore == null ? void 0 : nodeBefore.type) && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, list.pos);\n  if (!canJoinBackwards) {\n    return true;\n  }\n  tr.join(list.pos);\n  return true;\n};\nvar joinListForwards = (tr, listType) => {\n  const list = findParentNode((node) => node.type === listType)(tr.selection);\n  if (!list) {\n    return true;\n  }\n  const after = tr.doc.resolve(list.start).after(list.depth);\n  if (after === void 0) {\n    return true;\n  }\n  const nodeAfter = tr.doc.nodeAt(after);\n  const canJoinForwards = list.node.type === (nodeAfter == null ? void 0 : nodeAfter.type) && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, after);\n  if (!canJoinForwards) {\n    return true;\n  }\n  tr.join(after);\n  return true;\n};\nvar toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr, state, dispatch, chain, commands, can }) => {\n  const { extensions, splittableMarks } = editor.extensionManager;\n  const listType = getNodeType(listTypeOrName, state.schema);\n  const itemType = getNodeType(itemTypeOrName, state.schema);\n  const { selection, storedMarks } = state;\n  const { $from, $to } = selection;\n  const range = $from.blockRange($to);\n  const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n  if (!range) {\n    return false;\n  }\n  const parentList = findParentNode((node) => isList(node.type.name, extensions))(selection);\n  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n    if (parentList.node.type === listType) {\n      return commands.liftListItem(itemType);\n    }\n    if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {\n      return chain().command(() => {\n        tr.setNodeMarkup(parentList.pos, listType);\n        return true;\n      }).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n    }\n  }\n  if (!keepMarks || !marks || !dispatch) {\n    return chain().command(() => {\n      const canWrapInList = can().wrapInList(listType, attributes);\n      if (canWrapInList) {\n        return true;\n      }\n      return commands.clearNodes();\n    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n  }\n  return chain().command(() => {\n    const canWrapInList = can().wrapInList(listType, attributes);\n    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));\n    tr.ensureMarks(filteredMarks);\n    if (canWrapInList) {\n      return true;\n    }\n    return commands.clearNodes();\n  }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n};\n\n// src/commands/toggleMark.ts\nvar toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands }) => {\n  const { extendEmptyMarkRange = false } = options;\n  const type = getMarkType(typeOrName, state.schema);\n  const isActive2 = isMarkActive(state, type, attributes);\n  if (isActive2) {\n    return commands.unsetMark(type, { extendEmptyMarkRange });\n  }\n  return commands.setMark(type, attributes);\n};\n\n// src/commands/toggleNode.ts\nvar toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const toggleType = getNodeType(toggleTypeOrName, state.schema);\n  const isActive2 = isNodeActive(state, type, attributes);\n  let attributesToCopy;\n  if (state.selection.$anchor.sameParent(state.selection.$head)) {\n    attributesToCopy = state.selection.$anchor.parent.attrs;\n  }\n  if (isActive2) {\n    return commands.setNode(toggleType, attributesToCopy);\n  }\n  return commands.setNode(type, { ...attributesToCopy, ...attributes });\n};\n\n// src/commands/toggleWrap.ts\nvar toggleWrap = (typeOrName, attributes = {}) => ({ state, commands }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const isActive2 = isNodeActive(state, type, attributes);\n  if (isActive2) {\n    return commands.lift(type);\n  }\n  return commands.wrapIn(type, attributes);\n};\n\n// src/commands/undoInputRule.ts\nvar undoInputRule = () => ({ state, dispatch }) => {\n  const plugins = state.plugins;\n  for (let i = 0; i < plugins.length; i += 1) {\n    const plugin = plugins[i];\n    let undoable;\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        const tr = state.tr;\n        const toUndo = undoable.transform;\n        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n        }\n        if (undoable.text) {\n          const marks = tr.doc.resolve(undoable.from).marks();\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n        } else {\n          tr.delete(undoable.from, undoable.to);\n        }\n      }\n      return true;\n    }\n  }\n  return false;\n};\n\n// src/commands/unsetAllMarks.ts\nvar unsetAllMarks = () => ({ tr, dispatch }) => {\n  const { selection } = tr;\n  const { empty, ranges } = selection;\n  if (empty) {\n    return true;\n  }\n  if (dispatch) {\n    ranges.forEach((range) => {\n      tr.removeMark(range.$from.pos, range.$to.pos);\n    });\n  }\n  return true;\n};\n\n// src/commands/unsetMark.ts\nvar unsetMark = (typeOrName, options = {}) => ({ tr, state, dispatch }) => {\n  var _a;\n  const { extendEmptyMarkRange = false } = options;\n  const { selection } = tr;\n  const type = getMarkType(typeOrName, state.schema);\n  const { $from, empty, ranges } = selection;\n  if (!dispatch) {\n    return true;\n  }\n  if (empty && extendEmptyMarkRange) {\n    let { from, to } = selection;\n    const attrs = (_a = $from.marks().find((mark) => mark.type === type)) == null ? void 0 : _a.attrs;\n    const range = getMarkRange($from, type, attrs);\n    if (range) {\n      from = range.from;\n      to = range.to;\n    }\n    tr.removeMark(from, to, type);\n  } else {\n    ranges.forEach((range) => {\n      tr.removeMark(range.$from.pos, range.$to.pos, type);\n    });\n  }\n  tr.removeStoredMark(type);\n  return true;\n};\n\n// src/commands/updateAttributes.ts\nvar updateAttributes = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  let nodeType = null;\n  let markType = null;\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === \"string\" ? typeOrName : typeOrName.name,\n    state.schema\n  );\n  if (!schemaType) {\n    return false;\n  }\n  if (schemaType === \"node\") {\n    nodeType = getNodeType(typeOrName, state.schema);\n  }\n  if (schemaType === \"mark\") {\n    markType = getMarkType(typeOrName, state.schema);\n  }\n  if (dispatch) {\n    tr.selection.ranges.forEach((range) => {\n      const from = range.$from.pos;\n      const to = range.$to.pos;\n      let lastPos;\n      let lastNode;\n      let trimmedFrom;\n      let trimmedTo;\n      if (tr.selection.empty) {\n        state.doc.nodesBetween(from, to, (node, pos) => {\n          if (nodeType && nodeType === node.type) {\n            trimmedFrom = Math.max(pos, from);\n            trimmedTo = Math.min(pos + node.nodeSize, to);\n            lastPos = pos;\n            lastNode = node;\n          }\n        });\n      } else {\n        state.doc.nodesBetween(from, to, (node, pos) => {\n          if (pos < from && nodeType && nodeType === node.type) {\n            trimmedFrom = Math.max(pos, from);\n            trimmedTo = Math.min(pos + node.nodeSize, to);\n            lastPos = pos;\n            lastNode = node;\n          }\n          if (pos >= from && pos <= to) {\n            if (nodeType && nodeType === node.type) {\n              tr.setNodeMarkup(pos, void 0, {\n                ...node.attrs,\n                ...attributes\n              });\n            }\n            if (markType && node.marks.length) {\n              node.marks.forEach((mark) => {\n                if (markType === mark.type) {\n                  const trimmedFrom2 = Math.max(pos, from);\n                  const trimmedTo2 = Math.min(pos + node.nodeSize, to);\n                  tr.addMark(\n                    trimmedFrom2,\n                    trimmedTo2,\n                    markType.create({\n                      ...mark.attrs,\n                      ...attributes\n                    })\n                  );\n                }\n              });\n            }\n          }\n        });\n      }\n      if (lastNode) {\n        if (lastPos !== void 0) {\n          tr.setNodeMarkup(lastPos, void 0, {\n            ...lastNode.attrs,\n            ...attributes\n          });\n        }\n        if (markType && lastNode.marks.length) {\n          lastNode.marks.forEach((mark) => {\n            if (markType === mark.type) {\n              tr.addMark(\n                trimmedFrom,\n                trimmedTo,\n                markType.create({\n                  ...mark.attrs,\n                  ...attributes\n                })\n              );\n            }\n          });\n        }\n      }\n    });\n  }\n  return true;\n};\n\n// src/commands/wrapIn.ts\n\nvar wrapIn = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_1__.wrapIn)(type, attributes)(state, dispatch);\n};\n\n// src/commands/wrapInList.ts\n\nvar wrapInList = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_4__.wrapInList)(type, attributes)(state, dispatch);\n};\n\n// src/Editor.ts\n\n\n\n// src/EventEmitter.ts\nvar EventEmitter = class {\n  constructor() {\n    this.callbacks = {};\n  }\n  on(event, fn) {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = [];\n    }\n    this.callbacks[event].push(fn);\n    return this;\n  }\n  emit(event, ...args) {\n    const callbacks = this.callbacks[event];\n    if (callbacks) {\n      callbacks.forEach((callback) => callback.apply(this, args));\n    }\n    return this;\n  }\n  off(event, fn) {\n    const callbacks = this.callbacks[event];\n    if (callbacks) {\n      if (fn) {\n        this.callbacks[event] = callbacks.filter((callback) => callback !== fn);\n      } else {\n        delete this.callbacks[event];\n      }\n    }\n    return this;\n  }\n  once(event, fn) {\n    const onceFn = (...args) => {\n      this.off(event, onceFn);\n      fn.apply(this, args);\n    };\n    return this.on(event, onceFn);\n  }\n  removeAllListeners() {\n    this.callbacks = {};\n  }\n};\n\n// src/ExtensionManager.ts\n\n\n// src/InputRule.ts\n\n\nvar InputRule = class {\n  constructor(config) {\n    var _a;\n    this.find = config.find;\n    this.handler = config.handler;\n    this.undoable = (_a = config.undoable) != null ? _a : true;\n  }\n};\nvar inputRuleMatcherHandler = (text, find) => {\n  if (isRegExp(find)) {\n    return find.exec(text);\n  }\n  const inputRuleMatch = find(text);\n  if (!inputRuleMatch) {\n    return null;\n  }\n  const result = [inputRuleMatch.text];\n  result.index = inputRuleMatch.index;\n  result.input = text;\n  result.data = inputRuleMatch.data;\n  if (inputRuleMatch.replaceWith) {\n    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\n      console.warn('[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".');\n    }\n    result.push(inputRuleMatch.replaceWith);\n  }\n  return result;\n};\nfunction run(config) {\n  var _a;\n  const { editor, from, to, text, rules, plugin } = config;\n  const { view } = editor;\n  if (view.composing) {\n    return false;\n  }\n  const $from = view.state.doc.resolve(from);\n  if (\n    // check for code node\n    $from.parent.type.spec.code || // check for code mark\n    !!((_a = $from.nodeBefore || $from.nodeAfter) == null ? void 0 : _a.marks.find((mark) => mark.type.spec.code))\n  ) {\n    return false;\n  }\n  let matched = false;\n  const textBefore = getTextContentFromNodes($from) + text;\n  rules.forEach((rule) => {\n    if (matched) {\n      return;\n    }\n    const match = inputRuleMatcherHandler(textBefore, rule.find);\n    if (!match) {\n      return;\n    }\n    const tr = view.state.tr;\n    const state = createChainableState({\n      state: view.state,\n      transaction: tr\n    });\n    const range = {\n      from: from - (match[0].length - text.length),\n      to\n    };\n    const { commands, chain, can } = new CommandManager({\n      editor,\n      state\n    });\n    const handler = rule.handler({\n      state,\n      range,\n      match,\n      commands,\n      chain,\n      can\n    });\n    if (handler === null || !tr.steps.length) {\n      return;\n    }\n    if (rule.undoable) {\n      tr.setMeta(plugin, {\n        transform: tr,\n        from,\n        to,\n        text\n      });\n    }\n    view.dispatch(tr);\n    matched = true;\n  });\n  return matched;\n}\nfunction inputRulesPlugin(props) {\n  const { editor, rules } = props;\n  const plugin = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, prev, state) {\n        const stored = tr.getMeta(plugin);\n        if (stored) {\n          return stored;\n        }\n        const simulatedInputMeta = tr.getMeta(\"applyInputRules\");\n        const isSimulatedInput = !!simulatedInputMeta;\n        if (isSimulatedInput) {\n          setTimeout(() => {\n            let { text } = simulatedInputMeta;\n            if (typeof text === \"string\") {\n              text = text;\n            } else {\n              text = getHTMLFromFragment(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from(text), state.schema);\n            }\n            const { from } = simulatedInputMeta;\n            const to = from + text.length;\n            run({\n              editor,\n              from,\n              to,\n              text,\n              rules,\n              plugin\n            });\n          });\n        }\n        return tr.selectionSet || tr.docChanged ? null : prev;\n      }\n    },\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run({\n          editor,\n          from,\n          to,\n          text,\n          rules,\n          plugin\n        });\n      },\n      handleDOMEvents: {\n        compositionend: (view) => {\n          setTimeout(() => {\n            const { $cursor } = view.state.selection;\n            if ($cursor) {\n              run({\n                editor,\n                from: $cursor.pos,\n                to: $cursor.pos,\n                text: \"\",\n                rules,\n                plugin\n              });\n            }\n          });\n          return false;\n        }\n      },\n      // add support for input rules to trigger on enter\n      // this is useful for example for code blocks\n      handleKeyDown(view, event) {\n        if (event.key !== \"Enter\") {\n          return false;\n        }\n        const { $cursor } = view.state.selection;\n        if ($cursor) {\n          return run({\n            editor,\n            from: $cursor.pos,\n            to: $cursor.pos,\n            text: \"\\n\",\n            rules,\n            plugin\n          });\n        }\n        return false;\n      }\n    },\n    // @ts-ignore\n    isInputRules: true\n  });\n  return plugin;\n}\n\n// src/utilities/isPlainObject.ts\nfunction getType(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\nfunction isPlainObject(value) {\n  if (getType(value) !== \"Object\") {\n    return false;\n  }\n  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;\n}\n\n// src/utilities/mergeDeep.ts\nfunction mergeDeep(target, source) {\n  const output = { ...target };\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach((key) => {\n      if (isPlainObject(source[key]) && isPlainObject(target[key])) {\n        output[key] = mergeDeep(target[key], source[key]);\n      } else {\n        output[key] = source[key];\n      }\n    });\n  }\n  return output;\n}\n\n// src/Extendable.ts\nvar Extendable = class {\n  constructor(config = {}) {\n    this.type = \"extendable\";\n    this.parent = null;\n    this.child = null;\n    this.name = \"\";\n    this.config = {\n      name: this.name\n    };\n    this.config = {\n      ...this.config,\n      ...config\n    };\n    this.name = this.config.name;\n  }\n  get options() {\n    return {\n      ...callOrReturn(\n        getExtensionField(this, \"addOptions\", {\n          name: this.name\n        })\n      ) || {}\n    };\n  }\n  get storage() {\n    return {\n      ...callOrReturn(\n        getExtensionField(this, \"addStorage\", {\n          name: this.name,\n          options: this.options\n        })\n      ) || {}\n    };\n  }\n  configure(options = {}) {\n    const extension = this.extend({\n      ...this.config,\n      addOptions: () => {\n        return mergeDeep(this.options, options);\n      }\n    });\n    extension.name = this.name;\n    extension.parent = this.parent;\n    return extension;\n  }\n  extend(extendedConfig = {}) {\n    const extension = new this.constructor({ ...this.config, ...extendedConfig });\n    extension.parent = this;\n    this.child = extension;\n    extension.name = \"name\" in extendedConfig ? extendedConfig.name : extension.parent.name;\n    return extension;\n  }\n};\n\n// src/Mark.ts\nvar Mark = class _Mark extends Extendable {\n  constructor() {\n    super(...arguments);\n    this.type = \"mark\";\n  }\n  /**\n   * Create a new Mark instance\n   * @param config - Mark configuration object or a function that returns a configuration object\n   */\n  static create(config = {}) {\n    const resolvedConfig = typeof config === \"function\" ? config() : config;\n    return new _Mark(resolvedConfig);\n  }\n  static handleExit({ editor, mark }) {\n    const { tr } = editor.state;\n    const currentPos = editor.state.selection.$from;\n    const isAtEnd = currentPos.pos === currentPos.end();\n    if (isAtEnd) {\n      const currentMarks = currentPos.marks();\n      const isInMark = !!currentMarks.find((m) => (m == null ? void 0 : m.type.name) === mark.name);\n      if (!isInMark) {\n        return false;\n      }\n      const removeMark = currentMarks.find((m) => (m == null ? void 0 : m.type.name) === mark.name);\n      if (removeMark) {\n        tr.removeStoredMark(removeMark);\n      }\n      tr.insertText(\" \", currentPos.pos);\n      editor.view.dispatch(tr);\n      return true;\n    }\n    return false;\n  }\n  configure(options) {\n    return super.configure(options);\n  }\n  extend(extendedConfig) {\n    const resolvedConfig = typeof extendedConfig === \"function\" ? extendedConfig() : extendedConfig;\n    return super.extend(resolvedConfig);\n  }\n};\n\n// src/PasteRule.ts\n\n\n\n// src/utilities/isNumber.ts\nfunction isNumber(value) {\n  return typeof value === \"number\";\n}\n\n// src/PasteRule.ts\nvar PasteRule = class {\n  constructor(config) {\n    this.find = config.find;\n    this.handler = config.handler;\n  }\n};\nvar pasteRuleMatcherHandler = (text, find, event) => {\n  if (isRegExp(find)) {\n    return [...text.matchAll(find)];\n  }\n  const matches = find(text, event);\n  if (!matches) {\n    return [];\n  }\n  return matches.map((pasteRuleMatch) => {\n    const result = [pasteRuleMatch.text];\n    result.index = pasteRuleMatch.index;\n    result.input = text;\n    result.data = pasteRuleMatch.data;\n    if (pasteRuleMatch.replaceWith) {\n      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\n        console.warn('[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".');\n      }\n      result.push(pasteRuleMatch.replaceWith);\n    }\n    return result;\n  });\n};\nfunction run2(config) {\n  const { editor, state, from, to, rule, pasteEvent, dropEvent } = config;\n  const { commands, chain, can } = new CommandManager({\n    editor,\n    state\n  });\n  const handlers = [];\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    var _a, _b, _c, _d, _e;\n    if (((_b = (_a = node.type) == null ? void 0 : _a.spec) == null ? void 0 : _b.code) || !(node.isText || node.isTextblock || node.isInline)) {\n      return;\n    }\n    const contentSize = (_e = (_d = (_c = node.content) == null ? void 0 : _c.size) != null ? _d : node.nodeSize) != null ? _e : 0;\n    const resolvedFrom = Math.max(from, pos);\n    const resolvedTo = Math.min(to, pos + contentSize);\n    if (resolvedFrom >= resolvedTo) {\n      return;\n    }\n    const textToMatch = node.isText ? node.text || \"\" : node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, \"\\uFFFC\");\n    const matches = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);\n    matches.forEach((match) => {\n      if (match.index === void 0) {\n        return;\n      }\n      const start = resolvedFrom + match.index + 1;\n      const end = start + match[0].length;\n      const range = {\n        from: state.tr.mapping.map(start),\n        to: state.tr.mapping.map(end)\n      };\n      const handler = rule.handler({\n        state,\n        range,\n        match,\n        commands,\n        chain,\n        can,\n        pasteEvent,\n        dropEvent\n      });\n      handlers.push(handler);\n    });\n  });\n  const success = handlers.every((handler) => handler !== null);\n  return success;\n}\nvar tiptapDragFromOtherEditor = null;\nvar createClipboardPasteEvent = (text) => {\n  var _a;\n  const event = new ClipboardEvent(\"paste\", {\n    clipboardData: new DataTransfer()\n  });\n  (_a = event.clipboardData) == null ? void 0 : _a.setData(\"text/html\", text);\n  return event;\n};\nfunction pasteRulesPlugin(props) {\n  const { editor, rules } = props;\n  let dragSourceElement = null;\n  let isPastedFromProseMirror = false;\n  let isDroppedFromProseMirror = false;\n  let pasteEvent = typeof ClipboardEvent !== \"undefined\" ? new ClipboardEvent(\"paste\") : null;\n  let dropEvent;\n  try {\n    dropEvent = typeof DragEvent !== \"undefined\" ? new DragEvent(\"drop\") : null;\n  } catch {\n    dropEvent = null;\n  }\n  const processEvent = ({\n    state,\n    from,\n    to,\n    rule,\n    pasteEvt\n  }) => {\n    const tr = state.tr;\n    const chainableState = createChainableState({\n      state,\n      transaction: tr\n    });\n    const handler = run2({\n      editor,\n      state: chainableState,\n      from: Math.max(from - 1, 0),\n      to: to.b - 1,\n      rule,\n      pasteEvent: pasteEvt,\n      dropEvent\n    });\n    if (!handler || !tr.steps.length) {\n      return;\n    }\n    try {\n      dropEvent = typeof DragEvent !== \"undefined\" ? new DragEvent(\"drop\") : null;\n    } catch {\n      dropEvent = null;\n    }\n    pasteEvent = typeof ClipboardEvent !== \"undefined\" ? new ClipboardEvent(\"paste\") : null;\n    return tr;\n  };\n  const plugins = rules.map((rule) => {\n    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n      // we register a global drag handler to track the current drag source element\n      view(view) {\n        const handleDragstart = (event) => {\n          var _a;\n          dragSourceElement = ((_a = view.dom.parentElement) == null ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;\n          if (dragSourceElement) {\n            tiptapDragFromOtherEditor = editor;\n          }\n        };\n        const handleDragend = () => {\n          if (tiptapDragFromOtherEditor) {\n            tiptapDragFromOtherEditor = null;\n          }\n        };\n        window.addEventListener(\"dragstart\", handleDragstart);\n        window.addEventListener(\"dragend\", handleDragend);\n        return {\n          destroy() {\n            window.removeEventListener(\"dragstart\", handleDragstart);\n            window.removeEventListener(\"dragend\", handleDragend);\n          }\n        };\n      },\n      props: {\n        handleDOMEvents: {\n          drop: (view, event) => {\n            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;\n            dropEvent = event;\n            if (!isDroppedFromProseMirror) {\n              const dragFromOtherEditor = tiptapDragFromOtherEditor;\n              if (dragFromOtherEditor == null ? void 0 : dragFromOtherEditor.isEditable) {\n                setTimeout(() => {\n                  const selection = dragFromOtherEditor.state.selection;\n                  if (selection) {\n                    dragFromOtherEditor.commands.deleteRange({ from: selection.from, to: selection.to });\n                  }\n                }, 10);\n              }\n            }\n            return false;\n          },\n          paste: (_view, event) => {\n            var _a;\n            const html = (_a = event.clipboardData) == null ? void 0 : _a.getData(\"text/html\");\n            pasteEvent = event;\n            isPastedFromProseMirror = !!(html == null ? void 0 : html.includes(\"data-pm-slice\"));\n            return false;\n          }\n        }\n      },\n      appendTransaction: (transactions, oldState, state) => {\n        const transaction = transactions[0];\n        const isPaste = transaction.getMeta(\"uiEvent\") === \"paste\" && !isPastedFromProseMirror;\n        const isDrop = transaction.getMeta(\"uiEvent\") === \"drop\" && !isDroppedFromProseMirror;\n        const simulatedPasteMeta = transaction.getMeta(\"applyPasteRules\");\n        const isSimulatedPaste = !!simulatedPasteMeta;\n        if (!isPaste && !isDrop && !isSimulatedPaste) {\n          return;\n        }\n        if (isSimulatedPaste) {\n          let { text } = simulatedPasteMeta;\n          if (typeof text === \"string\") {\n            text = text;\n          } else {\n            text = getHTMLFromFragment(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from(text), state.schema);\n          }\n          const { from: from2 } = simulatedPasteMeta;\n          const to2 = from2 + text.length;\n          const pasteEvt = createClipboardPasteEvent(text);\n          return processEvent({\n            rule,\n            state,\n            from: from2,\n            to: { b: to2 },\n            pasteEvt\n          });\n        }\n        const from = oldState.doc.content.findDiffStart(state.doc.content);\n        const to = oldState.doc.content.findDiffEnd(state.doc.content);\n        if (!isNumber(from) || !to || from === to.b) {\n          return;\n        }\n        return processEvent({\n          rule,\n          state,\n          from,\n          to,\n          pasteEvt: pasteEvent\n        });\n      }\n    });\n  });\n  return plugins;\n}\n\n// src/ExtensionManager.ts\nvar ExtensionManager = class {\n  constructor(extensions, editor) {\n    this.splittableMarks = [];\n    this.editor = editor;\n    this.baseExtensions = extensions;\n    this.extensions = resolveExtensions(extensions);\n    this.schema = getSchemaByResolvedExtensions(this.extensions, editor);\n    this.setupExtensions();\n  }\n  /**\n   * Get all commands from the extensions.\n   * @returns An object with all commands where the key is the command name and the value is the command function\n   */\n  get commands() {\n    return this.extensions.reduce((commands, extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: this.editor.extensionStorage[extension.name],\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      const addCommands = getExtensionField(extension, \"addCommands\", context);\n      if (!addCommands) {\n        return commands;\n      }\n      return {\n        ...commands,\n        ...addCommands()\n      };\n    }, {});\n  }\n  /**\n   * Get all registered Prosemirror plugins from the extensions.\n   * @returns An array of Prosemirror plugins\n   */\n  get plugins() {\n    const { editor } = this;\n    const extensions = sortExtensions([...this.extensions].reverse());\n    const allPlugins = extensions.flatMap((extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: this.editor.extensionStorage[extension.name],\n        editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      const plugins = [];\n      const addKeyboardShortcuts = getExtensionField(\n        extension,\n        \"addKeyboardShortcuts\",\n        context\n      );\n      let defaultBindings = {};\n      if (extension.type === \"mark\" && getExtensionField(extension, \"exitable\", context)) {\n        defaultBindings.ArrowRight = () => Mark.handleExit({ editor, mark: extension });\n      }\n      if (addKeyboardShortcuts) {\n        const bindings = Object.fromEntries(\n          Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {\n            return [shortcut, () => method({ editor })];\n          })\n        );\n        defaultBindings = { ...defaultBindings, ...bindings };\n      }\n      const keyMapPlugin = (0,_tiptap_pm_keymap__WEBPACK_IMPORTED_MODULE_6__.keymap)(defaultBindings);\n      plugins.push(keyMapPlugin);\n      const addInputRules = getExtensionField(extension, \"addInputRules\", context);\n      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\n        const rules = addInputRules();\n        if (rules && rules.length) {\n          const inputResult = inputRulesPlugin({\n            editor,\n            rules\n          });\n          const inputPlugins = Array.isArray(inputResult) ? inputResult : [inputResult];\n          plugins.push(...inputPlugins);\n        }\n      }\n      const addPasteRules = getExtensionField(extension, \"addPasteRules\", context);\n      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\n        const rules = addPasteRules();\n        if (rules && rules.length) {\n          const pasteRules = pasteRulesPlugin({ editor, rules });\n          plugins.push(...pasteRules);\n        }\n      }\n      const addProseMirrorPlugins = getExtensionField(\n        extension,\n        \"addProseMirrorPlugins\",\n        context\n      );\n      if (addProseMirrorPlugins) {\n        const proseMirrorPlugins = addProseMirrorPlugins();\n        plugins.push(...proseMirrorPlugins);\n      }\n      return plugins;\n    });\n    return allPlugins;\n  }\n  /**\n   * Get all attributes from the extensions.\n   * @returns An array of attributes\n   */\n  get attributes() {\n    return getAttributesFromExtensions(this.extensions);\n  }\n  /**\n   * Get all node views from the extensions.\n   * @returns An object with all node views where the key is the node name and the value is the node view function\n   */\n  get nodeViews() {\n    const { editor } = this;\n    const { nodeExtensions } = splitExtensions(this.extensions);\n    return Object.fromEntries(\n      nodeExtensions.filter((extension) => !!getExtensionField(extension, \"addNodeView\")).map((extension) => {\n        const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);\n        const context = {\n          name: extension.name,\n          options: extension.options,\n          storage: this.editor.extensionStorage[extension.name],\n          editor,\n          type: getNodeType(extension.name, this.schema)\n        };\n        const addNodeView = getExtensionField(extension, \"addNodeView\", context);\n        if (!addNodeView) {\n          return [];\n        }\n        const nodeview = (node, view, getPos, decorations, innerDecorations) => {\n          const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);\n          return addNodeView()({\n            // pass-through\n            node,\n            view,\n            getPos,\n            decorations,\n            innerDecorations,\n            // tiptap-specific\n            editor,\n            extension,\n            HTMLAttributes\n          });\n        };\n        return [extension.name, nodeview];\n      })\n    );\n  }\n  get markViews() {\n    const { editor } = this;\n    const { markExtensions } = splitExtensions(this.extensions);\n    return Object.fromEntries(\n      markExtensions.filter((extension) => !!getExtensionField(extension, \"addMarkView\")).map((extension) => {\n        const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);\n        const context = {\n          name: extension.name,\n          options: extension.options,\n          storage: this.editor.extensionStorage[extension.name],\n          editor,\n          type: getMarkType(extension.name, this.schema)\n        };\n        const addMarkView = getExtensionField(extension, \"addMarkView\", context);\n        if (!addMarkView) {\n          return [];\n        }\n        const markView = (mark, view, inline) => {\n          const HTMLAttributes = getRenderedAttributes(mark, extensionAttributes);\n          return addMarkView()({\n            // pass-through\n            mark,\n            view,\n            inline,\n            // tiptap-specific\n            editor,\n            extension,\n            HTMLAttributes,\n            updateAttributes: (attrs) => {\n              updateMarkViewAttributes(mark, editor, attrs);\n            }\n          });\n        };\n        return [extension.name, markView];\n      })\n    );\n  }\n  /**\n   * Go through all extensions, create extension storages & setup marks\n   * & bind editor event listener.\n   */\n  setupExtensions() {\n    const extensions = this.extensions;\n    this.editor.extensionStorage = Object.fromEntries(\n      extensions.map((extension) => [extension.name, extension.storage])\n    );\n    extensions.forEach((extension) => {\n      var _a;\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: this.editor.extensionStorage[extension.name],\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      if (extension.type === \"mark\") {\n        const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, \"keepOnSplit\", context))) != null ? _a : true;\n        if (keepOnSplit) {\n          this.splittableMarks.push(extension.name);\n        }\n      }\n      const onBeforeCreate = getExtensionField(extension, \"onBeforeCreate\", context);\n      const onCreate = getExtensionField(extension, \"onCreate\", context);\n      const onUpdate = getExtensionField(extension, \"onUpdate\", context);\n      const onSelectionUpdate = getExtensionField(\n        extension,\n        \"onSelectionUpdate\",\n        context\n      );\n      const onTransaction = getExtensionField(extension, \"onTransaction\", context);\n      const onFocus = getExtensionField(extension, \"onFocus\", context);\n      const onBlur = getExtensionField(extension, \"onBlur\", context);\n      const onDestroy = getExtensionField(extension, \"onDestroy\", context);\n      if (onBeforeCreate) {\n        this.editor.on(\"beforeCreate\", onBeforeCreate);\n      }\n      if (onCreate) {\n        this.editor.on(\"create\", onCreate);\n      }\n      if (onUpdate) {\n        this.editor.on(\"update\", onUpdate);\n      }\n      if (onSelectionUpdate) {\n        this.editor.on(\"selectionUpdate\", onSelectionUpdate);\n      }\n      if (onTransaction) {\n        this.editor.on(\"transaction\", onTransaction);\n      }\n      if (onFocus) {\n        this.editor.on(\"focus\", onFocus);\n      }\n      if (onBlur) {\n        this.editor.on(\"blur\", onBlur);\n      }\n      if (onDestroy) {\n        this.editor.on(\"destroy\", onDestroy);\n      }\n    });\n  }\n};\nExtensionManager.resolve = resolveExtensions;\nExtensionManager.sort = sortExtensions;\nExtensionManager.flatten = flattenExtensions;\n\n// src/extensions/index.ts\nvar extensions_exports = {};\n__export(extensions_exports, {\n  ClipboardTextSerializer: () => ClipboardTextSerializer,\n  Commands: () => Commands,\n  Delete: () => Delete,\n  Drop: () => Drop,\n  Editable: () => Editable,\n  FocusEvents: () => FocusEvents,\n  Keymap: () => Keymap,\n  Paste: () => Paste,\n  Tabindex: () => Tabindex,\n  focusEventsPluginKey: () => focusEventsPluginKey\n});\n\n// src/extensions/clipboardTextSerializer.ts\n\n\n// src/Extension.ts\nvar Extension = class _Extension extends Extendable {\n  constructor() {\n    super(...arguments);\n    this.type = \"extension\";\n  }\n  /**\n   * Create a new Extension instance\n   * @param config - Extension configuration object or a function that returns a configuration object\n   */\n  static create(config = {}) {\n    const resolvedConfig = typeof config === \"function\" ? config() : config;\n    return new _Extension(resolvedConfig);\n  }\n  configure(options) {\n    return super.configure(options);\n  }\n  extend(extendedConfig) {\n    const resolvedConfig = typeof extendedConfig === \"function\" ? extendedConfig() : extendedConfig;\n    return super.extend(resolvedConfig);\n  }\n};\n\n// src/extensions/clipboardTextSerializer.ts\nvar ClipboardTextSerializer = Extension.create({\n  name: \"clipboardTextSerializer\",\n  addOptions() {\n    return {\n      blockSeparator: void 0\n    };\n  },\n  addProseMirrorPlugins() {\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"clipboardTextSerializer\"),\n        props: {\n          clipboardTextSerializer: () => {\n            const { editor } = this;\n            const { state, schema } = editor;\n            const { doc, selection } = state;\n            const { ranges } = selection;\n            const from = Math.min(...ranges.map((range2) => range2.$from.pos));\n            const to = Math.max(...ranges.map((range2) => range2.$to.pos));\n            const textSerializers = getTextSerializersFromSchema(schema);\n            const range = { from, to };\n            return getTextBetween(doc, range, {\n              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},\n              textSerializers\n            });\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/extensions/commands.ts\nvar Commands = Extension.create({\n  name: \"commands\",\n  addCommands() {\n    return {\n      ...commands_exports\n    };\n  }\n});\n\n// src/extensions/delete.ts\n\nvar Delete = Extension.create({\n  name: \"delete\",\n  onUpdate({ transaction, appendedTransactions }) {\n    var _a, _b, _c;\n    const callback = () => {\n      var _a2, _b2, _c2, _d;\n      if ((_d = (_c2 = (_b2 = (_a2 = this.editor.options.coreExtensionOptions) == null ? void 0 : _a2.delete) == null ? void 0 : _b2.filterTransaction) == null ? void 0 : _c2.call(_b2, transaction)) != null ? _d : transaction.getMeta(\"y-sync$\")) {\n        return;\n      }\n      const nextTransaction = combineTransactionSteps(transaction.before, [transaction, ...appendedTransactions]);\n      const changes = getChangedRanges(nextTransaction);\n      changes.forEach((change) => {\n        if (nextTransaction.mapping.mapResult(change.oldRange.from).deletedAfter && nextTransaction.mapping.mapResult(change.oldRange.to).deletedBefore) {\n          nextTransaction.before.nodesBetween(change.oldRange.from, change.oldRange.to, (node, from) => {\n            const to = from + node.nodeSize - 2;\n            const isFullyWithinRange = change.oldRange.from <= from && to <= change.oldRange.to;\n            this.editor.emit(\"delete\", {\n              type: \"node\",\n              node,\n              from,\n              to,\n              newFrom: nextTransaction.mapping.map(from),\n              newTo: nextTransaction.mapping.map(to),\n              deletedRange: change.oldRange,\n              newRange: change.newRange,\n              partial: !isFullyWithinRange,\n              editor: this.editor,\n              transaction,\n              combinedTransform: nextTransaction\n            });\n          });\n        }\n      });\n      const mapping = nextTransaction.mapping;\n      nextTransaction.steps.forEach((step, index) => {\n        var _a3, _b3;\n        if (step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveMarkStep) {\n          const newStart = mapping.slice(index).map(step.from, -1);\n          const newEnd = mapping.slice(index).map(step.to);\n          const oldStart = mapping.invert().map(newStart, -1);\n          const oldEnd = mapping.invert().map(newEnd);\n          const foundBeforeMark = (_a3 = nextTransaction.doc.nodeAt(newStart - 1)) == null ? void 0 : _a3.marks.some((mark) => mark.eq(step.mark));\n          const foundAfterMark = (_b3 = nextTransaction.doc.nodeAt(newEnd)) == null ? void 0 : _b3.marks.some((mark) => mark.eq(step.mark));\n          this.editor.emit(\"delete\", {\n            type: \"mark\",\n            mark: step.mark,\n            from: step.from,\n            to: step.to,\n            deletedRange: {\n              from: oldStart,\n              to: oldEnd\n            },\n            newRange: {\n              from: newStart,\n              to: newEnd\n            },\n            partial: Boolean(foundAfterMark || foundBeforeMark),\n            editor: this.editor,\n            transaction,\n            combinedTransform: nextTransaction\n          });\n        }\n      });\n    };\n    if ((_c = (_b = (_a = this.editor.options.coreExtensionOptions) == null ? void 0 : _a.delete) == null ? void 0 : _b.async) != null ? _c : true) {\n      setTimeout(callback, 0);\n    } else {\n      callback();\n    }\n  }\n});\n\n// src/extensions/drop.ts\n\nvar Drop = Extension.create({\n  name: \"drop\",\n  addProseMirrorPlugins() {\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"tiptapDrop\"),\n        props: {\n          handleDrop: (_, e, slice, moved) => {\n            this.editor.emit(\"drop\", {\n              editor: this.editor,\n              event: e,\n              slice,\n              moved\n            });\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/extensions/editable.ts\n\nvar Editable = Extension.create({\n  name: \"editable\",\n  addProseMirrorPlugins() {\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"editable\"),\n        props: {\n          editable: () => this.editor.options.editable\n        }\n      })\n    ];\n  }\n});\n\n// src/extensions/focusEvents.ts\n\nvar focusEventsPluginKey = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"focusEvents\");\nvar FocusEvents = Extension.create({\n  name: \"focusEvents\",\n  addProseMirrorPlugins() {\n    const { editor } = this;\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n        key: focusEventsPluginKey,\n        props: {\n          handleDOMEvents: {\n            focus: (view, event) => {\n              editor.isFocused = true;\n              const transaction = editor.state.tr.setMeta(\"focus\", { event }).setMeta(\"addToHistory\", false);\n              view.dispatch(transaction);\n              return false;\n            },\n            blur: (view, event) => {\n              editor.isFocused = false;\n              const transaction = editor.state.tr.setMeta(\"blur\", { event }).setMeta(\"addToHistory\", false);\n              view.dispatch(transaction);\n              return false;\n            }\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/extensions/keymap.ts\n\nvar Keymap = Extension.create({\n  name: \"keymap\",\n  addKeyboardShortcuts() {\n    const handleBackspace = () => this.editor.commands.first(({ commands }) => [\n      () => commands.undoInputRule(),\n      // maybe convert first text block node to default node\n      () => commands.command(({ tr }) => {\n        const { selection, doc } = tr;\n        const { empty, $anchor } = selection;\n        const { pos, parent } = $anchor;\n        const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr.doc.resolve(pos - 1) : $anchor;\n        const parentIsIsolating = $parentPos.parent.type.spec.isolating;\n        const parentPos = $anchor.pos - $anchor.parentOffset;\n        const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Selection.atStart(doc).from === pos;\n        if (!empty || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === \"paragraph\") {\n          return false;\n        }\n        return commands.clearNodes();\n      }),\n      () => commands.deleteSelection(),\n      () => commands.joinBackward(),\n      () => commands.selectNodeBackward()\n    ]);\n    const handleDelete = () => this.editor.commands.first(({ commands }) => [\n      () => commands.deleteSelection(),\n      () => commands.deleteCurrentNode(),\n      () => commands.joinForward(),\n      () => commands.selectNodeForward()\n    ]);\n    const handleEnter = () => this.editor.commands.first(({ commands }) => [\n      () => commands.newlineInCode(),\n      () => commands.createParagraphNear(),\n      () => commands.liftEmptyBlock(),\n      () => commands.splitBlock()\n    ]);\n    const baseKeymap = {\n      Enter: handleEnter,\n      \"Mod-Enter\": () => this.editor.commands.exitCode(),\n      Backspace: handleBackspace,\n      \"Mod-Backspace\": handleBackspace,\n      \"Shift-Backspace\": handleBackspace,\n      Delete: handleDelete,\n      \"Mod-Delete\": handleDelete,\n      \"Mod-a\": () => this.editor.commands.selectAll()\n    };\n    const pcKeymap = {\n      ...baseKeymap\n    };\n    const macKeymap = {\n      ...baseKeymap,\n      \"Ctrl-h\": handleBackspace,\n      \"Alt-Backspace\": handleBackspace,\n      \"Ctrl-d\": handleDelete,\n      \"Ctrl-Alt-Backspace\": handleDelete,\n      \"Alt-Delete\": handleDelete,\n      \"Alt-d\": handleDelete,\n      \"Ctrl-a\": () => this.editor.commands.selectTextblockStart(),\n      \"Ctrl-e\": () => this.editor.commands.selectTextblockEnd()\n    };\n    if (isiOS() || isMacOS()) {\n      return macKeymap;\n    }\n    return pcKeymap;\n  },\n  addProseMirrorPlugins() {\n    return [\n      // With this plugin we check if the whole document was selected and deleted.\n      // In this case we will additionally call `clearNodes()` to convert e.g. a heading\n      // to a paragraph if necessary.\n      // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well\n      // with many other commands.\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"clearDocument\"),\n        appendTransaction: (transactions, oldState, newState) => {\n          if (transactions.some((tr2) => tr2.getMeta(\"composition\"))) {\n            return;\n          }\n          const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);\n          const ignoreTr = transactions.some((transaction) => transaction.getMeta(\"preventClearDocument\"));\n          if (!docChanges || ignoreTr) {\n            return;\n          }\n          const { empty, from, to } = oldState.selection;\n          const allFrom = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Selection.atStart(oldState.doc).from;\n          const allEnd = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Selection.atEnd(oldState.doc).to;\n          const allWasSelected = from === allFrom && to === allEnd;\n          if (empty || !allWasSelected) {\n            return;\n          }\n          const isEmpty = isNodeEmpty(newState.doc);\n          if (!isEmpty) {\n            return;\n          }\n          const tr = newState.tr;\n          const state = createChainableState({\n            state: newState,\n            transaction: tr\n          });\n          const { commands } = new CommandManager({\n            editor: this.editor,\n            state\n          });\n          commands.clearNodes();\n          if (!tr.steps.length) {\n            return;\n          }\n          return tr;\n        }\n      })\n    ];\n  }\n});\n\n// src/extensions/paste.ts\n\nvar Paste = Extension.create({\n  name: \"paste\",\n  addProseMirrorPlugins() {\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"tiptapPaste\"),\n        props: {\n          handlePaste: (_view, e, slice) => {\n            this.editor.emit(\"paste\", {\n              editor: this.editor,\n              event: e,\n              slice\n            });\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/extensions/tabindex.ts\n\nvar Tabindex = Extension.create({\n  name: \"tabindex\",\n  addProseMirrorPlugins() {\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"tabindex\"),\n        props: {\n          attributes: () => this.editor.isEditable ? { tabindex: \"0\" } : {}\n        }\n      })\n    ];\n  }\n});\n\n// src/NodePos.ts\nvar NodePos = class _NodePos {\n  constructor(pos, editor, isBlock = false, node = null) {\n    this.currentNode = null;\n    this.actualDepth = null;\n    this.isBlock = isBlock;\n    this.resolvedPos = pos;\n    this.editor = editor;\n    this.currentNode = node;\n  }\n  get name() {\n    return this.node.type.name;\n  }\n  get node() {\n    return this.currentNode || this.resolvedPos.node();\n  }\n  get element() {\n    return this.editor.view.domAtPos(this.pos).node;\n  }\n  get depth() {\n    var _a;\n    return (_a = this.actualDepth) != null ? _a : this.resolvedPos.depth;\n  }\n  get pos() {\n    return this.resolvedPos.pos;\n  }\n  get content() {\n    return this.node.content;\n  }\n  set content(content) {\n    let from = this.from;\n    let to = this.to;\n    if (this.isBlock) {\n      if (this.content.size === 0) {\n        console.error(`You can\\u2019t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);\n        return;\n      }\n      from = this.from + 1;\n      to = this.to - 1;\n    }\n    this.editor.commands.insertContentAt({ from, to }, content);\n  }\n  get attributes() {\n    return this.node.attrs;\n  }\n  get textContent() {\n    return this.node.textContent;\n  }\n  get size() {\n    return this.node.nodeSize;\n  }\n  get from() {\n    if (this.isBlock) {\n      return this.pos;\n    }\n    return this.resolvedPos.start(this.resolvedPos.depth);\n  }\n  get range() {\n    return {\n      from: this.from,\n      to: this.to\n    };\n  }\n  get to() {\n    if (this.isBlock) {\n      return this.pos + this.size;\n    }\n    return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);\n  }\n  get parent() {\n    if (this.depth === 0) {\n      return null;\n    }\n    const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);\n    const $pos = this.resolvedPos.doc.resolve(parentPos);\n    return new _NodePos($pos, this.editor);\n  }\n  get before() {\n    let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));\n    if ($pos.depth !== this.depth) {\n      $pos = this.resolvedPos.doc.resolve(this.from - 3);\n    }\n    return new _NodePos($pos, this.editor);\n  }\n  get after() {\n    let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));\n    if ($pos.depth !== this.depth) {\n      $pos = this.resolvedPos.doc.resolve(this.to + 3);\n    }\n    return new _NodePos($pos, this.editor);\n  }\n  get children() {\n    const children = [];\n    this.node.content.forEach((node, offset) => {\n      const isBlock = node.isBlock && !node.isTextblock;\n      const isNonTextAtom = node.isAtom && !node.isText;\n      const targetPos = this.pos + offset + (isNonTextAtom ? 0 : 1);\n      if (targetPos < 0 || targetPos > this.resolvedPos.doc.nodeSize - 2) {\n        return;\n      }\n      const $pos = this.resolvedPos.doc.resolve(targetPos);\n      if (!isBlock && $pos.depth <= this.depth) {\n        return;\n      }\n      const childNodePos = new _NodePos($pos, this.editor, isBlock, isBlock ? node : null);\n      if (isBlock) {\n        childNodePos.actualDepth = this.depth + 1;\n      }\n      children.push(new _NodePos($pos, this.editor, isBlock, isBlock ? node : null));\n    });\n    return children;\n  }\n  get firstChild() {\n    return this.children[0] || null;\n  }\n  get lastChild() {\n    const children = this.children;\n    return children[children.length - 1] || null;\n  }\n  closest(selector, attributes = {}) {\n    let node = null;\n    let currentNode = this.parent;\n    while (currentNode && !node) {\n      if (currentNode.node.type.name === selector) {\n        if (Object.keys(attributes).length > 0) {\n          const nodeAttributes = currentNode.node.attrs;\n          const attrKeys = Object.keys(attributes);\n          for (let index = 0; index < attrKeys.length; index += 1) {\n            const key = attrKeys[index];\n            if (nodeAttributes[key] !== attributes[key]) {\n              break;\n            }\n          }\n        } else {\n          node = currentNode;\n        }\n      }\n      currentNode = currentNode.parent;\n    }\n    return node;\n  }\n  querySelector(selector, attributes = {}) {\n    return this.querySelectorAll(selector, attributes, true)[0] || null;\n  }\n  querySelectorAll(selector, attributes = {}, firstItemOnly = false) {\n    let nodes = [];\n    if (!this.children || this.children.length === 0) {\n      return nodes;\n    }\n    const attrKeys = Object.keys(attributes);\n    this.children.forEach((childPos) => {\n      if (firstItemOnly && nodes.length > 0) {\n        return;\n      }\n      if (childPos.node.type.name === selector) {\n        const doesAllAttributesMatch = attrKeys.every((key) => attributes[key] === childPos.node.attrs[key]);\n        if (doesAllAttributesMatch) {\n          nodes.push(childPos);\n        }\n      }\n      if (firstItemOnly && nodes.length > 0) {\n        return;\n      }\n      nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));\n    });\n    return nodes;\n  }\n  setAttribute(attributes) {\n    const { tr } = this.editor.state;\n    tr.setNodeMarkup(this.from, void 0, {\n      ...this.node.attrs,\n      ...attributes\n    });\n    this.editor.view.dispatch(tr);\n  }\n};\n\n// src/style.ts\nvar style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 0 !important;\n  height: 0 !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}`;\n\n// src/utilities/createStyleTag.ts\nfunction createStyleTag(style2, nonce, suffix) {\n  const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : \"\"}]`);\n  if (tiptapStyleTag !== null) {\n    return tiptapStyleTag;\n  }\n  const styleNode = document.createElement(\"style\");\n  if (nonce) {\n    styleNode.setAttribute(\"nonce\", nonce);\n  }\n  styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : \"\"}`, \"\");\n  styleNode.innerHTML = style2;\n  document.getElementsByTagName(\"head\")[0].appendChild(styleNode);\n  return styleNode;\n}\n\n// src/Editor.ts\nvar Editor = class extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    this.css = null;\n    this.editorView = null;\n    this.isFocused = false;\n    /**\n     * The editor is considered initialized after the `create` event has been emitted.\n     */\n    this.isInitialized = false;\n    this.extensionStorage = {};\n    /**\n     * A unique ID for this editor instance.\n     */\n    this.instanceId = Math.random().toString(36).slice(2, 9);\n    this.options = {\n      element: typeof document !== \"undefined\" ? document.createElement(\"div\") : null,\n      content: \"\",\n      injectCSS: true,\n      injectNonce: void 0,\n      extensions: [],\n      autofocus: false,\n      editable: true,\n      editorProps: {},\n      parseOptions: {},\n      coreExtensionOptions: {},\n      enableInputRules: true,\n      enablePasteRules: true,\n      enableCoreExtensions: true,\n      enableContentCheck: false,\n      emitContentError: false,\n      onBeforeCreate: () => null,\n      onCreate: () => null,\n      onMount: () => null,\n      onUnmount: () => null,\n      onUpdate: () => null,\n      onSelectionUpdate: () => null,\n      onTransaction: () => null,\n      onFocus: () => null,\n      onBlur: () => null,\n      onDestroy: () => null,\n      onContentError: ({ error }) => {\n        throw error;\n      },\n      onPaste: () => null,\n      onDrop: () => null,\n      onDelete: () => null\n    };\n    this.isCapturingTransaction = false;\n    this.capturedTransaction = null;\n    this.setOptions(options);\n    this.createExtensionManager();\n    this.createCommandManager();\n    this.createSchema();\n    this.on(\"beforeCreate\", this.options.onBeforeCreate);\n    this.emit(\"beforeCreate\", { editor: this });\n    this.on(\"mount\", this.options.onMount);\n    this.on(\"unmount\", this.options.onUnmount);\n    this.on(\"contentError\", this.options.onContentError);\n    this.on(\"create\", this.options.onCreate);\n    this.on(\"update\", this.options.onUpdate);\n    this.on(\"selectionUpdate\", this.options.onSelectionUpdate);\n    this.on(\"transaction\", this.options.onTransaction);\n    this.on(\"focus\", this.options.onFocus);\n    this.on(\"blur\", this.options.onBlur);\n    this.on(\"destroy\", this.options.onDestroy);\n    this.on(\"drop\", ({ event, slice, moved }) => this.options.onDrop(event, slice, moved));\n    this.on(\"paste\", ({ event, slice }) => this.options.onPaste(event, slice));\n    this.on(\"delete\", this.options.onDelete);\n    const initialDoc = this.createDoc();\n    const selection = resolveFocusPosition(initialDoc, this.options.autofocus);\n    this.editorState = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.create({\n      doc: initialDoc,\n      schema: this.schema,\n      selection: selection || void 0\n    });\n    if (this.options.element) {\n      this.mount(this.options.element);\n    }\n  }\n  /**\n   * Attach the editor to the DOM, creating a new editor view.\n   */\n  mount(el) {\n    if (typeof document === \"undefined\") {\n      throw new Error(\n        `[tiptap error]: The editor cannot be mounted because there is no 'document' defined in this environment.`\n      );\n    }\n    this.createView(el);\n    this.emit(\"mount\", { editor: this });\n    if (this.css && !document.head.contains(this.css)) {\n      document.head.appendChild(this.css);\n    }\n    window.setTimeout(() => {\n      if (this.isDestroyed) {\n        return;\n      }\n      this.commands.focus(this.options.autofocus);\n      this.emit(\"create\", { editor: this });\n      this.isInitialized = true;\n    }, 0);\n  }\n  /**\n   * Remove the editor from the DOM, but still allow remounting at a different point in time\n   */\n  unmount() {\n    if (this.editorView) {\n      const dom = this.editorView.dom;\n      if (dom == null ? void 0 : dom.editor) {\n        delete dom.editor;\n      }\n      this.editorView.destroy();\n    }\n    this.editorView = null;\n    this.isInitialized = false;\n    if (this.css) {\n      try {\n        if (typeof this.css.remove === \"function\") {\n          this.css.remove();\n        } else if (this.css.parentNode) {\n          this.css.parentNode.removeChild(this.css);\n        }\n      } catch (error) {\n        console.warn(\"Failed to remove CSS element:\", error);\n      }\n    }\n    this.css = null;\n    this.emit(\"unmount\", { editor: this });\n  }\n  /**\n   * Returns the editor storage.\n   */\n  get storage() {\n    return this.extensionStorage;\n  }\n  /**\n   * An object of all registered commands.\n   */\n  get commands() {\n    return this.commandManager.commands;\n  }\n  /**\n   * Create a command chain to call multiple commands at once.\n   */\n  chain() {\n    return this.commandManager.chain();\n  }\n  /**\n   * Check if a command or a command chain can be executed. Without executing it.\n   */\n  can() {\n    return this.commandManager.can();\n  }\n  /**\n   * Inject CSS styles.\n   */\n  injectCSS() {\n    if (this.options.injectCSS && typeof document !== \"undefined\") {\n      this.css = createStyleTag(style, this.options.injectNonce);\n    }\n  }\n  /**\n   * Update editor options.\n   *\n   * @param options A list of options\n   */\n  setOptions(options = {}) {\n    this.options = {\n      ...this.options,\n      ...options\n    };\n    if (!this.editorView || !this.state || this.isDestroyed) {\n      return;\n    }\n    if (this.options.editorProps) {\n      this.view.setProps(this.options.editorProps);\n    }\n    this.view.updateState(this.state);\n  }\n  /**\n   * Update editable state of the editor.\n   */\n  setEditable(editable, emitUpdate = true) {\n    this.setOptions({ editable });\n    if (emitUpdate) {\n      this.emit(\"update\", { editor: this, transaction: this.state.tr, appendedTransactions: [] });\n    }\n  }\n  /**\n   * Returns whether the editor is editable.\n   */\n  get isEditable() {\n    return this.options.editable && this.view && this.view.editable;\n  }\n  /**\n   * Returns the editor state.\n   */\n  get view() {\n    if (this.editorView) {\n      return this.editorView;\n    }\n    return new Proxy(\n      {\n        state: this.editorState,\n        updateState: (state) => {\n          this.editorState = state;\n        },\n        dispatch: (tr) => {\n          this.dispatchTransaction(tr);\n        },\n        // Stub some commonly accessed properties to prevent errors\n        composing: false,\n        dragging: null,\n        editable: true,\n        isDestroyed: false\n      },\n      {\n        get: (obj, key) => {\n          if (this.editorView) {\n            return this.editorView[key];\n          }\n          if (key === \"state\") {\n            return this.editorState;\n          }\n          if (key in obj) {\n            return Reflect.get(obj, key);\n          }\n          throw new Error(\n            `[tiptap error]: The editor view is not available. Cannot access view['${key}']. The editor may not be mounted yet.`\n          );\n        }\n      }\n    );\n  }\n  /**\n   * Returns the editor state.\n   */\n  get state() {\n    if (this.editorView) {\n      this.editorState = this.view.state;\n    }\n    return this.editorState;\n  }\n  /**\n   * Register a ProseMirror plugin.\n   *\n   * @param plugin A ProseMirror plugin\n   * @param handlePlugins Control how to merge the plugin into the existing plugins.\n   * @returns The new editor state\n   */\n  registerPlugin(plugin, handlePlugins) {\n    const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];\n    const state = this.state.reconfigure({ plugins });\n    this.view.updateState(state);\n    return state;\n  }\n  /**\n   * Unregister a ProseMirror plugin.\n   *\n   * @param nameOrPluginKeyToRemove The plugins name\n   * @returns The new editor state or undefined if the editor is destroyed\n   */\n  unregisterPlugin(nameOrPluginKeyToRemove) {\n    if (this.isDestroyed) {\n      return void 0;\n    }\n    const prevPlugins = this.state.plugins;\n    let plugins = prevPlugins;\n    [].concat(nameOrPluginKeyToRemove).forEach((nameOrPluginKey) => {\n      const name = typeof nameOrPluginKey === \"string\" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;\n      plugins = plugins.filter((plugin) => !plugin.key.startsWith(name));\n    });\n    if (prevPlugins.length === plugins.length) {\n      return void 0;\n    }\n    const state = this.state.reconfigure({\n      plugins\n    });\n    this.view.updateState(state);\n    return state;\n  }\n  /**\n   * Creates an extension manager.\n   */\n  createExtensionManager() {\n    var _a, _b;\n    const coreExtensions = this.options.enableCoreExtensions ? [\n      Editable,\n      ClipboardTextSerializer.configure({\n        blockSeparator: (_b = (_a = this.options.coreExtensionOptions) == null ? void 0 : _a.clipboardTextSerializer) == null ? void 0 : _b.blockSeparator\n      }),\n      Commands,\n      FocusEvents,\n      Keymap,\n      Tabindex,\n      Drop,\n      Paste,\n      Delete\n    ].filter((ext) => {\n      if (typeof this.options.enableCoreExtensions === \"object\") {\n        return this.options.enableCoreExtensions[ext.name] !== false;\n      }\n      return true;\n    }) : [];\n    const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {\n      return [\"extension\", \"node\", \"mark\"].includes(extension == null ? void 0 : extension.type);\n    });\n    this.extensionManager = new ExtensionManager(allExtensions, this);\n  }\n  /**\n   * Creates an command manager.\n   */\n  createCommandManager() {\n    this.commandManager = new CommandManager({\n      editor: this\n    });\n  }\n  /**\n   * Creates a ProseMirror schema.\n   */\n  createSchema() {\n    this.schema = this.extensionManager.schema;\n  }\n  /**\n   * Creates the initial document.\n   */\n  createDoc() {\n    let doc;\n    try {\n      doc = createDocument(this.options.content, this.schema, this.options.parseOptions, {\n        errorOnInvalidContent: this.options.enableContentCheck\n      });\n    } catch (e) {\n      if (!(e instanceof Error) || ![\"[tiptap error]: Invalid JSON content\", \"[tiptap error]: Invalid HTML content\"].includes(e.message)) {\n        throw e;\n      }\n      this.emit(\"contentError\", {\n        editor: this,\n        error: e,\n        disableCollaboration: () => {\n          if (\"collaboration\" in this.storage && typeof this.storage.collaboration === \"object\" && this.storage.collaboration) {\n            ;\n            this.storage.collaboration.isDisabled = true;\n          }\n          this.options.extensions = this.options.extensions.filter((extension) => extension.name !== \"collaboration\");\n          this.createExtensionManager();\n        }\n      });\n      doc = createDocument(this.options.content, this.schema, this.options.parseOptions, {\n        errorOnInvalidContent: false\n      });\n    }\n    return doc;\n  }\n  /**\n   * Creates a ProseMirror view.\n   */\n  createView(element) {\n    var _a;\n    this.editorView = new _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_5__.EditorView(element, {\n      ...this.options.editorProps,\n      attributes: {\n        // add `role=\"textbox\"` to the editor element\n        role: \"textbox\",\n        ...(_a = this.options.editorProps) == null ? void 0 : _a.attributes\n      },\n      dispatchTransaction: this.dispatchTransaction.bind(this),\n      state: this.editorState,\n      markViews: this.extensionManager.markViews,\n      nodeViews: this.extensionManager.nodeViews\n    });\n    const newState = this.state.reconfigure({\n      plugins: this.extensionManager.plugins\n    });\n    this.view.updateState(newState);\n    this.prependClass();\n    this.injectCSS();\n    const dom = this.view.dom;\n    dom.editor = this;\n  }\n  /**\n   * Creates all node and mark views.\n   */\n  createNodeViews() {\n    if (this.view.isDestroyed) {\n      return;\n    }\n    this.view.setProps({\n      markViews: this.extensionManager.markViews,\n      nodeViews: this.extensionManager.nodeViews\n    });\n  }\n  /**\n   * Prepend class name to element.\n   */\n  prependClass() {\n    this.view.dom.className = `tiptap ${this.view.dom.className}`;\n  }\n  captureTransaction(fn) {\n    this.isCapturingTransaction = true;\n    fn();\n    this.isCapturingTransaction = false;\n    const tr = this.capturedTransaction;\n    this.capturedTransaction = null;\n    return tr;\n  }\n  /**\n   * The callback over which to send transactions (state updates) produced by the view.\n   *\n   * @param transaction An editor state transaction\n   */\n  dispatchTransaction(transaction) {\n    if (this.view.isDestroyed) {\n      return;\n    }\n    if (this.isCapturingTransaction) {\n      if (!this.capturedTransaction) {\n        this.capturedTransaction = transaction;\n        return;\n      }\n      transaction.steps.forEach((step) => {\n        var _a;\n        return (_a = this.capturedTransaction) == null ? void 0 : _a.step(step);\n      });\n      return;\n    }\n    const { state, transactions } = this.state.applyTransaction(transaction);\n    const selectionHasChanged = !this.state.selection.eq(state.selection);\n    const rootTrWasApplied = transactions.includes(transaction);\n    const prevState = this.state;\n    this.emit(\"beforeTransaction\", {\n      editor: this,\n      transaction,\n      nextState: state\n    });\n    if (!rootTrWasApplied) {\n      return;\n    }\n    this.view.updateState(state);\n    this.emit(\"transaction\", {\n      editor: this,\n      transaction,\n      appendedTransactions: transactions.slice(1)\n    });\n    if (selectionHasChanged) {\n      this.emit(\"selectionUpdate\", {\n        editor: this,\n        transaction\n      });\n    }\n    const mostRecentFocusTr = transactions.findLast((tr) => tr.getMeta(\"focus\") || tr.getMeta(\"blur\"));\n    const focus2 = mostRecentFocusTr == null ? void 0 : mostRecentFocusTr.getMeta(\"focus\");\n    const blur2 = mostRecentFocusTr == null ? void 0 : mostRecentFocusTr.getMeta(\"blur\");\n    if (focus2) {\n      this.emit(\"focus\", {\n        editor: this,\n        event: focus2.event,\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        transaction: mostRecentFocusTr\n      });\n    }\n    if (blur2) {\n      this.emit(\"blur\", {\n        editor: this,\n        event: blur2.event,\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        transaction: mostRecentFocusTr\n      });\n    }\n    if (transaction.getMeta(\"preventUpdate\") || !transactions.some((tr) => tr.docChanged) || prevState.doc.eq(state.doc)) {\n      return;\n    }\n    this.emit(\"update\", {\n      editor: this,\n      transaction,\n      appendedTransactions: transactions.slice(1)\n    });\n  }\n  /**\n   * Get attributes of the currently selected node or mark.\n   */\n  getAttributes(nameOrType) {\n    return getAttributes(this.state, nameOrType);\n  }\n  isActive(nameOrAttributes, attributesOrUndefined) {\n    const name = typeof nameOrAttributes === \"string\" ? nameOrAttributes : null;\n    const attributes = typeof nameOrAttributes === \"string\" ? attributesOrUndefined : nameOrAttributes;\n    return isActive(this.state, name, attributes);\n  }\n  /**\n   * Get the document as JSON.\n   */\n  getJSON() {\n    return this.state.doc.toJSON();\n  }\n  /**\n   * Get the document as HTML.\n   */\n  getHTML() {\n    return getHTMLFromFragment(this.state.doc.content, this.schema);\n  }\n  /**\n   * Get the document as text.\n   */\n  getText(options) {\n    const { blockSeparator = \"\\n\\n\", textSerializers = {} } = options || {};\n    return getText(this.state.doc, {\n      blockSeparator,\n      textSerializers: {\n        ...getTextSerializersFromSchema(this.schema),\n        ...textSerializers\n      }\n    });\n  }\n  /**\n   * Check if there is no content.\n   */\n  get isEmpty() {\n    return isNodeEmpty(this.state.doc);\n  }\n  /**\n   * Destroy the editor.\n   */\n  destroy() {\n    this.emit(\"destroy\");\n    this.unmount();\n    this.removeAllListeners();\n  }\n  /**\n   * Check if the editor is already destroyed.\n   */\n  get isDestroyed() {\n    var _a, _b;\n    return (_b = (_a = this.editorView) == null ? void 0 : _a.isDestroyed) != null ? _b : true;\n  }\n  $node(selector, attributes) {\n    var _a;\n    return ((_a = this.$doc) == null ? void 0 : _a.querySelector(selector, attributes)) || null;\n  }\n  $nodes(selector, attributes) {\n    var _a;\n    return ((_a = this.$doc) == null ? void 0 : _a.querySelectorAll(selector, attributes)) || null;\n  }\n  $pos(pos) {\n    const $pos = this.state.doc.resolve(pos);\n    return new NodePos($pos, this);\n  }\n  get $doc() {\n    return this.$pos(0);\n  }\n};\n\n// src/inputRules/markInputRule.ts\nfunction markInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, void 0, match);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      const { tr } = state;\n      const captureGroup = match[match.length - 1];\n      const fullMatch = match[0];\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/);\n        const textStart = range.from + fullMatch.indexOf(captureGroup);\n        const textEnd = textStart + captureGroup.length;\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {\n          const excluded = item.mark.type.excluded;\n          return excluded.find((type) => type === config.type && type !== item.mark.type);\n        }).filter((item) => item.to > textStart);\n        if (excludedMarks.length) {\n          return null;\n        }\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to);\n        }\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart);\n        }\n        const markEnd = range.from + startSpaces + captureGroup.length;\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n        tr.removeStoredMark(config.type);\n      }\n    },\n    undoable: config.undoable\n  });\n}\n\n// src/inputRules/nodeInputRule.ts\nfunction nodeInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};\n      const { tr } = state;\n      const start = range.from;\n      let end = range.to;\n      const newNode = config.type.create(attributes);\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        let matchStart = start + offset;\n        if (matchStart > end) {\n          matchStart = end;\n        } else {\n          end = matchStart + match[1].length;\n        }\n        const lastChar = match[0][match[0].length - 1];\n        tr.insertText(lastChar, start + match[0].length - 1);\n        tr.replaceWith(matchStart, end, newNode);\n      } else if (match[0]) {\n        const insertionStart = config.type.isInline ? start : start - 1;\n        tr.insert(insertionStart, config.type.create(attributes)).delete(tr.mapping.map(start), tr.mapping.map(end));\n      }\n      tr.scrollIntoView();\n    },\n    undoable: config.undoable\n  });\n}\n\n// src/inputRules/textblockTypeInputRule.ts\nfunction textblockTypeInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const $start = state.doc.resolve(range.from);\n      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};\n      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\n        return null;\n      }\n      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);\n    },\n    undoable: config.undoable\n  });\n}\n\n// src/inputRules/textInputRule.ts\nfunction textInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      let insert = config.replace;\n      let start = range.from;\n      const end = range.to;\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        insert += match[0].slice(offset + match[1].length);\n        start += offset;\n        const cutOff = start - end;\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert;\n          start = end;\n        }\n      }\n      state.tr.insertText(insert, start, end);\n    },\n    undoable: config.undoable\n  });\n}\n\n// src/inputRules/wrappingInputRule.ts\n\nfunction wrappingInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match, chain }) => {\n      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};\n      const tr = state.tr.delete(range.from, range.to);\n      const $start = tr.doc.resolve(range.from);\n      const blockRange = $start.blockRange();\n      const wrapping = blockRange && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping)(blockRange, config.type, attributes);\n      if (!wrapping) {\n        return null;\n      }\n      tr.wrap(blockRange, wrapping);\n      if (config.keepMarks && config.editor) {\n        const { selection, storedMarks } = state;\n        const { splittableMarks } = config.editor.extensionManager;\n        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n        if (marks) {\n          const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));\n          tr.ensureMarks(filteredMarks);\n        }\n      }\n      if (config.keepAttributes) {\n        const nodeType = config.type.name === \"bulletList\" || config.type.name === \"orderedList\" ? \"listItem\" : \"taskList\";\n        chain().updateAttributes(nodeType, attributes).run();\n      }\n      const before = tr.doc.resolve(range.from - 1).nodeBefore;\n      if (before && before.type === config.type && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {\n        tr.join(range.from - 1);\n      }\n    },\n    undoable: config.undoable\n  });\n}\n\n// src/jsx-runtime.ts\nfunction Fragment6(props) {\n  return props.children;\n}\nvar h = (tag, attributes) => {\n  if (tag === \"slot\") {\n    return 0;\n  }\n  if (tag instanceof Function) {\n    return tag(attributes);\n  }\n  const { children, ...rest } = attributes != null ? attributes : {};\n  if (tag === \"svg\") {\n    throw new Error(\"SVG elements are not supported in the JSX syntax, use the array syntax instead\");\n  }\n  return [tag, rest, children];\n};\n\n// src/utilities/canInsertNode.ts\n\nfunction canInsertNode(state, nodeType) {\n  const { selection } = state;\n  const { $from } = selection;\n  if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection) {\n    const index = $from.index();\n    const parent = $from.parent;\n    return parent.canReplaceWith(index, index + 1, nodeType);\n  }\n  let depth = $from.depth;\n  while (depth >= 0) {\n    const index = $from.index(depth);\n    const parent = $from.node(depth);\n    const match = parent.contentMatchAt(index);\n    if (match.matchType(nodeType)) {\n      return true;\n    }\n    depth -= 1;\n  }\n  return false;\n}\n\n// src/utilities/escapeForRegEx.ts\nfunction escapeForRegEx(string) {\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\n\n// src/utilities/isString.ts\nfunction isString(value) {\n  return typeof value === \"string\";\n}\n\n// src/utilities/markdown/index.ts\nvar markdown_exports = {};\n__export(markdown_exports, {\n  createAtomBlockMarkdownSpec: () => createAtomBlockMarkdownSpec,\n  createBlockMarkdownSpec: () => createBlockMarkdownSpec,\n  createInlineMarkdownSpec: () => createInlineMarkdownSpec,\n  parseAttributes: () => parseAttributes,\n  parseIndentedBlocks: () => parseIndentedBlocks,\n  renderNestedMarkdownContent: () => renderNestedMarkdownContent,\n  serializeAttributes: () => serializeAttributes\n});\n\n// src/utilities/markdown/attributeUtils.ts\nfunction parseAttributes(attrString) {\n  if (!(attrString == null ? void 0 : attrString.trim())) {\n    return {};\n  }\n  const attributes = {};\n  const quotedStrings = [];\n  const tempString = attrString.replace(/[\"']([^\"']*)[\"']/g, (match) => {\n    quotedStrings.push(match);\n    return `__QUOTED_${quotedStrings.length - 1}__`;\n  });\n  const classMatches = tempString.match(/(?:^|\\s)\\.([a-zA-Z][\\w-]*)/g);\n  if (classMatches) {\n    const classes = classMatches.map((match) => match.trim().slice(1));\n    attributes.class = classes.join(\" \");\n  }\n  const idMatch = tempString.match(/(?:^|\\s)#([a-zA-Z][\\w-]*)/);\n  if (idMatch) {\n    attributes.id = idMatch[1];\n  }\n  const kvRegex = /([a-zA-Z][\\w-]*)\\s*=\\s*(__QUOTED_\\d+__)/g;\n  const kvMatches = Array.from(tempString.matchAll(kvRegex));\n  kvMatches.forEach(([, key, quotedRef]) => {\n    var _a;\n    const quotedIndex = parseInt(((_a = quotedRef.match(/__QUOTED_(\\d+)__/)) == null ? void 0 : _a[1]) || \"0\", 10);\n    const quotedValue = quotedStrings[quotedIndex];\n    if (quotedValue) {\n      attributes[key] = quotedValue.slice(1, -1);\n    }\n  });\n  const cleanString = tempString.replace(/(?:^|\\s)\\.([a-zA-Z][\\w-]*)/g, \"\").replace(/(?:^|\\s)#([a-zA-Z][\\w-]*)/g, \"\").replace(/([a-zA-Z][\\w-]*)\\s*=\\s*__QUOTED_\\d+__/g, \"\").trim();\n  if (cleanString) {\n    const booleanAttrs = cleanString.split(/\\s+/).filter(Boolean);\n    booleanAttrs.forEach((attr) => {\n      if (attr.match(/^[a-zA-Z][\\w-]*$/)) {\n        attributes[attr] = true;\n      }\n    });\n  }\n  return attributes;\n}\nfunction serializeAttributes(attributes) {\n  if (!attributes || Object.keys(attributes).length === 0) {\n    return \"\";\n  }\n  const parts = [];\n  if (attributes.class) {\n    const classes = String(attributes.class).split(/\\s+/).filter(Boolean);\n    classes.forEach((cls) => parts.push(`.${cls}`));\n  }\n  if (attributes.id) {\n    parts.push(`#${attributes.id}`);\n  }\n  Object.entries(attributes).forEach(([key, value]) => {\n    if (key === \"class\" || key === \"id\") {\n      return;\n    }\n    if (value === true) {\n      parts.push(key);\n    } else if (value !== false && value != null) {\n      parts.push(`${key}=\"${String(value)}\"`);\n    }\n  });\n  return parts.join(\" \");\n}\n\n// src/utilities/markdown/createAtomBlockMarkdownSpec.ts\nfunction createAtomBlockMarkdownSpec(options) {\n  const {\n    nodeName,\n    name: markdownName,\n    parseAttributes: parseAttributes2 = parseAttributes,\n    serializeAttributes: serializeAttributes2 = serializeAttributes,\n    defaultAttributes = {},\n    requiredAttributes = [],\n    allowedAttributes\n  } = options;\n  const blockName = markdownName || nodeName;\n  const filterAttributes = (attrs) => {\n    if (!allowedAttributes) {\n      return attrs;\n    }\n    const filtered = {};\n    allowedAttributes.forEach((key) => {\n      if (key in attrs) {\n        filtered[key] = attrs[key];\n      }\n    });\n    return filtered;\n  };\n  return {\n    parseMarkdown: (token, h2) => {\n      const attrs = { ...defaultAttributes, ...token.attributes };\n      return h2.createNode(nodeName, attrs, []);\n    },\n    markdownTokenizer: {\n      name: nodeName,\n      level: \"block\",\n      start(src) {\n        var _a;\n        const regex = new RegExp(`^:::${blockName}(?:\\\\s|$)`, \"m\");\n        const index = (_a = src.match(regex)) == null ? void 0 : _a.index;\n        return index !== void 0 ? index : -1;\n      },\n      tokenize(src, _tokens, _lexer) {\n        const regex = new RegExp(`^:::${blockName}(?:\\\\s+\\\\{([^}]*)\\\\})?\\\\s*:::(?:\\\\n|$)`);\n        const match = src.match(regex);\n        if (!match) {\n          return void 0;\n        }\n        const attrString = match[1] || \"\";\n        const attributes = parseAttributes2(attrString);\n        const missingRequired = requiredAttributes.find((required) => !(required in attributes));\n        if (missingRequired) {\n          return void 0;\n        }\n        return {\n          type: nodeName,\n          raw: match[0],\n          attributes\n        };\n      }\n    },\n    renderMarkdown: (node) => {\n      const filteredAttrs = filterAttributes(node.attrs || {});\n      const attrs = serializeAttributes2(filteredAttrs);\n      const attrString = attrs ? ` {${attrs}}` : \"\";\n      return `:::${blockName}${attrString} :::`;\n    }\n  };\n}\n\n// src/utilities/markdown/createBlockMarkdownSpec.ts\nfunction createBlockMarkdownSpec(options) {\n  const {\n    nodeName,\n    name: markdownName,\n    getContent,\n    parseAttributes: parseAttributes2 = parseAttributes,\n    serializeAttributes: serializeAttributes2 = serializeAttributes,\n    defaultAttributes = {},\n    content = \"block\",\n    allowedAttributes\n  } = options;\n  const blockName = markdownName || nodeName;\n  const filterAttributes = (attrs) => {\n    if (!allowedAttributes) {\n      return attrs;\n    }\n    const filtered = {};\n    allowedAttributes.forEach((key) => {\n      if (key in attrs) {\n        filtered[key] = attrs[key];\n      }\n    });\n    return filtered;\n  };\n  return {\n    parseMarkdown: (token, h2) => {\n      let nodeContent;\n      if (getContent) {\n        const contentResult = getContent(token);\n        nodeContent = typeof contentResult === \"string\" ? [{ type: \"text\", text: contentResult }] : contentResult;\n      } else if (content === \"block\") {\n        nodeContent = h2.parseChildren(token.tokens || []);\n      } else {\n        nodeContent = h2.parseInline(token.tokens || []);\n      }\n      const attrs = { ...defaultAttributes, ...token.attributes };\n      return h2.createNode(nodeName, attrs, nodeContent);\n    },\n    markdownTokenizer: {\n      name: nodeName,\n      level: \"block\",\n      start(src) {\n        var _a;\n        const regex = new RegExp(`^:::${blockName}`, \"m\");\n        const index = (_a = src.match(regex)) == null ? void 0 : _a.index;\n        return index !== void 0 ? index : -1;\n      },\n      tokenize(src, _tokens, lexer) {\n        var _a;\n        const openingRegex = new RegExp(`^:::${blockName}(?:\\\\s+\\\\{([^}]*)\\\\})?\\\\s*\\\\n`);\n        const openingMatch = src.match(openingRegex);\n        if (!openingMatch) {\n          return void 0;\n        }\n        const [openingTag, attrString = \"\"] = openingMatch;\n        const attributes = parseAttributes2(attrString);\n        let level = 1;\n        const position = openingTag.length;\n        let matchedContent = \"\";\n        const blockPattern = /^:::([\\w-]*)(\\s.*)?/gm;\n        const remaining = src.slice(position);\n        blockPattern.lastIndex = 0;\n        for (; ; ) {\n          const match = blockPattern.exec(remaining);\n          if (match === null) {\n            break;\n          }\n          const matchPos = match.index;\n          const blockType = match[1];\n          if ((_a = match[2]) == null ? void 0 : _a.endsWith(\":::\")) {\n            continue;\n          }\n          if (blockType) {\n            level += 1;\n          } else {\n            level -= 1;\n            if (level === 0) {\n              const rawContent = remaining.slice(0, matchPos);\n              matchedContent = rawContent.trim();\n              const fullMatch = src.slice(0, position + matchPos + match[0].length);\n              let contentTokens = [];\n              if (matchedContent) {\n                if (content === \"block\") {\n                  contentTokens = lexer.blockTokens(rawContent);\n                  contentTokens.forEach((token) => {\n                    if (token.text && (!token.tokens || token.tokens.length === 0)) {\n                      token.tokens = lexer.inlineTokens(token.text);\n                    }\n                  });\n                  while (contentTokens.length > 0) {\n                    const lastToken = contentTokens[contentTokens.length - 1];\n                    if (lastToken.type === \"paragraph\" && (!lastToken.text || lastToken.text.trim() === \"\")) {\n                      contentTokens.pop();\n                    } else {\n                      break;\n                    }\n                  }\n                } else {\n                  contentTokens = lexer.inlineTokens(matchedContent);\n                }\n              }\n              return {\n                type: nodeName,\n                raw: fullMatch,\n                attributes,\n                content: matchedContent,\n                tokens: contentTokens\n              };\n            }\n          }\n        }\n        return void 0;\n      }\n    },\n    renderMarkdown: (node, h2) => {\n      const filteredAttrs = filterAttributes(node.attrs || {});\n      const attrs = serializeAttributes2(filteredAttrs);\n      const attrString = attrs ? ` {${attrs}}` : \"\";\n      const renderedContent = h2.renderChildren(node.content || [], \"\\n\\n\");\n      return `:::${blockName}${attrString}\n\n${renderedContent}\n\n:::`;\n    }\n  };\n}\n\n// src/utilities/markdown/createInlineMarkdownSpec.ts\nfunction parseShortcodeAttributes(attrString) {\n  if (!attrString.trim()) {\n    return {};\n  }\n  const attributes = {};\n  const regex = /(\\w+)=(?:\"([^\"]*)\"|'([^']*)')/g;\n  let match = regex.exec(attrString);\n  while (match !== null) {\n    const [, key, doubleQuoted, singleQuoted] = match;\n    attributes[key] = doubleQuoted || singleQuoted;\n    match = regex.exec(attrString);\n  }\n  return attributes;\n}\nfunction serializeShortcodeAttributes(attrs) {\n  return Object.entries(attrs).filter(([, value]) => value !== void 0 && value !== null).map(([key, value]) => `${key}=\"${value}\"`).join(\" \");\n}\nfunction createInlineMarkdownSpec(options) {\n  const {\n    nodeName,\n    name: shortcodeName,\n    getContent,\n    parseAttributes: parseAttributes2 = parseShortcodeAttributes,\n    serializeAttributes: serializeAttributes2 = serializeShortcodeAttributes,\n    defaultAttributes = {},\n    selfClosing = false,\n    allowedAttributes\n  } = options;\n  const shortcode = shortcodeName || nodeName;\n  const filterAttributes = (attrs) => {\n    if (!allowedAttributes) {\n      return attrs;\n    }\n    const filtered = {};\n    allowedAttributes.forEach((key) => {\n      if (key in attrs) {\n        filtered[key] = attrs[key];\n      }\n    });\n    return filtered;\n  };\n  const escapedShortcode = shortcode.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n  return {\n    parseMarkdown: (token, h2) => {\n      const attrs = { ...defaultAttributes, ...token.attributes };\n      if (selfClosing) {\n        return h2.createNode(nodeName, attrs);\n      }\n      const content = getContent ? getContent(token) : token.content || \"\";\n      if (content) {\n        return h2.createNode(nodeName, attrs, [h2.createTextNode(content)]);\n      }\n      return h2.createNode(nodeName, attrs, []);\n    },\n    markdownTokenizer: {\n      name: nodeName,\n      level: \"inline\",\n      start(src) {\n        const startPattern = selfClosing ? new RegExp(`\\\\[${escapedShortcode}\\\\s*[^\\\\]]*\\\\]`) : new RegExp(`\\\\[${escapedShortcode}\\\\s*[^\\\\]]*\\\\][\\\\s\\\\S]*?\\\\[\\\\/${escapedShortcode}\\\\]`);\n        const match = src.match(startPattern);\n        const index = match == null ? void 0 : match.index;\n        return index !== void 0 ? index : -1;\n      },\n      tokenize(src, _tokens, _lexer) {\n        const tokenPattern = selfClosing ? new RegExp(`^\\\\[${escapedShortcode}\\\\s*([^\\\\]]*)\\\\]`) : new RegExp(`^\\\\[${escapedShortcode}\\\\s*([^\\\\]]*)\\\\]([\\\\s\\\\S]*?)\\\\[\\\\/${escapedShortcode}\\\\]`);\n        const match = src.match(tokenPattern);\n        if (!match) {\n          return void 0;\n        }\n        let content = \"\";\n        let attrString = \"\";\n        if (selfClosing) {\n          const [, attrs] = match;\n          attrString = attrs;\n        } else {\n          const [, attrs, contentMatch] = match;\n          attrString = attrs;\n          content = contentMatch || \"\";\n        }\n        const attributes = parseAttributes2(attrString.trim());\n        return {\n          type: nodeName,\n          raw: match[0],\n          content: content.trim(),\n          attributes\n        };\n      }\n    },\n    renderMarkdown: (node) => {\n      let content = \"\";\n      if (getContent) {\n        content = getContent(node);\n      } else if (node.content && node.content.length > 0) {\n        content = node.content.filter((child) => child.type === \"text\").map((child) => child.text).join(\"\");\n      }\n      const filteredAttrs = filterAttributes(node.attrs || {});\n      const attrs = serializeAttributes2(filteredAttrs);\n      const attrString = attrs ? ` ${attrs}` : \"\";\n      if (selfClosing) {\n        return `[${shortcode}${attrString}]`;\n      }\n      return `[${shortcode}${attrString}]${content}[/${shortcode}]`;\n    }\n  };\n}\n\n// src/utilities/markdown/parseIndentedBlocks.ts\nfunction parseIndentedBlocks(src, config, lexer) {\n  var _a, _b, _c, _d;\n  const lines = src.split(\"\\n\");\n  const items = [];\n  let totalRaw = \"\";\n  let i = 0;\n  const baseIndentSize = config.baseIndentSize || 2;\n  while (i < lines.length) {\n    const currentLine = lines[i];\n    const itemMatch = currentLine.match(config.itemPattern);\n    if (!itemMatch) {\n      if (items.length > 0) {\n        break;\n      } else if (currentLine.trim() === \"\") {\n        i += 1;\n        continue;\n      } else {\n        return void 0;\n      }\n    }\n    const itemData = config.extractItemData(itemMatch);\n    const { indentLevel, mainContent } = itemData;\n    totalRaw = `${totalRaw}${currentLine}\n`;\n    const itemContent = [mainContent];\n    i += 1;\n    while (i < lines.length) {\n      const nextLine = lines[i];\n      if (nextLine.trim() === \"\") {\n        const nextNonEmptyIndex = lines.slice(i + 1).findIndex((l) => l.trim() !== \"\");\n        if (nextNonEmptyIndex === -1) {\n          break;\n        }\n        const nextNonEmpty = lines[i + 1 + nextNonEmptyIndex];\n        const nextIndent2 = ((_b = (_a = nextNonEmpty.match(/^(\\s*)/)) == null ? void 0 : _a[1]) == null ? void 0 : _b.length) || 0;\n        if (nextIndent2 > indentLevel) {\n          itemContent.push(nextLine);\n          totalRaw = `${totalRaw}${nextLine}\n`;\n          i += 1;\n          continue;\n        } else {\n          break;\n        }\n      }\n      const nextIndent = ((_d = (_c = nextLine.match(/^(\\s*)/)) == null ? void 0 : _c[1]) == null ? void 0 : _d.length) || 0;\n      if (nextIndent > indentLevel) {\n        itemContent.push(nextLine);\n        totalRaw = `${totalRaw}${nextLine}\n`;\n        i += 1;\n      } else {\n        break;\n      }\n    }\n    let nestedTokens;\n    const nestedContent = itemContent.slice(1);\n    if (nestedContent.length > 0) {\n      const dedentedNested = nestedContent.map((nestedLine) => nestedLine.slice(indentLevel + baseIndentSize)).join(\"\\n\");\n      if (dedentedNested.trim()) {\n        if (config.customNestedParser) {\n          nestedTokens = config.customNestedParser(dedentedNested);\n        } else {\n          nestedTokens = lexer.blockTokens(dedentedNested);\n        }\n      }\n    }\n    const token = config.createToken(itemData, nestedTokens);\n    items.push(token);\n  }\n  if (items.length === 0) {\n    return void 0;\n  }\n  return {\n    items,\n    raw: totalRaw.trim()\n  };\n}\n\n// src/utilities/markdown/renderNestedMarkdownContent.ts\nfunction renderNestedMarkdownContent(node, h2, prefixOrGenerator, ctx) {\n  if (!node || !Array.isArray(node.content)) {\n    return \"\";\n  }\n  const prefix = typeof prefixOrGenerator === \"function\" ? prefixOrGenerator(ctx) : prefixOrGenerator;\n  const [content, ...children] = node.content;\n  const mainContent = h2.renderChildren([content]);\n  const output = [`${prefix}${mainContent}`];\n  if (children && children.length > 0) {\n    children.forEach((child) => {\n      const childContent = h2.renderChildren([child]);\n      if (childContent) {\n        const indentedChild = childContent.split(\"\\n\").map((line) => line ? h2.indent(line) : \"\").join(\"\\n\");\n        output.push(indentedChild);\n      }\n    });\n  }\n  return output.join(\"\\n\");\n}\n\n// src/MarkView.ts\nfunction updateMarkViewAttributes(checkMark, editor, attrs = {}) {\n  const { state } = editor;\n  const { doc, tr } = state;\n  const thisMark = checkMark;\n  doc.descendants((node, pos) => {\n    const from = tr.mapping.map(pos);\n    const to = tr.mapping.map(pos) + node.nodeSize;\n    let foundMark = null;\n    node.marks.forEach((mark) => {\n      if (mark !== thisMark) {\n        return false;\n      }\n      foundMark = mark;\n    });\n    if (!foundMark) {\n      return;\n    }\n    let needsUpdate = false;\n    Object.keys(attrs).forEach((k) => {\n      if (attrs[k] !== foundMark.attrs[k]) {\n        needsUpdate = true;\n      }\n    });\n    if (needsUpdate) {\n      const updatedMark = checkMark.type.create({\n        ...checkMark.attrs,\n        ...attrs\n      });\n      tr.removeMark(from, to, checkMark.type);\n      tr.addMark(from, to, updatedMark);\n    }\n  });\n  if (tr.docChanged) {\n    editor.view.dispatch(tr);\n  }\n}\nvar MarkView = class {\n  constructor(component, props, options) {\n    this.component = component;\n    this.editor = props.editor;\n    this.options = { ...options };\n    this.mark = props.mark;\n    this.HTMLAttributes = props.HTMLAttributes;\n  }\n  get dom() {\n    return this.editor.view.dom;\n  }\n  get contentDOM() {\n    return null;\n  }\n  /**\n   * Update the attributes of the mark in the document.\n   * @param attrs The attributes to update.\n   */\n  updateAttributes(attrs, checkMark) {\n    updateMarkViewAttributes(checkMark || this.mark, this.editor, attrs);\n  }\n  ignoreMutation(mutation) {\n    if (!this.dom || !this.contentDOM) {\n      return true;\n    }\n    if (typeof this.options.ignoreMutation === \"function\") {\n      return this.options.ignoreMutation({ mutation });\n    }\n    if (mutation.type === \"selection\") {\n      return false;\n    }\n    if (this.dom.contains(mutation.target) && mutation.type === \"childList\" && (isiOS() || isAndroid()) && this.editor.isFocused) {\n      const changedNodes = [...Array.from(mutation.addedNodes), ...Array.from(mutation.removedNodes)];\n      if (changedNodes.every((node) => node.isContentEditable)) {\n        return false;\n      }\n    }\n    if (this.contentDOM === mutation.target && mutation.type === \"attributes\") {\n      return true;\n    }\n    if (this.contentDOM.contains(mutation.target)) {\n      return false;\n    }\n    return true;\n  }\n};\n\n// src/Node.ts\nvar Node3 = class _Node extends Extendable {\n  constructor() {\n    super(...arguments);\n    this.type = \"node\";\n  }\n  /**\n   * Create a new Node instance\n   * @param config - Node configuration object or a function that returns a configuration object\n   */\n  static create(config = {}) {\n    const resolvedConfig = typeof config === \"function\" ? config() : config;\n    return new _Node(resolvedConfig);\n  }\n  configure(options) {\n    return super.configure(options);\n  }\n  extend(extendedConfig) {\n    const resolvedConfig = typeof extendedConfig === \"function\" ? extendedConfig() : extendedConfig;\n    return super.extend(resolvedConfig);\n  }\n};\n\n// src/NodeView.ts\n\nvar NodeView = class {\n  constructor(component, props, options) {\n    this.isDragging = false;\n    this.component = component;\n    this.editor = props.editor;\n    this.options = {\n      stopEvent: null,\n      ignoreMutation: null,\n      ...options\n    };\n    this.extension = props.extension;\n    this.node = props.node;\n    this.decorations = props.decorations;\n    this.innerDecorations = props.innerDecorations;\n    this.view = props.view;\n    this.HTMLAttributes = props.HTMLAttributes;\n    this.getPos = props.getPos;\n    this.mount();\n  }\n  mount() {\n    return;\n  }\n  get dom() {\n    return this.editor.view.dom;\n  }\n  get contentDOM() {\n    return null;\n  }\n  onDragStart(event) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const { view } = this.editor;\n    const target = event.target;\n    const dragHandle = target.nodeType === 3 ? (_a = target.parentElement) == null ? void 0 : _a.closest(\"[data-drag-handle]\") : target.closest(\"[data-drag-handle]\");\n    if (!this.dom || ((_b = this.contentDOM) == null ? void 0 : _b.contains(target)) || !dragHandle) {\n      return;\n    }\n    let x = 0;\n    let y = 0;\n    if (this.dom !== dragHandle) {\n      const domBox = this.dom.getBoundingClientRect();\n      const handleBox = dragHandle.getBoundingClientRect();\n      const offsetX = (_d = event.offsetX) != null ? _d : (_c = event.nativeEvent) == null ? void 0 : _c.offsetX;\n      const offsetY = (_f = event.offsetY) != null ? _f : (_e = event.nativeEvent) == null ? void 0 : _e.offsetY;\n      x = handleBox.x - domBox.x + offsetX;\n      y = handleBox.y - domBox.y + offsetY;\n    }\n    const clonedNode = this.dom.cloneNode(true);\n    try {\n      const domBox = this.dom.getBoundingClientRect();\n      clonedNode.style.width = `${Math.round(domBox.width)}px`;\n      clonedNode.style.height = `${Math.round(domBox.height)}px`;\n      clonedNode.style.boxSizing = \"border-box\";\n      clonedNode.style.pointerEvents = \"none\";\n    } catch {\n    }\n    let dragImageWrapper = null;\n    try {\n      dragImageWrapper = document.createElement(\"div\");\n      dragImageWrapper.style.position = \"absolute\";\n      dragImageWrapper.style.top = \"-9999px\";\n      dragImageWrapper.style.left = \"-9999px\";\n      dragImageWrapper.style.pointerEvents = \"none\";\n      dragImageWrapper.appendChild(clonedNode);\n      document.body.appendChild(dragImageWrapper);\n      (_g = event.dataTransfer) == null ? void 0 : _g.setDragImage(clonedNode, x, y);\n    } finally {\n      if (dragImageWrapper) {\n        setTimeout(() => {\n          try {\n            dragImageWrapper == null ? void 0 : dragImageWrapper.remove();\n          } catch {\n          }\n        }, 0);\n      }\n    }\n    const pos = this.getPos();\n    if (typeof pos !== \"number\") {\n      return;\n    }\n    const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.create(view.state.doc, pos);\n    const transaction = view.state.tr.setSelection(selection);\n    view.dispatch(transaction);\n  }\n  stopEvent(event) {\n    var _a;\n    if (!this.dom) {\n      return false;\n    }\n    if (typeof this.options.stopEvent === \"function\") {\n      return this.options.stopEvent({ event });\n    }\n    const target = event.target;\n    const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) == null ? void 0 : _a.contains(target));\n    if (!isInElement) {\n      return false;\n    }\n    const isDragEvent = event.type.startsWith(\"drag\");\n    const isDropEvent = event.type === \"drop\";\n    const isInput = [\"INPUT\", \"BUTTON\", \"SELECT\", \"TEXTAREA\"].includes(target.tagName) || target.isContentEditable;\n    if (isInput && !isDropEvent && !isDragEvent) {\n      return true;\n    }\n    const { isEditable } = this.editor;\n    const { isDragging } = this;\n    const isDraggable = !!this.node.type.spec.draggable;\n    const isSelectable = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.isSelectable(this.node);\n    const isCopyEvent = event.type === \"copy\";\n    const isPasteEvent = event.type === \"paste\";\n    const isCutEvent = event.type === \"cut\";\n    const isClickEvent = event.type === \"mousedown\";\n    if (!isDraggable && isSelectable && isDragEvent && event.target === this.dom) {\n      event.preventDefault();\n    }\n    if (isDraggable && isDragEvent && !isDragging && event.target === this.dom) {\n      event.preventDefault();\n      return false;\n    }\n    if (isDraggable && isEditable && !isDragging && isClickEvent) {\n      const dragHandle = target.closest(\"[data-drag-handle]\");\n      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));\n      if (isValidDragHandle) {\n        this.isDragging = true;\n        document.addEventListener(\n          \"dragend\",\n          () => {\n            this.isDragging = false;\n          },\n          { once: true }\n        );\n        document.addEventListener(\n          \"drop\",\n          () => {\n            this.isDragging = false;\n          },\n          { once: true }\n        );\n        document.addEventListener(\n          \"mouseup\",\n          () => {\n            this.isDragging = false;\n          },\n          { once: true }\n        );\n      }\n    }\n    if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.\n   * @return `false` if the editor should re-read the selection or re-parse the range around the mutation\n   * @return `true` if it can safely be ignored.\n   */\n  ignoreMutation(mutation) {\n    if (!this.dom || !this.contentDOM) {\n      return true;\n    }\n    if (typeof this.options.ignoreMutation === \"function\") {\n      return this.options.ignoreMutation({ mutation });\n    }\n    if (this.node.isLeaf || this.node.isAtom) {\n      return true;\n    }\n    if (mutation.type === \"selection\") {\n      return false;\n    }\n    if (this.dom.contains(mutation.target) && mutation.type === \"childList\" && (isiOS() || isAndroid()) && this.editor.isFocused) {\n      const changedNodes = [...Array.from(mutation.addedNodes), ...Array.from(mutation.removedNodes)];\n      if (changedNodes.every((node) => node.isContentEditable)) {\n        return false;\n      }\n    }\n    if (this.contentDOM === mutation.target && mutation.type === \"attributes\") {\n      return true;\n    }\n    if (this.contentDOM.contains(mutation.target)) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Update the attributes of the prosemirror node.\n   */\n  updateAttributes(attributes) {\n    this.editor.commands.command(({ tr }) => {\n      const pos = this.getPos();\n      if (typeof pos !== \"number\") {\n        return false;\n      }\n      tr.setNodeMarkup(pos, void 0, {\n        ...this.node.attrs,\n        ...attributes\n      });\n      return true;\n    });\n  }\n  /**\n   * Delete the node.\n   */\n  deleteNode() {\n    const from = this.getPos();\n    if (typeof from !== \"number\") {\n      return;\n    }\n    const to = from + this.node.nodeSize;\n    this.editor.commands.deleteRange({ from, to });\n  }\n};\n\n// src/pasteRules/markPasteRule.ts\nfunction markPasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({ state, range, match, pasteEvent }) => {\n      const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      const { tr } = state;\n      const captureGroup = match[match.length - 1];\n      const fullMatch = match[0];\n      let markEnd = range.to;\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/);\n        const textStart = range.from + fullMatch.indexOf(captureGroup);\n        const textEnd = textStart + captureGroup.length;\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {\n          const excluded = item.mark.type.excluded;\n          return excluded.find((type) => type === config.type && type !== item.mark.type);\n        }).filter((item) => item.to > textStart);\n        if (excludedMarks.length) {\n          return null;\n        }\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to);\n        }\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart);\n        }\n        markEnd = range.from + startSpaces + captureGroup.length;\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n        tr.removeStoredMark(config.type);\n      }\n    }\n  });\n}\n\n// src/pasteRules/nodePasteRule.ts\nfunction nodePasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler({ match, chain, range, pasteEvent }) {\n      const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);\n      const content = callOrReturn(config.getContent, void 0, attributes);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      const node = { type: config.type.name, attrs: attributes };\n      if (content) {\n        node.content = content;\n      }\n      if (match.input) {\n        chain().deleteRange(range).insertContentAt(range.from, node);\n      }\n    }\n  });\n}\n\n// src/pasteRules/textPasteRule.ts\nfunction textPasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      let insert = config.replace;\n      let start = range.from;\n      const end = range.to;\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        insert += match[0].slice(offset + match[1].length);\n        start += offset;\n        const cutOff = start - end;\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert;\n          start = end;\n        }\n      }\n      state.tr.insertText(insert, start, end);\n    }\n  });\n}\n\n// src/Tracker.ts\nvar Tracker = class {\n  constructor(transaction) {\n    this.transaction = transaction;\n    this.currentStep = this.transaction.steps.length;\n  }\n  map(position) {\n    let deleted = false;\n    const mappedPosition = this.transaction.steps.slice(this.currentStep).reduce((newPosition, step) => {\n      const mapResult = step.getMap().mapResult(newPosition);\n      if (mapResult.deleted) {\n        deleted = true;\n      }\n      return mapResult.pos;\n    }, position);\n    return {\n      position: mappedPosition,\n      deleted\n    };\n  }\n};\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQSxVQUFVLHFCQUFxQjtBQUMvQixRQUFRLFlBQVk7QUFDcEIsUUFBUSxNQUFNO0FBQ2QsUUFBUSxjQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QyxZQUFZLE9BQU87QUFDbkIsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekMsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUN3Qzs7QUFFeEM7QUFDaUQ7QUFDakQ7QUFDQSwyQkFBMkIsMkRBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNxRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUNBQWlDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixnREFBZ0Q7QUFDaEQscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwyRkFBMkYsU0FBUyxJQUFJLElBQUksV0FBVztBQUN2SCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUcsSUFBSTtBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsOEVBQThFO0FBQ2pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSTtBQUNYLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlDQUFpQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhLG9EQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxrQ0FBa0MsS0FBSyxlQUFlO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtEQUFJO0FBQzFCO0FBQ0E7O0FBRUE7QUFDMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsU0FBUyx1REFBVTtBQUNuQjs7QUFFQTtBQUNpRDs7QUFFakQ7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQixVQUFVLGdEQUFnRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsZ0RBQWdEO0FBQzFEO0FBQ0Esc0JBQXNCLGtEQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUIsTUFBTTtBQUNOO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEMsT0FBTztBQUNQO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNILGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RDtBQUN4RCxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMERBQTBELGVBQWU7QUFDOUU7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRywyRUFBMkUsZUFBZTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsc0JBQXNCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUNBQWlDO0FBQ3JFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDaUQ7QUFDakQ7QUFDQSwwQkFBMEIsMkRBQWE7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkIsd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBLDBDQUEwQyxRQUFRLHFCQUFxQjtBQUN2RSxVQUFVLFlBQVk7QUFDdEIsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxJQUFJO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNtRDtBQUNuRCwwQ0FBMEMsUUFBUSx3QkFBd0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEMsd0JBQXdCLGlFQUFZLFNBQVMsb0NBQW9DO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxhQUFhLHFCQUFxQjtBQUNyQyxXQUFXLGlFQUFZLFNBQVMsb0NBQW9DO0FBQ3BFLEdBQUc7QUFDSDs7QUFFQTtBQUNtRTtBQUNuRSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBLHNCQUFzQiwyREFBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNtRTtBQUNuRSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLFdBQVcsbUNBQW1DLCtCQUErQjtBQUN6RixtQkFBbUIsMkRBQWM7QUFDakMsbUJBQW1CLDJEQUFjO0FBQ2pDO0FBQ0E7QUFDQSxzQkFBc0IsMkRBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDOEU7QUFDOUUsc0NBQXNDLGlCQUFpQjtBQUN2RDtBQUNBLFNBQVMsb0VBQW9CO0FBQzdCOztBQUVBO0FBQ29HO0FBQ3BEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQixJQUFJLFFBQVEsNkJBQTZCO0FBQ2hGLFVBQVUsaUJBQWlCO0FBQzNCLFVBQVUsYUFBYTtBQUN2QjtBQUNBO0FBQ0EsMkJBQTJCLDJEQUFjO0FBQ3pDLGdDQUFnQyw4REFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhEQUFRO0FBQ3BCLHdCQUF3Qiw4REFBUSxrREFBa0QsYUFBYTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwyREFBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDZ0U7QUFDRztBQUNOO0FBQzdELG1EQUFtRCxRQUFRLDZCQUE2QjtBQUN4RjtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0RBQVM7QUFDMUI7QUFDQSw4Q0FBOEMsc0JBQXNCO0FBQ3BFLGVBQWUsc0RBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0RBQVM7QUFDbEM7QUFDQSxzREFBc0QsbURBQUs7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHdCQUF3QiwyREFBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZ0NBQWdDO0FBQ3RDLE1BQU07QUFDTixTQUFTLGdDQUFnQztBQUN6QyxPQUFPLDhEQUFTO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQytDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLDZEQUFPO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLDZEQUFPO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxRQUFRLG1EQUFtRDtBQUN2SSxVQUFVLDhCQUE4QjtBQUN4QztBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkMsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLDZDQUE2QyxjQUFjLFFBQVEsaUJBQWlCO0FBQ3BGLFVBQVUsK0JBQStCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0RBQStELFFBQVEsaUJBQWlCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9DQUFvQztBQUN0RTs7QUFFQTtBQUNBLDZDQUE2QyxRQUFRLGlCQUFpQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDLFVBQVUsWUFBWTtBQUN0QixVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLFFBQVEscUJBQXFCO0FBQ3RFO0FBQ0EsVUFBVSwrQkFBK0I7QUFDekMsVUFBVSxZQUFZO0FBQ3RCO0FBQ0EsVUFBVSx1QkFBdUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCxRQUFRLHFCQUFxQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDK0Q7QUFDL0QseUNBQXlDLFFBQVEsaUJBQWlCO0FBQ2xFO0FBQ0EsU0FBUywyREFBYztBQUN2Qjs7QUFFQTtBQUMwRTtBQUMxRSw2Q0FBNkMsUUFBUSxpQkFBaUI7QUFDdEU7QUFDQSxTQUFTLGtFQUFrQjtBQUMzQjs7QUFFQTtBQUMrQztBQUNGOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDMkM7O0FBRTNDO0FBQ3lEO0FBQ2Y7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3Q0FBd0M7QUFDbEQsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCO0FBQzFCLHFCQUFxQixvREFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBLGNBQWM7QUFDZCx5Q0FBeUMsc0RBQVM7QUFDbEQ7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDZDQUE2QyxtQ0FBbUM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3lEO0FBQ0o7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsVUFBVSx1REFBdUQ7QUFDakUsVUFBVSx1QkFBdUI7QUFDakM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9EQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Qsd0NBQXdDO0FBQ3ZHO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBLFlBQVk7QUFDWix1Q0FBdUMsc0RBQVM7QUFDaEQ7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx5QkFBeUI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRCxXQUFXO0FBQ1g7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSwyQkFBMkIseURBQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGVBQWU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ2dFOztBQUVoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxVQUFVLG9EQUFPO0FBQ2pCLGlCQUFpQix1REFBUztBQUMxQjtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0Isb0JBQW9CLGdCQUFnQjtBQUNwQyxvQkFBb0IsaUJBQWlCO0FBQ3JDLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDREQUE0RCw4Q0FBOEMsSUFBSTtBQUM5RztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ3NEO0FBQ3REO0FBQ0E7QUFDQSxhQUFhLG1DQUFtQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0VBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9EQUFPO0FBQ2pCLGlCQUFpQix1REFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQzhFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvREFBTztBQUNqQixpQkFBaUIsdURBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQzhFO0FBQzlFLCtCQUErQix1REFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQSxVQUFVLG9EQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsT0FBTztBQUM1RTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxvRUFBb0UsT0FBTztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ3VHO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxVQUFVO0FBQzFFO0FBQ0E7QUFDQSxnQ0FBZ0MsSUFBSTtBQUNwQyxnQkFBZ0IsaUJBQWlCO0FBQ2pDLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsZ0hBQWdILHVEQUFVO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFVBQVU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxVQUFVO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0RBQU87QUFDakIsaUJBQWlCLHVEQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEMsMEJBQTBCLHVEQUFVO0FBQ3BDLHlCQUF5Qix1REFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9EQUFPO0FBQ2pCLGlCQUFpQix1REFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUM4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0RBQU87QUFDakIsaUJBQWlCLHVEQUFVO0FBQzNCO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixXQUFXLEtBQUssU0FBUztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIseUJBQXlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSwwRUFBMEUsYUFBYSxPQUFPLE9BQU87QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsYUFBYSxPQUFPLE9BQU87QUFDeEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5REFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixjQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBLDRCQUE0QixvRUFBb0U7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLElBQUk7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGdCQUFnQjtBQUM1RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdURBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msd0JBQXdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTLEVBQUU7QUFDakM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPLEVBQUUsWUFBWTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0Q7QUFDL0QsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWtIRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvbW9ydG9ubWFidW1iby9Eb3dubG9hZHMvdGVzdGltaW5vbnktd2ViMV8xMC1tYWluL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuXG4vLyBzcmMvaGVscGVycy9jcmVhdGVDaGFpbmFibGVTdGF0ZS50c1xuZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoY29uZmlnKSB7XG4gIGNvbnN0IHsgc3RhdGUsIHRyYW5zYWN0aW9uIH0gPSBjb25maWc7XG4gIGxldCB7IHNlbGVjdGlvbiB9ID0gdHJhbnNhY3Rpb247XG4gIGxldCB7IGRvYyB9ID0gdHJhbnNhY3Rpb247XG4gIGxldCB7IHN0b3JlZE1hcmtzIH0gPSB0cmFuc2FjdGlvbjtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBhcHBseTogc3RhdGUuYXBwbHkuYmluZChzdGF0ZSksXG4gICAgYXBwbHlUcmFuc2FjdGlvbjogc3RhdGUuYXBwbHlUcmFuc2FjdGlvbi5iaW5kKHN0YXRlKSxcbiAgICBwbHVnaW5zOiBzdGF0ZS5wbHVnaW5zLFxuICAgIHNjaGVtYTogc3RhdGUuc2NoZW1hLFxuICAgIHJlY29uZmlndXJlOiBzdGF0ZS5yZWNvbmZpZ3VyZS5iaW5kKHN0YXRlKSxcbiAgICB0b0pTT046IHN0YXRlLnRvSlNPTi5iaW5kKHN0YXRlKSxcbiAgICBnZXQgc3RvcmVkTWFya3MoKSB7XG4gICAgICByZXR1cm4gc3RvcmVkTWFya3M7XG4gICAgfSxcbiAgICBnZXQgc2VsZWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgICB9LFxuICAgIGdldCBkb2MoKSB7XG4gICAgICByZXR1cm4gZG9jO1xuICAgIH0sXG4gICAgZ2V0IHRyKCkge1xuICAgICAgc2VsZWN0aW9uID0gdHJhbnNhY3Rpb24uc2VsZWN0aW9uO1xuICAgICAgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICAgICAgc3RvcmVkTWFya3MgPSB0cmFuc2FjdGlvbi5zdG9yZWRNYXJrcztcbiAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9Db21tYW5kTWFuYWdlci50c1xudmFyIENvbW1hbmRNYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHRoaXMuZWRpdG9yID0gcHJvcHMuZWRpdG9yO1xuICAgIHRoaXMucmF3Q29tbWFuZHMgPSB0aGlzLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmNvbW1hbmRzO1xuICAgIHRoaXMuY3VzdG9tU3RhdGUgPSBwcm9wcy5zdGF0ZTtcbiAgfVxuICBnZXQgaGFzQ3VzdG9tU3RhdGUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5jdXN0b21TdGF0ZTtcbiAgfVxuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VzdG9tU3RhdGUgfHwgdGhpcy5lZGl0b3Iuc3RhdGU7XG4gIH1cbiAgZ2V0IGNvbW1hbmRzKCkge1xuICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIGVkaXRvciwgc3RhdGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB2aWV3IH0gPSBlZGl0b3I7XG4gICAgY29uc3QgeyB0ciB9ID0gc3RhdGU7XG4gICAgY29uc3QgcHJvcHMgPSB0aGlzLmJ1aWxkUHJvcHModHIpO1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZDJdKSA9PiB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBjb21tYW5kMiguLi5hcmdzKShwcm9wcyk7XG4gICAgICAgICAgaWYgKCF0ci5nZXRNZXRhKFwicHJldmVudERpc3BhdGNoXCIpICYmICF0aGlzLmhhc0N1c3RvbVN0YXRlKSB7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gW25hbWUsIG1ldGhvZF07XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgZ2V0IGNoYWluKCkge1xuICAgIHJldHVybiAoKSA9PiB0aGlzLmNyZWF0ZUNoYWluKCk7XG4gIH1cbiAgZ2V0IGNhbigpIHtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5jcmVhdGVDYW4oKTtcbiAgfVxuICBjcmVhdGVDaGFpbihzdGFydFRyLCBzaG91bGREaXNwYXRjaCA9IHRydWUpIHtcbiAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBlZGl0b3IsIHN0YXRlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yO1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IFtdO1xuICAgIGNvbnN0IGhhc1N0YXJ0VHJhbnNhY3Rpb24gPSAhIXN0YXJ0VHI7XG4gICAgY29uc3QgdHIgPSBzdGFydFRyIHx8IHN0YXRlLnRyO1xuICAgIGNvbnN0IHJ1bjMgPSAoKSA9PiB7XG4gICAgICBpZiAoIWhhc1N0YXJ0VHJhbnNhY3Rpb24gJiYgc2hvdWxkRGlzcGF0Y2ggJiYgIXRyLmdldE1ldGEoXCJwcmV2ZW50RGlzcGF0Y2hcIikgJiYgIXRoaXMuaGFzQ3VzdG9tU3RhdGUpIHtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FsbGJhY2tzLmV2ZXJ5KChjYWxsYmFjaykgPT4gY2FsbGJhY2sgPT09IHRydWUpO1xuICAgIH07XG4gICAgY29uc3QgY2hhaW4gPSB7XG4gICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHJhd0NvbW1hbmRzKS5tYXAoKFtuYW1lLCBjb21tYW5kMl0pID0+IHtcbiAgICAgICAgICBjb25zdCBjaGFpbmVkQ29tbWFuZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuYnVpbGRQcm9wcyh0ciwgc2hvdWxkRGlzcGF0Y2gpO1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBjb21tYW5kMiguLi5hcmdzKShwcm9wcyk7XG4gICAgICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gY2hhaW47XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gW25hbWUsIGNoYWluZWRDb21tYW5kXTtcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICBydW46IHJ1bjNcbiAgICB9O1xuICAgIHJldHVybiBjaGFpbjtcbiAgfVxuICBjcmVhdGVDYW4oc3RhcnRUcikge1xuICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIHN0YXRlIH0gPSB0aGlzO1xuICAgIGNvbnN0IGRpc3BhdGNoID0gZmFsc2U7XG4gICAgY29uc3QgdHIgPSBzdGFydFRyIHx8IHN0YXRlLnRyO1xuICAgIGNvbnN0IHByb3BzID0gdGhpcy5idWlsZFByb3BzKHRyLCBkaXNwYXRjaCk7XG4gICAgY29uc3QgZm9ybWF0dGVkQ29tbWFuZHMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZDJdKSA9PiB7XG4gICAgICAgIHJldHVybiBbbmFtZSwgKC4uLmFyZ3MpID0+IGNvbW1hbmQyKC4uLmFyZ3MpKHsgLi4ucHJvcHMsIGRpc3BhdGNoOiB2b2lkIDAgfSldO1xuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5mb3JtYXR0ZWRDb21tYW5kcyxcbiAgICAgIGNoYWluOiAoKSA9PiB0aGlzLmNyZWF0ZUNoYWluKHRyLCBkaXNwYXRjaClcbiAgICB9O1xuICB9XG4gIGJ1aWxkUHJvcHModHIsIHNob3VsZERpc3BhdGNoID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIGVkaXRvciwgc3RhdGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB2aWV3IH0gPSBlZGl0b3I7XG4gICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICB0cixcbiAgICAgIGVkaXRvcixcbiAgICAgIHZpZXcsXG4gICAgICBzdGF0ZTogY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgdHJhbnNhY3Rpb246IHRyXG4gICAgICB9KSxcbiAgICAgIGRpc3BhdGNoOiBzaG91bGREaXNwYXRjaCA/ICgpID0+IHZvaWQgMCA6IHZvaWQgMCxcbiAgICAgIGNoYWluOiAoKSA9PiB0aGlzLmNyZWF0ZUNoYWluKHRyLCBzaG91bGREaXNwYXRjaCksXG4gICAgICBjYW46ICgpID0+IHRoaXMuY3JlYXRlQ2FuKHRyKSxcbiAgICAgIGdldCBjb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZDJdKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW25hbWUsICguLi5hcmdzKSA9PiBjb21tYW5kMiguLi5hcmdzKShwcm9wcyldO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcHJvcHM7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tYW5kcy9pbmRleC50c1xudmFyIGNvbW1hbmRzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNvbW1hbmRzX2V4cG9ydHMsIHtcbiAgYmx1cjogKCkgPT4gYmx1cixcbiAgY2xlYXJDb250ZW50OiAoKSA9PiBjbGVhckNvbnRlbnQsXG4gIGNsZWFyTm9kZXM6ICgpID0+IGNsZWFyTm9kZXMsXG4gIGNvbW1hbmQ6ICgpID0+IGNvbW1hbmQsXG4gIGNyZWF0ZVBhcmFncmFwaE5lYXI6ICgpID0+IGNyZWF0ZVBhcmFncmFwaE5lYXIsXG4gIGN1dDogKCkgPT4gY3V0LFxuICBkZWxldGVDdXJyZW50Tm9kZTogKCkgPT4gZGVsZXRlQ3VycmVudE5vZGUsXG4gIGRlbGV0ZU5vZGU6ICgpID0+IGRlbGV0ZU5vZGUsXG4gIGRlbGV0ZVJhbmdlOiAoKSA9PiBkZWxldGVSYW5nZSxcbiAgZGVsZXRlU2VsZWN0aW9uOiAoKSA9PiBkZWxldGVTZWxlY3Rpb24sXG4gIGVudGVyOiAoKSA9PiBlbnRlcixcbiAgZXhpdENvZGU6ICgpID0+IGV4aXRDb2RlLFxuICBleHRlbmRNYXJrUmFuZ2U6ICgpID0+IGV4dGVuZE1hcmtSYW5nZSxcbiAgZmlyc3Q6ICgpID0+IGZpcnN0LFxuICBmb2N1czogKCkgPT4gZm9jdXMsXG4gIGZvckVhY2g6ICgpID0+IGZvckVhY2gsXG4gIGluc2VydENvbnRlbnQ6ICgpID0+IGluc2VydENvbnRlbnQsXG4gIGluc2VydENvbnRlbnRBdDogKCkgPT4gaW5zZXJ0Q29udGVudEF0LFxuICBqb2luQmFja3dhcmQ6ICgpID0+IGpvaW5CYWNrd2FyZCxcbiAgam9pbkRvd246ICgpID0+IGpvaW5Eb3duLFxuICBqb2luRm9yd2FyZDogKCkgPT4gam9pbkZvcndhcmQsXG4gIGpvaW5JdGVtQmFja3dhcmQ6ICgpID0+IGpvaW5JdGVtQmFja3dhcmQsXG4gIGpvaW5JdGVtRm9yd2FyZDogKCkgPT4gam9pbkl0ZW1Gb3J3YXJkLFxuICBqb2luVGV4dGJsb2NrQmFja3dhcmQ6ICgpID0+IGpvaW5UZXh0YmxvY2tCYWNrd2FyZCxcbiAgam9pblRleHRibG9ja0ZvcndhcmQ6ICgpID0+IGpvaW5UZXh0YmxvY2tGb3J3YXJkLFxuICBqb2luVXA6ICgpID0+IGpvaW5VcCxcbiAga2V5Ym9hcmRTaG9ydGN1dDogKCkgPT4ga2V5Ym9hcmRTaG9ydGN1dCxcbiAgbGlmdDogKCkgPT4gbGlmdCxcbiAgbGlmdEVtcHR5QmxvY2s6ICgpID0+IGxpZnRFbXB0eUJsb2NrLFxuICBsaWZ0TGlzdEl0ZW06ICgpID0+IGxpZnRMaXN0SXRlbSxcbiAgbmV3bGluZUluQ29kZTogKCkgPT4gbmV3bGluZUluQ29kZSxcbiAgcmVzZXRBdHRyaWJ1dGVzOiAoKSA9PiByZXNldEF0dHJpYnV0ZXMsXG4gIHNjcm9sbEludG9WaWV3OiAoKSA9PiBzY3JvbGxJbnRvVmlldyxcbiAgc2VsZWN0QWxsOiAoKSA9PiBzZWxlY3RBbGwsXG4gIHNlbGVjdE5vZGVCYWNrd2FyZDogKCkgPT4gc2VsZWN0Tm9kZUJhY2t3YXJkLFxuICBzZWxlY3ROb2RlRm9yd2FyZDogKCkgPT4gc2VsZWN0Tm9kZUZvcndhcmQsXG4gIHNlbGVjdFBhcmVudE5vZGU6ICgpID0+IHNlbGVjdFBhcmVudE5vZGUsXG4gIHNlbGVjdFRleHRibG9ja0VuZDogKCkgPT4gc2VsZWN0VGV4dGJsb2NrRW5kLFxuICBzZWxlY3RUZXh0YmxvY2tTdGFydDogKCkgPT4gc2VsZWN0VGV4dGJsb2NrU3RhcnQsXG4gIHNldENvbnRlbnQ6ICgpID0+IHNldENvbnRlbnQsXG4gIHNldE1hcms6ICgpID0+IHNldE1hcmssXG4gIHNldE1ldGE6ICgpID0+IHNldE1ldGEsXG4gIHNldE5vZGU6ICgpID0+IHNldE5vZGUsXG4gIHNldE5vZGVTZWxlY3Rpb246ICgpID0+IHNldE5vZGVTZWxlY3Rpb24sXG4gIHNldFRleHRTZWxlY3Rpb246ICgpID0+IHNldFRleHRTZWxlY3Rpb24sXG4gIHNpbmtMaXN0SXRlbTogKCkgPT4gc2lua0xpc3RJdGVtLFxuICBzcGxpdEJsb2NrOiAoKSA9PiBzcGxpdEJsb2NrLFxuICBzcGxpdExpc3RJdGVtOiAoKSA9PiBzcGxpdExpc3RJdGVtLFxuICB0b2dnbGVMaXN0OiAoKSA9PiB0b2dnbGVMaXN0LFxuICB0b2dnbGVNYXJrOiAoKSA9PiB0b2dnbGVNYXJrLFxuICB0b2dnbGVOb2RlOiAoKSA9PiB0b2dnbGVOb2RlLFxuICB0b2dnbGVXcmFwOiAoKSA9PiB0b2dnbGVXcmFwLFxuICB1bmRvSW5wdXRSdWxlOiAoKSA9PiB1bmRvSW5wdXRSdWxlLFxuICB1bnNldEFsbE1hcmtzOiAoKSA9PiB1bnNldEFsbE1hcmtzLFxuICB1bnNldE1hcms6ICgpID0+IHVuc2V0TWFyayxcbiAgdXBkYXRlQXR0cmlidXRlczogKCkgPT4gdXBkYXRlQXR0cmlidXRlcyxcbiAgd3JhcEluOiAoKSA9PiB3cmFwSW4sXG4gIHdyYXBJbkxpc3Q6ICgpID0+IHdyYXBJbkxpc3Rcbn0pO1xuXG4vLyBzcmMvY29tbWFuZHMvYmx1ci50c1xudmFyIGJsdXIgPSAoKSA9PiAoeyBlZGl0b3IsIHZpZXcgfSkgPT4ge1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIWVkaXRvci5pc0Rlc3Ryb3llZCkge1xuICAgICAgO1xuICAgICAgdmlldy5kb20uYmx1cigpO1xuICAgICAgKF9hID0gd2luZG93ID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9jbGVhckNvbnRlbnQudHNcbnZhciBjbGVhckNvbnRlbnQgPSAoZW1pdFVwZGF0ZSA9IHRydWUpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgcmV0dXJuIGNvbW1hbmRzLnNldENvbnRlbnQoXCJcIiwgeyBlbWl0VXBkYXRlIH0pO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2NsZWFyTm9kZXMudHNcbmltcG9ydCB7IGxpZnRUYXJnZXQgfSBmcm9tIFwiQHRpcHRhcC9wbS90cmFuc2Zvcm1cIjtcbnZhciBjbGVhck5vZGVzID0gKCkgPT4gKHsgc3RhdGUsIHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cjtcbiAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvbjtcbiAgaWYgKCFkaXNwYXRjaCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJhbmdlcy5mb3JFYWNoKCh7ICRmcm9tLCAkdG8gfSkgPT4ge1xuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICBpZiAobm9kZS50eXBlLmlzVGV4dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IGRvYywgbWFwcGluZyB9ID0gdHI7XG4gICAgICBjb25zdCAkbWFwcGVkRnJvbSA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHBvcykpO1xuICAgICAgY29uc3QgJG1hcHBlZFRvID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAocG9zICsgbm9kZS5ub2RlU2l6ZSkpO1xuICAgICAgY29uc3Qgbm9kZVJhbmdlID0gJG1hcHBlZEZyb20uYmxvY2tSYW5nZSgkbWFwcGVkVG8pO1xuICAgICAgaWYgKCFub2RlUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFyZ2V0TGlmdERlcHRoID0gbGlmdFRhcmdldChub2RlUmFuZ2UpO1xuICAgICAgaWYgKG5vZGUudHlwZS5pc1RleHRibG9jaykge1xuICAgICAgICBjb25zdCB7IGRlZmF1bHRUeXBlIH0gPSAkbWFwcGVkRnJvbS5wYXJlbnQuY29udGVudE1hdGNoQXQoJG1hcHBlZEZyb20uaW5kZXgoKSk7XG4gICAgICAgIHRyLnNldE5vZGVNYXJrdXAobm9kZVJhbmdlLnN0YXJ0LCBkZWZhdWx0VHlwZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0TGlmdERlcHRoIHx8IHRhcmdldExpZnREZXB0aCA9PT0gMCkge1xuICAgICAgICB0ci5saWZ0KG5vZGVSYW5nZSwgdGFyZ2V0TGlmdERlcHRoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2NvbW1hbmQudHNcbnZhciBjb21tYW5kID0gKGZuKSA9PiAocHJvcHMpID0+IHtcbiAgcmV0dXJuIGZuKHByb3BzKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9jcmVhdGVQYXJhZ3JhcGhOZWFyLnRzXG5pbXBvcnQgeyBjcmVhdGVQYXJhZ3JhcGhOZWFyIGFzIG9yaWdpbmFsQ3JlYXRlUGFyYWdyYXBoTmVhciB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgY3JlYXRlUGFyYWdyYXBoTmVhciA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbENyZWF0ZVBhcmFncmFwaE5lYXIoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9jdXQudHNcbmltcG9ydCB7IFRleHRTZWxlY3Rpb24gfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xudmFyIGN1dCA9IChvcmlnaW5SYW5nZSwgdGFyZ2V0UG9zKSA9PiAoeyBlZGl0b3IsIHRyIH0pID0+IHtcbiAgY29uc3QgeyBzdGF0ZSB9ID0gZWRpdG9yO1xuICBjb25zdCBjb250ZW50U2xpY2UgPSBzdGF0ZS5kb2Muc2xpY2Uob3JpZ2luUmFuZ2UuZnJvbSwgb3JpZ2luUmFuZ2UudG8pO1xuICB0ci5kZWxldGVSYW5nZShvcmlnaW5SYW5nZS5mcm9tLCBvcmlnaW5SYW5nZS50byk7XG4gIGNvbnN0IG5ld1BvcyA9IHRyLm1hcHBpbmcubWFwKHRhcmdldFBvcyk7XG4gIHRyLmluc2VydChuZXdQb3MsIGNvbnRlbnRTbGljZS5jb250ZW50KTtcbiAgdHIuc2V0U2VsZWN0aW9uKG5ldyBUZXh0U2VsZWN0aW9uKHRyLmRvYy5yZXNvbHZlKE1hdGgubWF4KG5ld1BvcyAtIDEsIDApKSkpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9kZWxldGVDdXJyZW50Tm9kZS50c1xudmFyIGRlbGV0ZUN1cnJlbnROb2RlID0gKCkgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyO1xuICBjb25zdCBjdXJyZW50Tm9kZSA9IHNlbGVjdGlvbi4kYW5jaG9yLm5vZGUoKTtcbiAgaWYgKGN1cnJlbnROb2RlLmNvbnRlbnQuc2l6ZSA+IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgJHBvcyA9IHRyLnNlbGVjdGlvbi4kYW5jaG9yO1xuICBmb3IgKGxldCBkZXB0aCA9ICRwb3MuZGVwdGg7IGRlcHRoID4gMDsgZGVwdGggLT0gMSkge1xuICAgIGNvbnN0IG5vZGUgPSAkcG9zLm5vZGUoZGVwdGgpO1xuICAgIGlmIChub2RlLnR5cGUgPT09IGN1cnJlbnROb2RlLnR5cGUpIHtcbiAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBjb25zdCBmcm9tID0gJHBvcy5iZWZvcmUoZGVwdGgpO1xuICAgICAgICBjb25zdCB0byA9ICRwb3MuYWZ0ZXIoZGVwdGgpO1xuICAgICAgICB0ci5kZWxldGUoZnJvbSwgdG8pLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gc3JjL2hlbHBlcnMvZ2V0Tm9kZVR5cGUudHNcbmZ1bmN0aW9uIGdldE5vZGVUeXBlKG5hbWVPclR5cGUsIHNjaGVtYSkge1xuICBpZiAodHlwZW9mIG5hbWVPclR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoIXNjaGVtYS5ub2Rlc1tuYW1lT3JUeXBlXSkge1xuICAgICAgdGhyb3cgRXJyb3IoYFRoZXJlIGlzIG5vIG5vZGUgdHlwZSBuYW1lZCAnJHtuYW1lT3JUeXBlfScuIE1heWJlIHlvdSBmb3Jnb3QgdG8gYWRkIHRoZSBleHRlbnNpb24/YCk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWEubm9kZXNbbmFtZU9yVHlwZV07XG4gIH1cbiAgcmV0dXJuIG5hbWVPclR5cGU7XG59XG5cbi8vIHNyYy9jb21tYW5kcy9kZWxldGVOb2RlLnRzXG52YXIgZGVsZXRlTm9kZSA9ICh0eXBlT3JOYW1lKSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGNvbnN0ICRwb3MgPSB0ci5zZWxlY3Rpb24uJGFuY2hvcjtcbiAgZm9yIChsZXQgZGVwdGggPSAkcG9zLmRlcHRoOyBkZXB0aCA+IDA7IGRlcHRoIC09IDEpIHtcbiAgICBjb25zdCBub2RlID0gJHBvcy5ub2RlKGRlcHRoKTtcbiAgICBpZiAobm9kZS50eXBlID09PSB0eXBlKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgY29uc3QgZnJvbSA9ICRwb3MuYmVmb3JlKGRlcHRoKTtcbiAgICAgICAgY29uc3QgdG8gPSAkcG9zLmFmdGVyKGRlcHRoKTtcbiAgICAgICAgdHIuZGVsZXRlKGZyb20sIHRvKS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9kZWxldGVSYW5nZS50c1xudmFyIGRlbGV0ZVJhbmdlID0gKHJhbmdlKSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB7IGZyb20sIHRvIH0gPSByYW5nZTtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgdHIuZGVsZXRlKGZyb20sIHRvKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9kZWxldGVTZWxlY3Rpb24udHNcbmltcG9ydCB7IGRlbGV0ZVNlbGVjdGlvbiBhcyBvcmlnaW5hbERlbGV0ZVNlbGVjdGlvbiB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgZGVsZXRlU2VsZWN0aW9uID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsRGVsZXRlU2VsZWN0aW9uKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvZW50ZXIudHNcbnZhciBlbnRlciA9ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgcmV0dXJuIGNvbW1hbmRzLmtleWJvYXJkU2hvcnRjdXQoXCJFbnRlclwiKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9leGl0Q29kZS50c1xuaW1wb3J0IHsgZXhpdENvZGUgYXMgb3JpZ2luYWxFeGl0Q29kZSB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgZXhpdENvZGUgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxFeGl0Q29kZShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2V4dGVuZE1hcmtSYW5nZS50c1xuaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiBhcyBUZXh0U2VsZWN0aW9uMiB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG5cbi8vIHNyYy91dGlsaXRpZXMvaXNSZWdFeHAudHNcbmZ1bmN0aW9uIGlzUmVnRXhwKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgUmVnRXhwXVwiO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL29iamVjdEluY2x1ZGVzLnRzXG5mdW5jdGlvbiBvYmplY3RJbmNsdWRlcyhvYmplY3QxLCBvYmplY3QyLCBvcHRpb25zID0geyBzdHJpY3Q6IHRydWUgfSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0Mik7XG4gIGlmICgha2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4ga2V5cy5ldmVyeSgoa2V5KSA9PiB7XG4gICAgaWYgKG9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0MltrZXldID09PSBvYmplY3QxW2tleV07XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cChvYmplY3QyW2tleV0pKSB7XG4gICAgICByZXR1cm4gb2JqZWN0MltrZXldLnRlc3Qob2JqZWN0MVtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDJba2V5XSA9PT0gb2JqZWN0MVtrZXldO1xuICB9KTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0TWFya1JhbmdlLnRzXG5mdW5jdGlvbiBmaW5kTWFya0luU2V0KG1hcmtzLCB0eXBlLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgcmV0dXJuIG1hcmtzLmZpbmQoKGl0ZW0pID0+IHtcbiAgICByZXR1cm4gaXRlbS50eXBlID09PSB0eXBlICYmIG9iamVjdEluY2x1ZGVzKFxuICAgICAgLy8gT25seSBjaGVjayBlcXVhbGl0eSBmb3IgdGhlIGF0dHJpYnV0ZXMgdGhhdCBhcmUgcHJvdmlkZWRcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5tYXAoKGspID0+IFtrLCBpdGVtLmF0dHJzW2tdXSkpLFxuICAgICAgYXR0cmlidXRlc1xuICAgICk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNNYXJrSW5TZXQobWFya3MsIHR5cGUsIGF0dHJpYnV0ZXMgPSB7fSkge1xuICByZXR1cm4gISFmaW5kTWFya0luU2V0KG1hcmtzLCB0eXBlLCBhdHRyaWJ1dGVzKTtcbn1cbmZ1bmN0aW9uIGdldE1hcmtSYW5nZSgkcG9zLCB0eXBlLCBhdHRyaWJ1dGVzKSB7XG4gIHZhciBfYTtcbiAgaWYgKCEkcG9zIHx8ICF0eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzdGFydCA9ICRwb3MucGFyZW50LmNoaWxkQWZ0ZXIoJHBvcy5wYXJlbnRPZmZzZXQpO1xuICBpZiAoIXN0YXJ0Lm5vZGUgfHwgIXN0YXJ0Lm5vZGUubWFya3Muc29tZSgobWFyazIpID0+IG1hcmsyLnR5cGUgPT09IHR5cGUpKSB7XG4gICAgc3RhcnQgPSAkcG9zLnBhcmVudC5jaGlsZEJlZm9yZSgkcG9zLnBhcmVudE9mZnNldCk7XG4gIH1cbiAgaWYgKCFzdGFydC5ub2RlIHx8ICFzdGFydC5ub2RlLm1hcmtzLnNvbWUoKG1hcmsyKSA9PiBtYXJrMi50eXBlID09PSB0eXBlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcyB8fCAoKF9hID0gc3RhcnQubm9kZS5tYXJrc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmF0dHJzKTtcbiAgY29uc3QgbWFyayA9IGZpbmRNYXJrSW5TZXQoWy4uLnN0YXJ0Lm5vZGUubWFya3NdLCB0eXBlLCBhdHRyaWJ1dGVzKTtcbiAgaWYgKCFtYXJrKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzdGFydEluZGV4ID0gc3RhcnQuaW5kZXg7XG4gIGxldCBzdGFydFBvcyA9ICRwb3Muc3RhcnQoKSArIHN0YXJ0Lm9mZnNldDtcbiAgbGV0IGVuZEluZGV4ID0gc3RhcnRJbmRleCArIDE7XG4gIGxldCBlbmRQb3MgPSBzdGFydFBvcyArIHN0YXJ0Lm5vZGUubm9kZVNpemU7XG4gIHdoaWxlIChzdGFydEluZGV4ID4gMCAmJiBpc01hcmtJblNldChbLi4uJHBvcy5wYXJlbnQuY2hpbGQoc3RhcnRJbmRleCAtIDEpLm1hcmtzXSwgdHlwZSwgYXR0cmlidXRlcykpIHtcbiAgICBzdGFydEluZGV4IC09IDE7XG4gICAgc3RhcnRQb3MgLT0gJHBvcy5wYXJlbnQuY2hpbGQoc3RhcnRJbmRleCkubm9kZVNpemU7XG4gIH1cbiAgd2hpbGUgKGVuZEluZGV4IDwgJHBvcy5wYXJlbnQuY2hpbGRDb3VudCAmJiBpc01hcmtJblNldChbLi4uJHBvcy5wYXJlbnQuY2hpbGQoZW5kSW5kZXgpLm1hcmtzXSwgdHlwZSwgYXR0cmlidXRlcykpIHtcbiAgICBlbmRQb3MgKz0gJHBvcy5wYXJlbnQuY2hpbGQoZW5kSW5kZXgpLm5vZGVTaXplO1xuICAgIGVuZEluZGV4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmcm9tOiBzdGFydFBvcyxcbiAgICB0bzogZW5kUG9zXG4gIH07XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dldE1hcmtUeXBlLnRzXG5mdW5jdGlvbiBnZXRNYXJrVHlwZShuYW1lT3JUeXBlLCBzY2hlbWEpIHtcbiAgaWYgKHR5cGVvZiBuYW1lT3JUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKCFzY2hlbWEubWFya3NbbmFtZU9yVHlwZV0pIHtcbiAgICAgIHRocm93IEVycm9yKGBUaGVyZSBpcyBubyBtYXJrIHR5cGUgbmFtZWQgJyR7bmFtZU9yVHlwZX0nLiBNYXliZSB5b3UgZm9yZ290IHRvIGFkZCB0aGUgZXh0ZW5zaW9uP2ApO1xuICAgIH1cbiAgICByZXR1cm4gc2NoZW1hLm1hcmtzW25hbWVPclR5cGVdO1xuICB9XG4gIHJldHVybiBuYW1lT3JUeXBlO1xufVxuXG4vLyBzcmMvY29tbWFuZHMvZXh0ZW5kTWFya1JhbmdlLnRzXG52YXIgZXh0ZW5kTWFya1JhbmdlID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICBjb25zdCB7IGRvYywgc2VsZWN0aW9uIH0gPSB0cjtcbiAgY29uc3QgeyAkZnJvbSwgZnJvbSwgdG8gfSA9IHNlbGVjdGlvbjtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgcmFuZ2UgPSBnZXRNYXJrUmFuZ2UoJGZyb20sIHR5cGUsIGF0dHJpYnV0ZXMpO1xuICAgIGlmIChyYW5nZSAmJiByYW5nZS5mcm9tIDw9IGZyb20gJiYgcmFuZ2UudG8gPj0gdG8pIHtcbiAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IFRleHRTZWxlY3Rpb24yLmNyZWF0ZShkb2MsIHJhbmdlLmZyb20sIHJhbmdlLnRvKTtcbiAgICAgIHRyLnNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9maXJzdC50c1xudmFyIGZpcnN0ID0gKGNvbW1hbmRzKSA9PiAocHJvcHMpID0+IHtcbiAgY29uc3QgaXRlbXMgPSB0eXBlb2YgY29tbWFuZHMgPT09IFwiZnVuY3Rpb25cIiA/IGNvbW1hbmRzKHByb3BzKSA6IGNvbW1hbmRzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGl0ZW1zW2ldKHByb3BzKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIHNyYy9oZWxwZXJzL2lzVGV4dFNlbGVjdGlvbi50c1xuaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiBhcyBUZXh0U2VsZWN0aW9uMyB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG5mdW5jdGlvbiBpc1RleHRTZWxlY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbjM7XG59XG5cbi8vIHNyYy9oZWxwZXJzL3Jlc29sdmVGb2N1c1Bvc2l0aW9uLnRzXG5pbXBvcnQgeyBTZWxlY3Rpb24sIFRleHRTZWxlY3Rpb24gYXMgVGV4dFNlbGVjdGlvbjQgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuXG4vLyBzcmMvdXRpbGl0aWVzL21pbk1heC50c1xuZnVuY3Rpb24gbWluTWF4KHZhbHVlID0gMCwgbWluID0gMCwgbWF4ID0gMCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heCk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL3Jlc29sdmVGb2N1c1Bvc2l0aW9uLnRzXG5mdW5jdGlvbiByZXNvbHZlRm9jdXNQb3NpdGlvbihkb2MsIHBvc2l0aW9uID0gbnVsbCkge1xuICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgc2VsZWN0aW9uQXRTdGFydCA9IFNlbGVjdGlvbi5hdFN0YXJ0KGRvYyk7XG4gIGNvbnN0IHNlbGVjdGlvbkF0RW5kID0gU2VsZWN0aW9uLmF0RW5kKGRvYyk7XG4gIGlmIChwb3NpdGlvbiA9PT0gXCJzdGFydFwiIHx8IHBvc2l0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHNlbGVjdGlvbkF0U3RhcnQ7XG4gIH1cbiAgaWYgKHBvc2l0aW9uID09PSBcImVuZFwiKSB7XG4gICAgcmV0dXJuIHNlbGVjdGlvbkF0RW5kO1xuICB9XG4gIGNvbnN0IG1pblBvcyA9IHNlbGVjdGlvbkF0U3RhcnQuZnJvbTtcbiAgY29uc3QgbWF4UG9zID0gc2VsZWN0aW9uQXRFbmQudG87XG4gIGlmIChwb3NpdGlvbiA9PT0gXCJhbGxcIikge1xuICAgIHJldHVybiBUZXh0U2VsZWN0aW9uNC5jcmVhdGUoZG9jLCBtaW5NYXgoMCwgbWluUG9zLCBtYXhQb3MpLCBtaW5NYXgoZG9jLmNvbnRlbnQuc2l6ZSwgbWluUG9zLCBtYXhQb3MpKTtcbiAgfVxuICByZXR1cm4gVGV4dFNlbGVjdGlvbjQuY3JlYXRlKGRvYywgbWluTWF4KHBvc2l0aW9uLCBtaW5Qb3MsIG1heFBvcyksIG1pbk1heChwb3NpdGlvbiwgbWluUG9zLCBtYXhQb3MpKTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9pc0FuZHJvaWQudHNcbmZ1bmN0aW9uIGlzQW5kcm9pZCgpIHtcbiAgcmV0dXJuIG5hdmlnYXRvci5wbGF0Zm9ybSA9PT0gXCJBbmRyb2lkXCIgfHwgL2FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL2lzaU9TLnRzXG5mdW5jdGlvbiBpc2lPUygpIHtcbiAgcmV0dXJuIFtcImlQYWQgU2ltdWxhdG9yXCIsIFwiaVBob25lIFNpbXVsYXRvclwiLCBcImlQb2QgU2ltdWxhdG9yXCIsIFwiaVBhZFwiLCBcImlQaG9uZVwiLCBcImlQb2RcIl0uaW5jbHVkZXMobmF2aWdhdG9yLnBsYXRmb3JtKSB8fCAvLyBpUGFkIG9uIGlPUyAxMyBkZXRlY3Rpb25cbiAgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcIk1hY1wiKSAmJiBcIm9udG91Y2hlbmRcIiBpbiBkb2N1bWVudDtcbn1cblxuLy8gc3JjL2NvbW1hbmRzL2ZvY3VzLnRzXG52YXIgZm9jdXMgPSAocG9zaXRpb24gPSBudWxsLCBvcHRpb25zID0ge30pID0+ICh7IGVkaXRvciwgdmlldywgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgb3B0aW9ucyA9IHtcbiAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGNvbnN0IGRlbGF5ZWRGb2N1cyA9ICgpID0+IHtcbiAgICBpZiAoaXNpT1MoKSB8fCBpc0FuZHJvaWQoKSkge1xuICAgICAgO1xuICAgICAgdmlldy5kb20uZm9jdXMoKTtcbiAgICB9XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGlmICghZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgICBlZGl0b3IuY29tbWFuZHMuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBpZiAodmlldy5oYXNGb2N1cygpICYmIHBvc2l0aW9uID09PSBudWxsIHx8IHBvc2l0aW9uID09PSBmYWxzZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChkaXNwYXRjaCAmJiBwb3NpdGlvbiA9PT0gbnVsbCAmJiAhaXNUZXh0U2VsZWN0aW9uKGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24pKSB7XG4gICAgZGVsYXllZEZvY3VzKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qgc2VsZWN0aW9uID0gcmVzb2x2ZUZvY3VzUG9zaXRpb24odHIuZG9jLCBwb3NpdGlvbikgfHwgZWRpdG9yLnN0YXRlLnNlbGVjdGlvbjtcbiAgY29uc3QgaXNTYW1lU2VsZWN0aW9uID0gZWRpdG9yLnN0YXRlLnNlbGVjdGlvbi5lcShzZWxlY3Rpb24pO1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBpZiAoIWlzU2FtZVNlbGVjdGlvbikge1xuICAgICAgdHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgfVxuICAgIGlmIChpc1NhbWVTZWxlY3Rpb24gJiYgdHIuc3RvcmVkTWFya3MpIHtcbiAgICAgIHRyLnNldFN0b3JlZE1hcmtzKHRyLnN0b3JlZE1hcmtzKTtcbiAgICB9XG4gICAgZGVsYXllZEZvY3VzKCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvZm9yRWFjaC50c1xudmFyIGZvckVhY2ggPSAoaXRlbXMsIGZuKSA9PiAocHJvcHMpID0+IHtcbiAgcmV0dXJuIGl0ZW1zLmV2ZXJ5KChpdGVtLCBpbmRleCkgPT4gZm4oaXRlbSwgeyAuLi5wcm9wcywgaW5kZXggfSkpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2luc2VydENvbnRlbnQudHNcbnZhciBpbnNlcnRDb250ZW50ID0gKHZhbHVlLCBvcHRpb25zKSA9PiAoeyB0ciwgY29tbWFuZHMgfSkgPT4ge1xuICByZXR1cm4gY29tbWFuZHMuaW5zZXJ0Q29udGVudEF0KHsgZnJvbTogdHIuc2VsZWN0aW9uLmZyb20sIHRvOiB0ci5zZWxlY3Rpb24udG8gfSwgdmFsdWUsIG9wdGlvbnMpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2luc2VydENvbnRlbnRBdC50c1xuaW1wb3J0IHsgRnJhZ21lbnQgYXMgRnJhZ21lbnQyIH0gZnJvbSBcIkB0aXB0YXAvcG0vbW9kZWxcIjtcblxuLy8gc3JjL2hlbHBlcnMvY3JlYXRlTm9kZUZyb21Db250ZW50LnRzXG5pbXBvcnQgeyBET01QYXJzZXIsIEZyYWdtZW50LCBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSwgU2NoZW1hIH0gZnJvbSBcIkB0aXB0YXAvcG0vbW9kZWxcIjtcblxuLy8gc3JjL3V0aWxpdGllcy9lbGVtZW50RnJvbVN0cmluZy50c1xudmFyIHJlbW92ZVdoaXRlc3BhY2VzID0gKG5vZGUpID0+IHtcbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XG4gIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAzICYmIGNoaWxkLm5vZGVWYWx1ZSAmJiAvXihcXG5cXHNcXHN8XFxuKSQvLnRlc3QoY2hpbGQubm9kZVZhbHVlKSkge1xuICAgICAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgfSBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgcmVtb3ZlV2hpdGVzcGFjZXMoY2hpbGQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZTtcbn07XG5mdW5jdGlvbiBlbGVtZW50RnJvbVN0cmluZyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlt0aXB0YXAgZXJyb3JdOiB0aGVyZSBpcyBubyB3aW5kb3cgb2JqZWN0IGF2YWlsYWJsZSwgc28gdGhpcyBmdW5jdGlvbiBjYW5ub3QgYmUgdXNlZFwiKTtcbiAgfVxuICBjb25zdCB3cmFwcGVkVmFsdWUgPSBgPGJvZHk+JHt2YWx1ZX08L2JvZHk+YDtcbiAgY29uc3QgaHRtbCA9IG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHdyYXBwZWRWYWx1ZSwgXCJ0ZXh0L2h0bWxcIikuYm9keTtcbiAgcmV0dXJuIHJlbW92ZVdoaXRlc3BhY2VzKGh0bWwpO1xufVxuXG4vLyBzcmMvaGVscGVycy9jcmVhdGVOb2RlRnJvbUNvbnRlbnQudHNcbmZ1bmN0aW9uIGNyZWF0ZU5vZGVGcm9tQ29udGVudChjb250ZW50LCBzY2hlbWEsIG9wdGlvbnMpIHtcbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBQcm9zZU1pcnJvck5vZGUgfHwgY29udGVudCBpbnN0YW5jZW9mIEZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgb3B0aW9ucyA9IHtcbiAgICBzbGljZTogdHJ1ZSxcbiAgICBwYXJzZU9wdGlvbnM6IHt9LFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgY29uc3QgaXNKU09OQ29udGVudCA9IHR5cGVvZiBjb250ZW50ID09PSBcIm9iamVjdFwiICYmIGNvbnRlbnQgIT09IG51bGw7XG4gIGNvbnN0IGlzVGV4dENvbnRlbnQgPSB0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIjtcbiAgaWYgKGlzSlNPTkNvbnRlbnQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaXNBcnJheUNvbnRlbnQgPSBBcnJheS5pc0FycmF5KGNvbnRlbnQpICYmIGNvbnRlbnQubGVuZ3RoID4gMDtcbiAgICAgIGlmIChpc0FycmF5Q29udGVudCkge1xuICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbUFycmF5KGNvbnRlbnQubWFwKChpdGVtKSA9PiBzY2hlbWEubm9kZUZyb21KU09OKGl0ZW0pKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlID0gc2NoZW1hLm5vZGVGcm9tSlNPTihjb250ZW50KTtcbiAgICAgIGlmIChvcHRpb25zLmVycm9yT25JbnZhbGlkQ29udGVudCkge1xuICAgICAgICBub2RlLmNoZWNrKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKG9wdGlvbnMuZXJyb3JPbkludmFsaWRDb250ZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlt0aXB0YXAgZXJyb3JdOiBJbnZhbGlkIEpTT04gY29udGVudFwiLCB7IGNhdXNlOiBlcnJvciB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcIlt0aXB0YXAgd2Fybl06IEludmFsaWQgY29udGVudC5cIiwgXCJQYXNzZWQgdmFsdWU6XCIsIGNvbnRlbnQsIFwiRXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoXCJcIiwgc2NoZW1hLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVGV4dENvbnRlbnQpIHtcbiAgICBpZiAob3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQpIHtcbiAgICAgIGxldCBoYXNJbnZhbGlkQ29udGVudCA9IGZhbHNlO1xuICAgICAgbGV0IGludmFsaWRDb250ZW50ID0gXCJcIjtcbiAgICAgIGNvbnN0IGNvbnRlbnRDaGVja1NjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICAgICAgICB0b3BOb2RlOiBzY2hlbWEuc3BlYy50b3BOb2RlLFxuICAgICAgICBtYXJrczogc2NoZW1hLnNwZWMubWFya3MsXG4gICAgICAgIC8vIFByb3NlbWlycm9yJ3Mgc2NoZW1hcyBhcmUgZXhlY3V0ZWQgc3VjaCB0aGF0OiB0aGUgbGFzdCB0byBleGVjdXRlLCBtYXRjaGVzIGxhc3RcbiAgICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IHdlIGNhbiBhZGQgYSBjYXRjaC1hbGwgbm9kZSBhdCB0aGUgZW5kIG9mIHRoZSBzY2hlbWEgdG8gY2F0Y2ggYW55IGNvbnRlbnQgdGhhdCB3ZSBkb24ndCBrbm93IGhvdyB0byBoYW5kbGVcbiAgICAgICAgbm9kZXM6IHNjaGVtYS5zcGVjLm5vZGVzLmFwcGVuZCh7XG4gICAgICAgICAgX190aXB0YXBfX3ByaXZhdGVfX3Vua25vd25fX2NhdGNoX19hbGxfX25vZGU6IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwiaW5saW5lKlwiLFxuICAgICAgICAgICAgZ3JvdXA6IFwiYmxvY2tcIixcbiAgICAgICAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWc6IFwiKlwiLFxuICAgICAgICAgICAgICAgIGdldEF0dHJzOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgaGFzSW52YWxpZENvbnRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgaW52YWxpZENvbnRlbnQgPSB0eXBlb2YgZSA9PT0gXCJzdHJpbmdcIiA/IGUgOiBlLm91dGVySFRNTDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgaWYgKG9wdGlvbnMuc2xpY2UpIHtcbiAgICAgICAgRE9NUGFyc2VyLmZyb21TY2hlbWEoY29udGVudENoZWNrU2NoZW1hKS5wYXJzZVNsaWNlKGVsZW1lbnRGcm9tU3RyaW5nKGNvbnRlbnQpLCBvcHRpb25zLnBhcnNlT3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBET01QYXJzZXIuZnJvbVNjaGVtYShjb250ZW50Q2hlY2tTY2hlbWEpLnBhcnNlKGVsZW1lbnRGcm9tU3RyaW5nKGNvbnRlbnQpLCBvcHRpb25zLnBhcnNlT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQgJiYgaGFzSW52YWxpZENvbnRlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW3RpcHRhcCBlcnJvcl06IEludmFsaWQgSFRNTCBjb250ZW50XCIsIHtcbiAgICAgICAgICBjYXVzZTogbmV3IEVycm9yKGBJbnZhbGlkIGVsZW1lbnQgZm91bmQ6ICR7aW52YWxpZENvbnRlbnR9YClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlciA9IERPTVBhcnNlci5mcm9tU2NoZW1hKHNjaGVtYSk7XG4gICAgaWYgKG9wdGlvbnMuc2xpY2UpIHtcbiAgICAgIHJldHVybiBwYXJzZXIucGFyc2VTbGljZShlbGVtZW50RnJvbVN0cmluZyhjb250ZW50KSwgb3B0aW9ucy5wYXJzZU9wdGlvbnMpLmNvbnRlbnQ7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZXIucGFyc2UoZWxlbWVudEZyb21TdHJpbmcoY29udGVudCksIG9wdGlvbnMucGFyc2VPcHRpb25zKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlTm9kZUZyb21Db250ZW50KFwiXCIsIHNjaGVtYSwgb3B0aW9ucyk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL3NlbGVjdGlvblRvSW5zZXJ0aW9uRW5kLnRzXG5pbXBvcnQgeyBTZWxlY3Rpb24gYXMgU2VsZWN0aW9uMiB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG5pbXBvcnQgeyBSZXBsYWNlQXJvdW5kU3RlcCwgUmVwbGFjZVN0ZXAgfSBmcm9tIFwiQHRpcHRhcC9wbS90cmFuc2Zvcm1cIjtcbmZ1bmN0aW9uIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCBzdGFydExlbiwgYmlhcykge1xuICBjb25zdCBsYXN0ID0gdHIuc3RlcHMubGVuZ3RoIC0gMTtcbiAgaWYgKGxhc3QgPCBzdGFydExlbikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzdGVwID0gdHIuc3RlcHNbbGFzdF07XG4gIGlmICghKHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlU3RlcCB8fCBzdGVwIGluc3RhbmNlb2YgUmVwbGFjZUFyb3VuZFN0ZXApKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG1hcCA9IHRyLm1hcHBpbmcubWFwc1tsYXN0XTtcbiAgbGV0IGVuZCA9IDA7XG4gIG1hcC5mb3JFYWNoKChfZnJvbSwgX3RvLCBfbmV3RnJvbSwgbmV3VG8pID0+IHtcbiAgICBpZiAoZW5kID09PSAwKSB7XG4gICAgICBlbmQgPSBuZXdUbztcbiAgICB9XG4gIH0pO1xuICB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uMi5uZWFyKHRyLmRvYy5yZXNvbHZlKGVuZCksIGJpYXMpKTtcbn1cblxuLy8gc3JjL2NvbW1hbmRzL2luc2VydENvbnRlbnRBdC50c1xudmFyIGlzRnJhZ21lbnQgPSAobm9kZU9yRnJhZ21lbnQpID0+IHtcbiAgcmV0dXJuICEoXCJ0eXBlXCIgaW4gbm9kZU9yRnJhZ21lbnQpO1xufTtcbnZhciBpbnNlcnRDb250ZW50QXQgPSAocG9zaXRpb24sIHZhbHVlLCBvcHRpb25zKSA9PiAoeyB0ciwgZGlzcGF0Y2gsIGVkaXRvciB9KSA9PiB7XG4gIHZhciBfYTtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHBhcnNlT3B0aW9uczogZWRpdG9yLm9wdGlvbnMucGFyc2VPcHRpb25zLFxuICAgICAgdXBkYXRlU2VsZWN0aW9uOiB0cnVlLFxuICAgICAgYXBwbHlJbnB1dFJ1bGVzOiBmYWxzZSxcbiAgICAgIGFwcGx5UGFzdGVSdWxlczogZmFsc2UsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgICBsZXQgY29udGVudDtcbiAgICBjb25zdCBlbWl0Q29udGVudEVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICBlZGl0b3IuZW1pdChcImNvbnRlbnRFcnJvclwiLCB7XG4gICAgICAgIGVkaXRvcixcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGRpc2FibGVDb2xsYWJvcmF0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgaWYgKFwiY29sbGFib3JhdGlvblwiIGluIGVkaXRvci5zdG9yYWdlICYmIHR5cGVvZiBlZGl0b3Iuc3RvcmFnZS5jb2xsYWJvcmF0aW9uID09PSBcIm9iamVjdFwiICYmIGVkaXRvci5zdG9yYWdlLmNvbGxhYm9yYXRpb24pIHtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGVkaXRvci5zdG9yYWdlLmNvbGxhYm9yYXRpb24uaXNEaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHBhcnNlT3B0aW9ucyA9IHtcbiAgICAgIHByZXNlcnZlV2hpdGVzcGFjZTogXCJmdWxsXCIsXG4gICAgICAuLi5vcHRpb25zLnBhcnNlT3B0aW9uc1xuICAgIH07XG4gICAgaWYgKCFvcHRpb25zLmVycm9yT25JbnZhbGlkQ29udGVudCAmJiAhZWRpdG9yLm9wdGlvbnMuZW5hYmxlQ29udGVudENoZWNrICYmIGVkaXRvci5vcHRpb25zLmVtaXRDb250ZW50RXJyb3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNyZWF0ZU5vZGVGcm9tQ29udGVudCh2YWx1ZSwgZWRpdG9yLnNjaGVtYSwge1xuICAgICAgICAgIHBhcnNlT3B0aW9ucyxcbiAgICAgICAgICBlcnJvck9uSW52YWxpZENvbnRlbnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVtaXRDb250ZW50RXJyb3IoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb250ZW50ID0gY3JlYXRlTm9kZUZyb21Db250ZW50KHZhbHVlLCBlZGl0b3Iuc2NoZW1hLCB7XG4gICAgICAgIHBhcnNlT3B0aW9ucyxcbiAgICAgICAgZXJyb3JPbkludmFsaWRDb250ZW50OiAoX2EgPSBvcHRpb25zLmVycm9yT25JbnZhbGlkQ29udGVudCkgIT0gbnVsbCA/IF9hIDogZWRpdG9yLm9wdGlvbnMuZW5hYmxlQ29udGVudENoZWNrXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlbWl0Q29udGVudEVycm9yKGUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgeyBmcm9tLCB0byB9ID0gdHlwZW9mIHBvc2l0aW9uID09PSBcIm51bWJlclwiID8geyBmcm9tOiBwb3NpdGlvbiwgdG86IHBvc2l0aW9uIH0gOiB7IGZyb206IHBvc2l0aW9uLmZyb20sIHRvOiBwb3NpdGlvbi50byB9O1xuICAgIGxldCBpc09ubHlUZXh0Q29udGVudCA9IHRydWU7XG4gICAgbGV0IGlzT25seUJsb2NrQ29udGVudCA9IHRydWU7XG4gICAgY29uc3Qgbm9kZXMgPSBpc0ZyYWdtZW50KGNvbnRlbnQpID8gY29udGVudCA6IFtjb250ZW50XTtcbiAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBub2RlLmNoZWNrKCk7XG4gICAgICBpc09ubHlUZXh0Q29udGVudCA9IGlzT25seVRleHRDb250ZW50ID8gbm9kZS5pc1RleHQgJiYgbm9kZS5tYXJrcy5sZW5ndGggPT09IDAgOiBmYWxzZTtcbiAgICAgIGlzT25seUJsb2NrQ29udGVudCA9IGlzT25seUJsb2NrQ29udGVudCA/IG5vZGUuaXNCbG9jayA6IGZhbHNlO1xuICAgIH0pO1xuICAgIGlmIChmcm9tID09PSB0byAmJiBpc09ubHlCbG9ja0NvbnRlbnQpIHtcbiAgICAgIGNvbnN0IHsgcGFyZW50IH0gPSB0ci5kb2MucmVzb2x2ZShmcm9tKTtcbiAgICAgIGNvbnN0IGlzRW1wdHlUZXh0QmxvY2sgPSBwYXJlbnQuaXNUZXh0YmxvY2sgJiYgIXBhcmVudC50eXBlLnNwZWMuY29kZSAmJiAhcGFyZW50LmNoaWxkQ291bnQ7XG4gICAgICBpZiAoaXNFbXB0eVRleHRCbG9jaykge1xuICAgICAgICBmcm9tIC09IDE7XG4gICAgICAgIHRvICs9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBuZXdDb250ZW50O1xuICAgIGlmIChpc09ubHlUZXh0Q29udGVudCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIG5ld0NvbnRlbnQgPSB2YWx1ZS5tYXAoKHYpID0+IHYudGV4dCB8fCBcIlwiKS5qb2luKFwiXCIpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZyYWdtZW50Mikge1xuICAgICAgICBsZXQgdGV4dCA9IFwiXCI7XG4gICAgICAgIHZhbHVlLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICBpZiAobm9kZS50ZXh0KSB7XG4gICAgICAgICAgICB0ZXh0ICs9IG5vZGUudGV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBuZXdDb250ZW50ID0gdGV4dDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmICEhdmFsdWUgJiYgISF2YWx1ZS50ZXh0KSB7XG4gICAgICAgIG5ld0NvbnRlbnQgPSB2YWx1ZS50ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3Q29udGVudCA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgdHIuaW5zZXJ0VGV4dChuZXdDb250ZW50LCBmcm9tLCB0byk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0NvbnRlbnQgPSBjb250ZW50O1xuICAgICAgY29uc3QgJGZyb20gPSB0ci5kb2MucmVzb2x2ZShmcm9tKTtcbiAgICAgIGNvbnN0ICRmcm9tTm9kZSA9ICRmcm9tLm5vZGUoKTtcbiAgICAgIGNvbnN0IGZyb21TZWxlY3Rpb25BdFN0YXJ0ID0gJGZyb20ucGFyZW50T2Zmc2V0ID09PSAwO1xuICAgICAgY29uc3QgaXNUZXh0U2VsZWN0aW9uMiA9ICRmcm9tTm9kZS5pc1RleHQgfHwgJGZyb21Ob2RlLmlzVGV4dGJsb2NrO1xuICAgICAgY29uc3QgaGFzQ29udGVudCA9ICRmcm9tTm9kZS5jb250ZW50LnNpemUgPiAwO1xuICAgICAgaWYgKGZyb21TZWxlY3Rpb25BdFN0YXJ0ICYmIGlzVGV4dFNlbGVjdGlvbjIgJiYgaGFzQ29udGVudCkge1xuICAgICAgICBmcm9tID0gTWF0aC5tYXgoMCwgZnJvbSAtIDEpO1xuICAgICAgfVxuICAgICAgdHIucmVwbGFjZVdpdGgoZnJvbSwgdG8sIG5ld0NvbnRlbnQpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy51cGRhdGVTZWxlY3Rpb24pIHtcbiAgICAgIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCB0ci5zdGVwcy5sZW5ndGggLSAxLCAtMSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFwcGx5SW5wdXRSdWxlcykge1xuICAgICAgdHIuc2V0TWV0YShcImFwcGx5SW5wdXRSdWxlc1wiLCB7IGZyb20sIHRleHQ6IG5ld0NvbnRlbnQgfSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFwcGx5UGFzdGVSdWxlcykge1xuICAgICAgdHIuc2V0TWV0YShcImFwcGx5UGFzdGVSdWxlc1wiLCB7IGZyb20sIHRleHQ6IG5ld0NvbnRlbnQgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2pvaW4udHNcbmltcG9ydCB7XG4gIGpvaW5CYWNrd2FyZCBhcyBvcmlnaW5hbEpvaW5CYWNrd2FyZCxcbiAgam9pbkRvd24gYXMgb3JpZ2luYWxKb2luRG93bixcbiAgam9pbkZvcndhcmQgYXMgb3JpZ2luYWxKb2luRm9yd2FyZCxcbiAgam9pblVwIGFzIG9yaWdpbmFsSm9pblVwXG59IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgam9pblVwID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsSm9pblVwKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xudmFyIGpvaW5Eb3duID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsSm9pbkRvd24oc3RhdGUsIGRpc3BhdGNoKTtcbn07XG52YXIgam9pbkJhY2t3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsSm9pbkJhY2t3YXJkKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xudmFyIGpvaW5Gb3J3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsSm9pbkZvcndhcmQoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9qb2luSXRlbUJhY2t3YXJkLnRzXG5pbXBvcnQgeyBqb2luUG9pbnQgfSBmcm9tIFwiQHRpcHRhcC9wbS90cmFuc2Zvcm1cIjtcbnZhciBqb2luSXRlbUJhY2t3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoLCB0ciB9KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcG9pbnQgPSBqb2luUG9pbnQoc3RhdGUuZG9jLCBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ucG9zLCAtMSk7XG4gICAgaWYgKHBvaW50ID09PSBudWxsIHx8IHBvaW50ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHIuam9pbihwb2ludCwgMik7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBkaXNwYXRjaCh0cik7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tYW5kcy9qb2luSXRlbUZvcndhcmQudHNcbmltcG9ydCB7IGpvaW5Qb2ludCBhcyBqb2luUG9pbnQyIH0gZnJvbSBcIkB0aXB0YXAvcG0vdHJhbnNmb3JtXCI7XG52YXIgam9pbkl0ZW1Gb3J3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoLCB0ciB9KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcG9pbnQgPSBqb2luUG9pbnQyKHN0YXRlLmRvYywgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBvcywgMSk7XG4gICAgaWYgKHBvaW50ID09PSBudWxsIHx8IHBvaW50ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHIuam9pbihwb2ludCwgMik7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBkaXNwYXRjaCh0cik7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tYW5kcy9qb2luVGV4dGJsb2NrQmFja3dhcmQudHNcbmltcG9ydCB7IGpvaW5UZXh0YmxvY2tCYWNrd2FyZCBhcyBvcmlnaW5hbENvbW1hbmQgfSBmcm9tIFwiQHRpcHRhcC9wbS9jb21tYW5kc1wiO1xudmFyIGpvaW5UZXh0YmxvY2tCYWNrd2FyZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbENvbW1hbmQoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9qb2luVGV4dGJsb2NrRm9yd2FyZC50c1xuaW1wb3J0IHsgam9pblRleHRibG9ja0ZvcndhcmQgYXMgb3JpZ2luYWxDb21tYW5kMiB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgam9pblRleHRibG9ja0ZvcndhcmQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxDb21tYW5kMihzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLy8gc3JjL3V0aWxpdGllcy9pc01hY09TLnRzXG5mdW5jdGlvbiBpc01hY09TKCkge1xuICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiA/IC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSA6IGZhbHNlO1xufVxuXG4vLyBzcmMvY29tbWFuZHMva2V5Ym9hcmRTaG9ydGN1dC50c1xuZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lKSB7XG4gIGNvbnN0IHBhcnRzID0gbmFtZS5zcGxpdCgvLSg/ISQpLyk7XG4gIGxldCByZXN1bHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgaWYgKHJlc3VsdCA9PT0gXCJTcGFjZVwiKSB7XG4gICAgcmVzdWx0ID0gXCIgXCI7XG4gIH1cbiAgbGV0IGFsdDtcbiAgbGV0IGN0cmw7XG4gIGxldCBzaGlmdDtcbiAgbGV0IG1ldGE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgY29uc3QgbW9kID0gcGFydHNbaV07XG4gICAgaWYgKC9eKGNtZHxtZXRhfG0pJC9pLnRlc3QobW9kKSkge1xuICAgICAgbWV0YSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpIHtcbiAgICAgIGFsdCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICgvXihjfGN0cmx8Y29udHJvbCkkL2kudGVzdChtb2QpKSB7XG4gICAgICBjdHJsID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKC9ecyhoaWZ0KT8kL2kudGVzdChtb2QpKSB7XG4gICAgICBzaGlmdCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICgvXm1vZCQvaS50ZXN0KG1vZCkpIHtcbiAgICAgIGlmIChpc2lPUygpIHx8IGlzTWFjT1MoKSkge1xuICAgICAgICBtZXRhID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0cmwgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiAke21vZH1gKTtcbiAgICB9XG4gIH1cbiAgaWYgKGFsdCkge1xuICAgIHJlc3VsdCA9IGBBbHQtJHtyZXN1bHR9YDtcbiAgfVxuICBpZiAoY3RybCkge1xuICAgIHJlc3VsdCA9IGBDdHJsLSR7cmVzdWx0fWA7XG4gIH1cbiAgaWYgKG1ldGEpIHtcbiAgICByZXN1bHQgPSBgTWV0YS0ke3Jlc3VsdH1gO1xuICB9XG4gIGlmIChzaGlmdCkge1xuICAgIHJlc3VsdCA9IGBTaGlmdC0ke3Jlc3VsdH1gO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIga2V5Ym9hcmRTaG9ydGN1dCA9IChuYW1lKSA9PiAoeyBlZGl0b3IsIHZpZXcsIHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IGtleXMgPSBub3JtYWxpemVLZXlOYW1lKG5hbWUpLnNwbGl0KC8tKD8hJCkvKTtcbiAgY29uc3Qga2V5ID0ga2V5cy5maW5kKChpdGVtKSA9PiAhW1wiQWx0XCIsIFwiQ3RybFwiLCBcIk1ldGFcIiwgXCJTaGlmdFwiXS5pbmNsdWRlcyhpdGVtKSk7XG4gIGNvbnN0IGV2ZW50ID0gbmV3IEtleWJvYXJkRXZlbnQoXCJrZXlkb3duXCIsIHtcbiAgICBrZXk6IGtleSA9PT0gXCJTcGFjZVwiID8gXCIgXCIgOiBrZXksXG4gICAgYWx0S2V5OiBrZXlzLmluY2x1ZGVzKFwiQWx0XCIpLFxuICAgIGN0cmxLZXk6IGtleXMuaW5jbHVkZXMoXCJDdHJsXCIpLFxuICAgIG1ldGFLZXk6IGtleXMuaW5jbHVkZXMoXCJNZXRhXCIpLFxuICAgIHNoaWZ0S2V5OiBrZXlzLmluY2x1ZGVzKFwiU2hpZnRcIiksXG4gICAgYnViYmxlczogdHJ1ZSxcbiAgICBjYW5jZWxhYmxlOiB0cnVlXG4gIH0pO1xuICBjb25zdCBjYXB0dXJlZFRyYW5zYWN0aW9uID0gZWRpdG9yLmNhcHR1cmVUcmFuc2FjdGlvbigoKSA9PiB7XG4gICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgKGYpID0+IGYodmlldywgZXZlbnQpKTtcbiAgfSk7XG4gIGNhcHR1cmVkVHJhbnNhY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGNhcHR1cmVkVHJhbnNhY3Rpb24uc3RlcHMuZm9yRWFjaCgoc3RlcCkgPT4ge1xuICAgIGNvbnN0IG5ld1N0ZXAgPSBzdGVwLm1hcCh0ci5tYXBwaW5nKTtcbiAgICBpZiAobmV3U3RlcCAmJiBkaXNwYXRjaCkge1xuICAgICAgdHIubWF5YmVTdGVwKG5ld1N0ZXApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2xpZnQudHNcbmltcG9ydCB7IGxpZnQgYXMgb3JpZ2luYWxMaWZ0IH0gZnJvbSBcIkB0aXB0YXAvcG0vY29tbWFuZHNcIjtcblxuLy8gc3JjL2hlbHBlcnMvaXNOb2RlQWN0aXZlLnRzXG5mdW5jdGlvbiBpc05vZGVBY3RpdmUoc3RhdGUsIHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkge1xuICBjb25zdCB7IGZyb20sIHRvLCBlbXB0eSB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICBjb25zdCB0eXBlID0gdHlwZU9yTmFtZSA/IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSkgOiBudWxsO1xuICBjb25zdCBub2RlUmFuZ2VzID0gW107XG4gIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVsYXRpdmVGcm9tID0gTWF0aC5tYXgoZnJvbSwgcG9zKTtcbiAgICBjb25zdCByZWxhdGl2ZVRvID0gTWF0aC5taW4odG8sIHBvcyArIG5vZGUubm9kZVNpemUpO1xuICAgIG5vZGVSYW5nZXMucHVzaCh7XG4gICAgICBub2RlLFxuICAgICAgZnJvbTogcmVsYXRpdmVGcm9tLFxuICAgICAgdG86IHJlbGF0aXZlVG9cbiAgICB9KTtcbiAgfSk7XG4gIGNvbnN0IHNlbGVjdGlvblJhbmdlID0gdG8gLSBmcm9tO1xuICBjb25zdCBtYXRjaGVkTm9kZVJhbmdlcyA9IG5vZGVSYW5nZXMuZmlsdGVyKChub2RlUmFuZ2UpID0+IHtcbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZS5uYW1lID09PSBub2RlUmFuZ2Uubm9kZS50eXBlLm5hbWU7XG4gIH0pLmZpbHRlcigobm9kZVJhbmdlKSA9PiBvYmplY3RJbmNsdWRlcyhub2RlUmFuZ2Uubm9kZS5hdHRycywgYXR0cmlidXRlcywgeyBzdHJpY3Q6IGZhbHNlIH0pKTtcbiAgaWYgKGVtcHR5KSB7XG4gICAgcmV0dXJuICEhbWF0Y2hlZE5vZGVSYW5nZXMubGVuZ3RoO1xuICB9XG4gIGNvbnN0IHJhbmdlID0gbWF0Y2hlZE5vZGVSYW5nZXMucmVkdWNlKChzdW0sIG5vZGVSYW5nZSkgPT4gc3VtICsgbm9kZVJhbmdlLnRvIC0gbm9kZVJhbmdlLmZyb20sIDApO1xuICByZXR1cm4gcmFuZ2UgPj0gc2VsZWN0aW9uUmFuZ2U7XG59XG5cbi8vIHNyYy9jb21tYW5kcy9saWZ0LnRzXG52YXIgbGlmdCA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICBjb25zdCBpc0FjdGl2ZTIgPSBpc05vZGVBY3RpdmUoc3RhdGUsIHR5cGUsIGF0dHJpYnV0ZXMpO1xuICBpZiAoIWlzQWN0aXZlMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3JpZ2luYWxMaWZ0KHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvbGlmdEVtcHR5QmxvY2sudHNcbmltcG9ydCB7IGxpZnRFbXB0eUJsb2NrIGFzIG9yaWdpbmFsTGlmdEVtcHR5QmxvY2sgfSBmcm9tIFwiQHRpcHRhcC9wbS9jb21tYW5kc1wiO1xudmFyIGxpZnRFbXB0eUJsb2NrID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsTGlmdEVtcHR5QmxvY2soc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9saWZ0TGlzdEl0ZW0udHNcbmltcG9ydCB7IGxpZnRMaXN0SXRlbSBhcyBvcmlnaW5hbExpZnRMaXN0SXRlbSB9IGZyb20gXCJAdGlwdGFwL3BtL3NjaGVtYS1saXN0XCI7XG52YXIgbGlmdExpc3RJdGVtID0gKHR5cGVPck5hbWUpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICByZXR1cm4gb3JpZ2luYWxMaWZ0TGlzdEl0ZW0odHlwZSkoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9uZXdsaW5lSW5Db2RlLnRzXG5pbXBvcnQgeyBuZXdsaW5lSW5Db2RlIGFzIG9yaWdpbmFsTmV3bGluZUluQ29kZSB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgbmV3bGluZUluQ29kZSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbE5ld2xpbmVJbkNvZGUoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9oZWxwZXJzL2dldFNjaGVtYVR5cGVOYW1lQnlOYW1lLnRzXG5mdW5jdGlvbiBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShuYW1lLCBzY2hlbWEpIHtcbiAgaWYgKHNjaGVtYS5ub2Rlc1tuYW1lXSkge1xuICAgIHJldHVybiBcIm5vZGVcIjtcbiAgfVxuICBpZiAoc2NoZW1hLm1hcmtzW25hbWVdKSB7XG4gICAgcmV0dXJuIFwibWFya1wiO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL2RlbGV0ZVByb3BzLnRzXG5mdW5jdGlvbiBkZWxldGVQcm9wcyhvYmosIHByb3BPclByb3BzKSB7XG4gIGNvbnN0IHByb3BzID0gdHlwZW9mIHByb3BPclByb3BzID09PSBcInN0cmluZ1wiID8gW3Byb3BPclByb3BzXSA6IHByb3BPclByb3BzO1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoKG5ld09iaiwgcHJvcCkgPT4ge1xuICAgIGlmICghcHJvcHMuaW5jbHVkZXMocHJvcCkpIHtcbiAgICAgIG5ld09ialtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld09iajtcbiAgfSwge30pO1xufVxuXG4vLyBzcmMvY29tbWFuZHMvcmVzZXRBdHRyaWJ1dGVzLnRzXG52YXIgcmVzZXRBdHRyaWJ1dGVzID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMpID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBsZXQgbm9kZVR5cGUgPSBudWxsO1xuICBsZXQgbWFya1R5cGUgPSBudWxsO1xuICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUoXG4gICAgdHlwZW9mIHR5cGVPck5hbWUgPT09IFwic3RyaW5nXCIgPyB0eXBlT3JOYW1lIDogdHlwZU9yTmFtZS5uYW1lLFxuICAgIHN0YXRlLnNjaGVtYVxuICApO1xuICBpZiAoIXNjaGVtYVR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHNjaGVtYVR5cGUgPT09IFwibm9kZVwiKSB7XG4gICAgbm9kZVR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICB9XG4gIGlmIChzY2hlbWFUeXBlID09PSBcIm1hcmtcIikge1xuICAgIG1hcmtUeXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgfVxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB0ci5zZWxlY3Rpb24ucmFuZ2VzLmZvckVhY2goKHJhbmdlKSA9PiB7XG4gICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKHJhbmdlLiRmcm9tLnBvcywgcmFuZ2UuJHRvLnBvcywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUgPT09IG5vZGUudHlwZSkge1xuICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCB2b2lkIDAsIGRlbGV0ZVByb3BzKG5vZGUuYXR0cnMsIGF0dHJpYnV0ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya1R5cGUgJiYgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICBub2RlLm1hcmtzLmZvckVhY2goKG1hcmspID0+IHtcbiAgICAgICAgICAgIGlmIChtYXJrVHlwZSA9PT0gbWFyay50eXBlKSB7XG4gICAgICAgICAgICAgIHRyLmFkZE1hcmsocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCBtYXJrVHlwZS5jcmVhdGUoZGVsZXRlUHJvcHMobWFyay5hdHRycywgYXR0cmlidXRlcykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvc2Nyb2xsSW50b1ZpZXcudHNcbnZhciBzY3JvbGxJbnRvVmlldyA9ICgpID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHRyLnNjcm9sbEludG9WaWV3KCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvc2VsZWN0QWxsLnRzXG5pbXBvcnQgeyBBbGxTZWxlY3Rpb24gfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xudmFyIHNlbGVjdEFsbCA9ICgpID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IG5ldyBBbGxTZWxlY3Rpb24odHIuZG9jKTtcbiAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zZWxlY3ROb2RlQmFja3dhcmQudHNcbmltcG9ydCB7IHNlbGVjdE5vZGVCYWNrd2FyZCBhcyBvcmlnaW5hbFNlbGVjdE5vZGVCYWNrd2FyZCB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgc2VsZWN0Tm9kZUJhY2t3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsU2VsZWN0Tm9kZUJhY2t3YXJkKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvc2VsZWN0Tm9kZUZvcndhcmQudHNcbmltcG9ydCB7IHNlbGVjdE5vZGVGb3J3YXJkIGFzIG9yaWdpbmFsU2VsZWN0Tm9kZUZvcndhcmQgfSBmcm9tIFwiQHRpcHRhcC9wbS9jb21tYW5kc1wiO1xudmFyIHNlbGVjdE5vZGVGb3J3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsU2VsZWN0Tm9kZUZvcndhcmQoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zZWxlY3RQYXJlbnROb2RlLnRzXG5pbXBvcnQgeyBzZWxlY3RQYXJlbnROb2RlIGFzIG9yaWdpbmFsU2VsZWN0UGFyZW50Tm9kZSB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgc2VsZWN0UGFyZW50Tm9kZSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbFNlbGVjdFBhcmVudE5vZGUoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zZWxlY3RUZXh0YmxvY2tFbmQudHNcbmltcG9ydCB7IHNlbGVjdFRleHRibG9ja0VuZCBhcyBvcmlnaW5hbFNlbGVjdFRleHRibG9ja0VuZCB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgc2VsZWN0VGV4dGJsb2NrRW5kID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrRW5kKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvc2VsZWN0VGV4dGJsb2NrU3RhcnQudHNcbmltcG9ydCB7IHNlbGVjdFRleHRibG9ja1N0YXJ0IGFzIG9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrU3RhcnQgfSBmcm9tIFwiQHRpcHRhcC9wbS9jb21tYW5kc1wiO1xudmFyIHNlbGVjdFRleHRibG9ja1N0YXJ0ID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrU3RhcnQoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9oZWxwZXJzL2NyZWF0ZURvY3VtZW50LnRzXG5mdW5jdGlvbiBjcmVhdGVEb2N1bWVudChjb250ZW50LCBzY2hlbWEsIHBhcnNlT3B0aW9ucyA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIGNyZWF0ZU5vZGVGcm9tQ29udGVudChjb250ZW50LCBzY2hlbWEsIHtcbiAgICBzbGljZTogZmFsc2UsXG4gICAgcGFyc2VPcHRpb25zLFxuICAgIGVycm9yT25JbnZhbGlkQ29udGVudDogb3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnRcbiAgfSk7XG59XG5cbi8vIHNyYy9jb21tYW5kcy9zZXRDb250ZW50LnRzXG52YXIgc2V0Q29udGVudCA9IChjb250ZW50LCB7IGVycm9yT25JbnZhbGlkQ29udGVudCwgZW1pdFVwZGF0ZSA9IHRydWUsIHBhcnNlT3B0aW9ucyA9IHt9IH0gPSB7fSkgPT4gKHsgZWRpdG9yLCB0ciwgZGlzcGF0Y2gsIGNvbW1hbmRzIH0pID0+IHtcbiAgY29uc3QgeyBkb2MgfSA9IHRyO1xuICBpZiAocGFyc2VPcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSAhPT0gXCJmdWxsXCIpIHtcbiAgICBjb25zdCBkb2N1bWVudDIgPSBjcmVhdGVEb2N1bWVudChjb250ZW50LCBlZGl0b3Iuc2NoZW1hLCBwYXJzZU9wdGlvbnMsIHtcbiAgICAgIGVycm9yT25JbnZhbGlkQ29udGVudDogZXJyb3JPbkludmFsaWRDb250ZW50ICE9IG51bGwgPyBlcnJvck9uSW52YWxpZENvbnRlbnQgOiBlZGl0b3Iub3B0aW9ucy5lbmFibGVDb250ZW50Q2hlY2tcbiAgICB9KTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIHRyLnJlcGxhY2VXaXRoKDAsIGRvYy5jb250ZW50LnNpemUsIGRvY3VtZW50Mikuc2V0TWV0YShcInByZXZlbnRVcGRhdGVcIiwgIWVtaXRVcGRhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB0ci5zZXRNZXRhKFwicHJldmVudFVwZGF0ZVwiLCAhZW1pdFVwZGF0ZSk7XG4gIH1cbiAgcmV0dXJuIGNvbW1hbmRzLmluc2VydENvbnRlbnRBdCh7IGZyb206IDAsIHRvOiBkb2MuY29udGVudC5zaXplIH0sIGNvbnRlbnQsIHtcbiAgICBwYXJzZU9wdGlvbnMsXG4gICAgZXJyb3JPbkludmFsaWRDb250ZW50OiBlcnJvck9uSW52YWxpZENvbnRlbnQgIT0gbnVsbCA/IGVycm9yT25JbnZhbGlkQ29udGVudCA6IGVkaXRvci5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVja1xuICB9KTtcbn07XG5cbi8vIHNyYy9oZWxwZXJzL2dldE1hcmtBdHRyaWJ1dGVzLnRzXG5mdW5jdGlvbiBnZXRNYXJrQXR0cmlidXRlcyhzdGF0ZSwgdHlwZU9yTmFtZSkge1xuICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgY29uc3QgeyBmcm9tLCB0bywgZW1wdHkgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgY29uc3QgbWFya3MgPSBbXTtcbiAgaWYgKGVtcHR5KSB7XG4gICAgaWYgKHN0YXRlLnN0b3JlZE1hcmtzKSB7XG4gICAgICBtYXJrcy5wdXNoKC4uLnN0YXRlLnN0b3JlZE1hcmtzKTtcbiAgICB9XG4gICAgbWFya3MucHVzaCguLi5zdGF0ZS5zZWxlY3Rpb24uJGhlYWQubWFya3MoKSk7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUpID0+IHtcbiAgICAgIG1hcmtzLnB1c2goLi4ubm9kZS5tYXJrcyk7XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbWFyayA9IG1hcmtzLmZpbmQoKG1hcmtJdGVtKSA9PiBtYXJrSXRlbS50eXBlLm5hbWUgPT09IHR5cGUubmFtZSk7XG4gIGlmICghbWFyaykge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4geyAuLi5tYXJrLmF0dHJzIH07XG59XG5cbi8vIHNyYy9oZWxwZXJzL2NvbWJpbmVUcmFuc2FjdGlvblN0ZXBzLnRzXG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tIFwiQHRpcHRhcC9wbS90cmFuc2Zvcm1cIjtcbmZ1bmN0aW9uIGNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzKG9sZERvYywgdHJhbnNhY3Rpb25zKSB7XG4gIGNvbnN0IHRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0ob2xkRG9jKTtcbiAgdHJhbnNhY3Rpb25zLmZvckVhY2goKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgdHJhbnNhY3Rpb24uc3RlcHMuZm9yRWFjaCgoc3RlcCkgPT4ge1xuICAgICAgdHJhbnNmb3JtLnN0ZXAoc3RlcCk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG4vLyBzcmMvaGVscGVycy9kZWZhdWx0QmxvY2tBdC50c1xuZnVuY3Rpb24gZGVmYXVsdEJsb2NrQXQobWF0Y2gpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5lZGdlQ291bnQ7IGkgKz0gMSkge1xuICAgIGNvbnN0IHsgdHlwZSB9ID0gbWF0Y2guZWRnZShpKTtcbiAgICBpZiAodHlwZS5pc1RleHRibG9jayAmJiAhdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpIHtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZmluZENoaWxkcmVuLnRzXG5mdW5jdGlvbiBmaW5kQ2hpbGRyZW4obm9kZSwgcHJlZGljYXRlKSB7XG4gIGNvbnN0IG5vZGVzV2l0aFBvcyA9IFtdO1xuICBub2RlLmRlc2NlbmRhbnRzKChjaGlsZCwgcG9zKSA9PiB7XG4gICAgaWYgKHByZWRpY2F0ZShjaGlsZCkpIHtcbiAgICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcbiAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgIHBvc1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5vZGVzV2l0aFBvcztcbn1cblxuLy8gc3JjL2hlbHBlcnMvZmluZENoaWxkcmVuSW5SYW5nZS50c1xuZnVuY3Rpb24gZmluZENoaWxkcmVuSW5SYW5nZShub2RlLCByYW5nZSwgcHJlZGljYXRlKSB7XG4gIGNvbnN0IG5vZGVzV2l0aFBvcyA9IFtdO1xuICBub2RlLm5vZGVzQmV0d2VlbihyYW5nZS5mcm9tLCByYW5nZS50bywgKGNoaWxkLCBwb3MpID0+IHtcbiAgICBpZiAocHJlZGljYXRlKGNoaWxkKSkge1xuICAgICAgbm9kZXNXaXRoUG9zLnB1c2goe1xuICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgcG9zXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbm9kZXNXaXRoUG9zO1xufVxuXG4vLyBzcmMvaGVscGVycy9maW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1Bvcy50c1xuZnVuY3Rpb24gZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MoJHBvcywgcHJlZGljYXRlKSB7XG4gIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoOyBpID4gMDsgaSAtPSAxKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRwb3Mubm9kZShpKTtcbiAgICBpZiAocHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3M6IGkgPiAwID8gJHBvcy5iZWZvcmUoaSkgOiAwLFxuICAgICAgICBzdGFydDogJHBvcy5zdGFydChpKSxcbiAgICAgICAgZGVwdGg6IGksXG4gICAgICAgIG5vZGVcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9oZWxwZXJzL2ZpbmRQYXJlbnROb2RlLnRzXG5mdW5jdGlvbiBmaW5kUGFyZW50Tm9kZShwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIChzZWxlY3Rpb24pID0+IGZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zKHNlbGVjdGlvbi4kZnJvbSwgcHJlZGljYXRlKTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0RXh0ZW5zaW9uRmllbGQudHNcbmZ1bmN0aW9uIGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgZmllbGQsIGNvbnRleHQpIHtcbiAgaWYgKGV4dGVuc2lvbi5jb25maWdbZmllbGRdID09PSB2b2lkIDAgJiYgZXh0ZW5zaW9uLnBhcmVudCkge1xuICAgIHJldHVybiBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24ucGFyZW50LCBmaWVsZCwgY29udGV4dCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBleHRlbnNpb24uY29uZmlnW2ZpZWxkXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3QgdmFsdWUgPSBleHRlbnNpb24uY29uZmlnW2ZpZWxkXS5iaW5kKHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICBwYXJlbnQ6IGV4dGVuc2lvbi5wYXJlbnQgPyBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24ucGFyZW50LCBmaWVsZCwgY29udGV4dCkgOiBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBleHRlbnNpb24uY29uZmlnW2ZpZWxkXTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZmxhdHRlbkV4dGVuc2lvbnMudHNcbmZ1bmN0aW9uIGZsYXR0ZW5FeHRlbnNpb25zKGV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIGV4dGVuc2lvbnMubWFwKChleHRlbnNpb24pID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlXG4gICAgfTtcbiAgICBjb25zdCBhZGRFeHRlbnNpb25zID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImFkZEV4dGVuc2lvbnNcIiwgY29udGV4dCk7XG4gICAgaWYgKGFkZEV4dGVuc2lvbnMpIHtcbiAgICAgIHJldHVybiBbZXh0ZW5zaW9uLCAuLi5mbGF0dGVuRXh0ZW5zaW9ucyhhZGRFeHRlbnNpb25zKCkpXTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuc2lvbjtcbiAgfSkuZmxhdCgxMCk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dlbmVyYXRlSFRNTC50c1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gXCJAdGlwdGFwL3BtL21vZGVsXCI7XG5cbi8vIHNyYy9oZWxwZXJzL2dldEhUTUxGcm9tRnJhZ21lbnQudHNcbmltcG9ydCB7IERPTVNlcmlhbGl6ZXIgfSBmcm9tIFwiQHRpcHRhcC9wbS9tb2RlbFwiO1xuZnVuY3Rpb24gZ2V0SFRNTEZyb21GcmFnbWVudChmcmFnbWVudCwgc2NoZW1hKSB7XG4gIGNvbnN0IGRvY3VtZW50RnJhZ21lbnQgPSBET01TZXJpYWxpemVyLmZyb21TY2hlbWEoc2NoZW1hKS5zZXJpYWxpemVGcmFnbWVudChmcmFnbWVudCk7XG4gIGNvbnN0IHRlbXBvcmFyeURvY3VtZW50ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCk7XG4gIGNvbnN0IGNvbnRhaW5lciA9IHRlbXBvcmFyeURvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChkb2N1bWVudEZyYWdtZW50KTtcbiAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUw7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zLnRzXG5pbXBvcnQgeyBTY2hlbWEgYXMgU2NoZW1hMiB9IGZyb20gXCJAdGlwdGFwL3BtL21vZGVsXCI7XG5cbi8vIHNyYy91dGlsaXRpZXMvaXNGdW5jdGlvbi50c1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLnRzXG5mdW5jdGlvbiBjYWxsT3JSZXR1cm4odmFsdWUsIGNvbnRleHQgPSB2b2lkIDAsIC4uLnByb3BzKSB7XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdmFsdWUuYmluZChjb250ZXh0KSguLi5wcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSguLi5wcm9wcyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL2lzRW1wdHlPYmplY3QudHNcbmZ1bmN0aW9uIGlzRW1wdHlPYmplY3QodmFsdWUgPSB7fSkge1xuICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMCAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufVxuXG4vLyBzcmMvaGVscGVycy9zcGxpdEV4dGVuc2lvbnMudHNcbmZ1bmN0aW9uIHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKSB7XG4gIGNvbnN0IGJhc2VFeHRlbnNpb25zID0gZXh0ZW5zaW9ucy5maWx0ZXIoKGV4dGVuc2lvbikgPT4gZXh0ZW5zaW9uLnR5cGUgPT09IFwiZXh0ZW5zaW9uXCIpO1xuICBjb25zdCBub2RlRXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMuZmlsdGVyKChleHRlbnNpb24pID0+IGV4dGVuc2lvbi50eXBlID09PSBcIm5vZGVcIik7XG4gIGNvbnN0IG1hcmtFeHRlbnNpb25zID0gZXh0ZW5zaW9ucy5maWx0ZXIoKGV4dGVuc2lvbikgPT4gZXh0ZW5zaW9uLnR5cGUgPT09IFwibWFya1wiKTtcbiAgcmV0dXJuIHtcbiAgICBiYXNlRXh0ZW5zaW9ucyxcbiAgICBub2RlRXh0ZW5zaW9ucyxcbiAgICBtYXJrRXh0ZW5zaW9uc1xuICB9O1xufVxuXG4vLyBzcmMvaGVscGVycy9nZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMudHNcbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyhleHRlbnNpb25zKSB7XG4gIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBbXTtcbiAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucywgbWFya0V4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgY29uc3Qgbm9kZUFuZE1hcmtFeHRlbnNpb25zID0gWy4uLm5vZGVFeHRlbnNpb25zLCAuLi5tYXJrRXh0ZW5zaW9uc107XG4gIGNvbnN0IGRlZmF1bHRBdHRyaWJ1dGUgPSB7XG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICB2YWxpZGF0ZTogdm9pZCAwLFxuICAgIHJlbmRlcmVkOiB0cnVlLFxuICAgIHJlbmRlckhUTUw6IG51bGwsXG4gICAgcGFyc2VIVE1MOiBudWxsLFxuICAgIGtlZXBPblNwbGl0OiB0cnVlLFxuICAgIGlzUmVxdWlyZWQ6IGZhbHNlXG4gIH07XG4gIGV4dGVuc2lvbnMuZm9yRWFjaCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgIGV4dGVuc2lvbnM6IG5vZGVBbmRNYXJrRXh0ZW5zaW9uc1xuICAgIH07XG4gICAgY29uc3QgYWRkR2xvYmFsQXR0cmlidXRlcyA9IGdldEV4dGVuc2lvbkZpZWxkKFxuICAgICAgZXh0ZW5zaW9uLFxuICAgICAgXCJhZGRHbG9iYWxBdHRyaWJ1dGVzXCIsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICBpZiAoIWFkZEdsb2JhbEF0dHJpYnV0ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZ2xvYmFsQXR0cmlidXRlcyA9IGFkZEdsb2JhbEF0dHJpYnV0ZXMoKTtcbiAgICBnbG9iYWxBdHRyaWJ1dGVzLmZvckVhY2goKGdsb2JhbEF0dHJpYnV0ZSkgPT4ge1xuICAgICAgZ2xvYmFsQXR0cmlidXRlLnR5cGVzLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoZ2xvYmFsQXR0cmlidXRlLmF0dHJpYnV0ZXMpLmZvckVhY2goKFtuYW1lLCBhdHRyaWJ1dGVdKSA9PiB7XG4gICAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgYXR0cmlidXRlOiB7XG4gICAgICAgICAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGUsXG4gICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgbm9kZUFuZE1hcmtFeHRlbnNpb25zLmZvckVhY2goKGV4dGVuc2lvbikgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2VcbiAgICB9O1xuICAgIGNvbnN0IGFkZEF0dHJpYnV0ZXMgPSBnZXRFeHRlbnNpb25GaWVsZChcbiAgICAgIGV4dGVuc2lvbixcbiAgICAgIFwiYWRkQXR0cmlidXRlc1wiLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgaWYgKCFhZGRBdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBhZGRBdHRyaWJ1dGVzKCk7XG4gICAgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykuZm9yRWFjaCgoW25hbWUsIGF0dHJpYnV0ZV0pID0+IHtcbiAgICAgIGNvbnN0IG1lcmdlZEF0dHIgPSB7XG4gICAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGUsXG4gICAgICAgIC4uLmF0dHJpYnV0ZVxuICAgICAgfTtcbiAgICAgIGlmICh0eXBlb2YgKG1lcmdlZEF0dHIgPT0gbnVsbCA/IHZvaWQgMCA6IG1lcmdlZEF0dHIuZGVmYXVsdCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBtZXJnZWRBdHRyLmRlZmF1bHQgPSBtZXJnZWRBdHRyLmRlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIGlmICgobWVyZ2VkQXR0ciA9PSBudWxsID8gdm9pZCAwIDogbWVyZ2VkQXR0ci5pc1JlcXVpcmVkKSAmJiAobWVyZ2VkQXR0ciA9PSBudWxsID8gdm9pZCAwIDogbWVyZ2VkQXR0ci5kZWZhdWx0KSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlbGV0ZSBtZXJnZWRBdHRyLmRlZmF1bHQ7XG4gICAgICB9XG4gICAgICBleHRlbnNpb25BdHRyaWJ1dGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgYXR0cmlidXRlOiBtZXJnZWRBdHRyXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBleHRlbnNpb25BdHRyaWJ1dGVzO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL21lcmdlQXR0cmlidXRlcy50c1xuZnVuY3Rpb24gbWVyZ2VBdHRyaWJ1dGVzKC4uLm9iamVjdHMpIHtcbiAgcmV0dXJuIG9iamVjdHMuZmlsdGVyKChpdGVtKSA9PiAhIWl0ZW0pLnJlZHVjZSgoaXRlbXMsIGl0ZW0pID0+IHtcbiAgICBjb25zdCBtZXJnZWRBdHRyaWJ1dGVzID0geyAuLi5pdGVtcyB9O1xuICAgIE9iamVjdC5lbnRyaWVzKGl0ZW0pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgY29uc3QgZXhpc3RzID0gbWVyZ2VkQXR0cmlidXRlc1trZXldO1xuICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09IFwiY2xhc3NcIikge1xuICAgICAgICBjb25zdCB2YWx1ZUNsYXNzZXMgPSB2YWx1ZSA/IFN0cmluZyh2YWx1ZSkuc3BsaXQoXCIgXCIpIDogW107XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ2xhc3NlcyA9IG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA/IG1lcmdlZEF0dHJpYnV0ZXNba2V5XS5zcGxpdChcIiBcIikgOiBbXTtcbiAgICAgICAgY29uc3QgaW5zZXJ0Q2xhc3NlcyA9IHZhbHVlQ2xhc3Nlcy5maWx0ZXIoKHZhbHVlQ2xhc3MpID0+ICFleGlzdGluZ0NsYXNzZXMuaW5jbHVkZXModmFsdWVDbGFzcykpO1xuICAgICAgICBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPSBbLi4uZXhpc3RpbmdDbGFzc2VzLCAuLi5pbnNlcnRDbGFzc2VzXS5qb2luKFwiIFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInN0eWxlXCIpIHtcbiAgICAgICAgY29uc3QgbmV3U3R5bGVzID0gdmFsdWUgPyB2YWx1ZS5zcGxpdChcIjtcIikubWFwKChzdHlsZTIpID0+IHN0eWxlMi50cmltKCkpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgICAgICBjb25zdCBleGlzdGluZ1N0eWxlcyA9IG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA/IG1lcmdlZEF0dHJpYnV0ZXNba2V5XS5zcGxpdChcIjtcIikubWFwKChzdHlsZTIpID0+IHN0eWxlMi50cmltKCkpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgICAgICBjb25zdCBzdHlsZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGV4aXN0aW5nU3R5bGVzLmZvckVhY2goKHN0eWxlMikgPT4ge1xuICAgICAgICAgIGNvbnN0IFtwcm9wZXJ0eSwgdmFsXSA9IHN0eWxlMi5zcGxpdChcIjpcIikubWFwKChwYXJ0KSA9PiBwYXJ0LnRyaW0oKSk7XG4gICAgICAgICAgc3R5bGVNYXAuc2V0KHByb3BlcnR5LCB2YWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgbmV3U3R5bGVzLmZvckVhY2goKHN0eWxlMikgPT4ge1xuICAgICAgICAgIGNvbnN0IFtwcm9wZXJ0eSwgdmFsXSA9IHN0eWxlMi5zcGxpdChcIjpcIikubWFwKChwYXJ0KSA9PiBwYXJ0LnRyaW0oKSk7XG4gICAgICAgICAgc3R5bGVNYXAuc2V0KHByb3BlcnR5LCB2YWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gQXJyYXkuZnJvbShzdHlsZU1hcC5lbnRyaWVzKCkpLm1hcCgoW3Byb3BlcnR5LCB2YWxdKSA9PiBgJHtwcm9wZXJ0eX06ICR7dmFsfWApLmpvaW4oXCI7IFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtZXJnZWRBdHRyaWJ1dGVzO1xuICB9LCB7fSk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dldFJlbmRlcmVkQXR0cmlidXRlcy50c1xuZnVuY3Rpb24gZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKG5vZGVPck1hcmssIGV4dGVuc2lvbkF0dHJpYnV0ZXMpIHtcbiAgcmV0dXJuIGV4dGVuc2lvbkF0dHJpYnV0ZXMuZmlsdGVyKChhdHRyaWJ1dGUpID0+IGF0dHJpYnV0ZS50eXBlID09PSBub2RlT3JNYXJrLnR5cGUubmFtZSkuZmlsdGVyKChpdGVtKSA9PiBpdGVtLmF0dHJpYnV0ZS5yZW5kZXJlZCkubWFwKChpdGVtKSA9PiB7XG4gICAgaWYgKCFpdGVtLmF0dHJpYnV0ZS5yZW5kZXJIVE1MKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbaXRlbS5uYW1lXTogbm9kZU9yTWFyay5hdHRyc1tpdGVtLm5hbWVdXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gaXRlbS5hdHRyaWJ1dGUucmVuZGVySFRNTChub2RlT3JNYXJrLmF0dHJzKSB8fCB7fTtcbiAgfSkucmVkdWNlKChhdHRyaWJ1dGVzLCBhdHRyaWJ1dGUpID0+IG1lcmdlQXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBhdHRyaWJ1dGUpLCB7fSk7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvZnJvbVN0cmluZy50c1xuZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZS5tYXRjaCgvXlsrLV0/KD86XFxkKlxcLik/XFxkKyQvKSkge1xuICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gXCJ0cnVlXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT09IFwiZmFsc2VcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2luamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZS50c1xuZnVuY3Rpb24gaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlKHBhcnNlUnVsZSwgZXh0ZW5zaW9uQXR0cmlidXRlcykge1xuICBpZiAoXCJzdHlsZVwiIGluIHBhcnNlUnVsZSkge1xuICAgIHJldHVybiBwYXJzZVJ1bGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5wYXJzZVJ1bGUsXG4gICAgZ2V0QXR0cnM6IChub2RlKSA9PiB7XG4gICAgICBjb25zdCBvbGRBdHRyaWJ1dGVzID0gcGFyc2VSdWxlLmdldEF0dHJzID8gcGFyc2VSdWxlLmdldEF0dHJzKG5vZGUpIDogcGFyc2VSdWxlLmF0dHJzO1xuICAgICAgaWYgKG9sZEF0dHJpYnV0ZXMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBleHRlbnNpb25BdHRyaWJ1dGVzLnJlZHVjZSgoaXRlbXMsIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpdGVtLmF0dHJpYnV0ZS5wYXJzZUhUTUwgPyBpdGVtLmF0dHJpYnV0ZS5wYXJzZUhUTUwobm9kZSkgOiBmcm9tU3RyaW5nKG5vZGUuZ2V0QXR0cmlidXRlKGl0ZW0ubmFtZSkpO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLml0ZW1zLFxuICAgICAgICAgIFtpdGVtLm5hbWVdOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSwge30pO1xuICAgICAgcmV0dXJuIHsgLi4ub2xkQXR0cmlidXRlcywgLi4ubmV3QXR0cmlidXRlcyB9O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMudHNcbmZ1bmN0aW9uIGNsZWFuVXBTY2hlbWFJdGVtKGRhdGEpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgT2JqZWN0LmVudHJpZXMoZGF0YSkuZmlsdGVyKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmIChrZXkgPT09IFwiYXR0cnNcIiAmJiBpc0VtcHR5T2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMDtcbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMoZXh0ZW5zaW9ucywgZWRpdG9yKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgYWxsQXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucywgbWFya0V4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgY29uc3QgdG9wTm9kZSA9IChfYSA9IG5vZGVFeHRlbnNpb25zLmZpbmQoKGV4dGVuc2lvbikgPT4gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcInRvcE5vZGVcIikpKSA9PSBudWxsID8gdm9pZCAwIDogX2EubmFtZTtcbiAgY29uc3Qgbm9kZXMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgbm9kZUV4dGVuc2lvbnMubWFwKChleHRlbnNpb24pID0+IHtcbiAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBhbGxBdHRyaWJ1dGVzLmZpbHRlcigoYXR0cmlidXRlKSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gZXh0ZW5zaW9uLm5hbWUpO1xuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9O1xuICAgICAgY29uc3QgZXh0cmFOb2RlRmllbGRzID0gZXh0ZW5zaW9ucy5yZWR1Y2UoKGZpZWxkcywgZSkgPT4ge1xuICAgICAgICBjb25zdCBleHRlbmROb2RlU2NoZW1hID0gZ2V0RXh0ZW5zaW9uRmllbGQoZSwgXCJleHRlbmROb2RlU2NoZW1hXCIsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAuLi5leHRlbmROb2RlU2NoZW1hID8gZXh0ZW5kTm9kZVNjaGVtYShleHRlbnNpb24pIDoge31cbiAgICAgICAgfTtcbiAgICAgIH0sIHt9KTtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IGNsZWFuVXBTY2hlbWFJdGVtKHtcbiAgICAgICAgLi4uZXh0cmFOb2RlRmllbGRzLFxuICAgICAgICBjb250ZW50OiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImNvbnRlbnRcIiwgY29udGV4dCkpLFxuICAgICAgICBtYXJrczogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJtYXJrc1wiLCBjb250ZXh0KSksXG4gICAgICAgIGdyb3VwOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImdyb3VwXCIsIGNvbnRleHQpKSxcbiAgICAgICAgaW5saW5lOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImlubGluZVwiLCBjb250ZXh0KSksXG4gICAgICAgIGF0b206IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwiYXRvbVwiLCBjb250ZXh0KSksXG4gICAgICAgIHNlbGVjdGFibGU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwic2VsZWN0YWJsZVwiLCBjb250ZXh0KSksXG4gICAgICAgIGRyYWdnYWJsZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJkcmFnZ2FibGVcIiwgY29udGV4dCkpLFxuICAgICAgICBjb2RlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImNvZGVcIiwgY29udGV4dCkpLFxuICAgICAgICB3aGl0ZXNwYWNlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcIndoaXRlc3BhY2VcIiwgY29udGV4dCkpLFxuICAgICAgICBsaW5lYnJlYWtSZXBsYWNlbWVudDogY2FsbE9yUmV0dXJuKFxuICAgICAgICAgIGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJsaW5lYnJlYWtSZXBsYWNlbWVudFwiLCBjb250ZXh0KVxuICAgICAgICApLFxuICAgICAgICBkZWZpbmluZzogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJkZWZpbmluZ1wiLCBjb250ZXh0KSksXG4gICAgICAgIGlzb2xhdGluZzogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJpc29sYXRpbmdcIiwgY29udGV4dCkpLFxuICAgICAgICBhdHRyczogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgIGV4dGVuc2lvbkF0dHJpYnV0ZXMubWFwKChleHRlbnNpb25BdHRyaWJ1dGUpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlLm5hbWUsXG4gICAgICAgICAgICAgIHsgZGVmYXVsdDogKF9hMiA9IGV4dGVuc2lvbkF0dHJpYnV0ZSA9PSBudWxsID8gdm9pZCAwIDogZXh0ZW5zaW9uQXR0cmlidXRlLmF0dHJpYnV0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5kZWZhdWx0LCB2YWxpZGF0ZTogKF9iID0gZXh0ZW5zaW9uQXR0cmlidXRlID09IG51bGwgPyB2b2lkIDAgOiBleHRlbnNpb25BdHRyaWJ1dGUuYXR0cmlidXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2IudmFsaWRhdGUgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHBhcnNlSFRNTCA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwicGFyc2VIVE1MXCIsIGNvbnRleHQpKTtcbiAgICAgIGlmIChwYXJzZUhUTUwpIHtcbiAgICAgICAgc2NoZW1hLnBhcnNlRE9NID0gcGFyc2VIVE1MLm1hcChcbiAgICAgICAgICAocGFyc2VSdWxlKSA9PiBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUocGFyc2VSdWxlLCBleHRlbnNpb25BdHRyaWJ1dGVzKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVuZGVySFRNTCA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJyZW5kZXJIVE1MXCIsIGNvbnRleHQpO1xuICAgICAgaWYgKHJlbmRlckhUTUwpIHtcbiAgICAgICAgc2NoZW1hLnRvRE9NID0gKG5vZGUpID0+IHJlbmRlckhUTUwoe1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IGdldFJlbmRlcmVkQXR0cmlidXRlcyhub2RlLCBleHRlbnNpb25BdHRyaWJ1dGVzKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbmRlclRleHQgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwicmVuZGVyVGV4dFwiLCBjb250ZXh0KTtcbiAgICAgIGlmIChyZW5kZXJUZXh0KSB7XG4gICAgICAgIHNjaGVtYS50b1RleHQgPSByZW5kZXJUZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtleHRlbnNpb24ubmFtZSwgc2NoZW1hXTtcbiAgICB9KVxuICApO1xuICBjb25zdCBtYXJrcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBtYXJrRXh0ZW5zaW9ucy5tYXAoKGV4dGVuc2lvbikgPT4ge1xuICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGFsbEF0dHJpYnV0ZXMuZmlsdGVyKChhdHRyaWJ1dGUpID0+IGF0dHJpYnV0ZS50eXBlID09PSBleHRlbnNpb24ubmFtZSk7XG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICBlZGl0b3JcbiAgICAgIH07XG4gICAgICBjb25zdCBleHRyYU1hcmtGaWVsZHMgPSBleHRlbnNpb25zLnJlZHVjZSgoZmllbGRzLCBlKSA9PiB7XG4gICAgICAgIGNvbnN0IGV4dGVuZE1hcmtTY2hlbWEgPSBnZXRFeHRlbnNpb25GaWVsZChlLCBcImV4dGVuZE1hcmtTY2hlbWFcIiwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgIC4uLmV4dGVuZE1hcmtTY2hlbWEgPyBleHRlbmRNYXJrU2NoZW1hKGV4dGVuc2lvbikgOiB7fVxuICAgICAgICB9O1xuICAgICAgfSwge30pO1xuICAgICAgY29uc3Qgc2NoZW1hID0gY2xlYW5VcFNjaGVtYUl0ZW0oe1xuICAgICAgICAuLi5leHRyYU1hcmtGaWVsZHMsXG4gICAgICAgIGluY2x1c2l2ZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJpbmNsdXNpdmVcIiwgY29udGV4dCkpLFxuICAgICAgICBleGNsdWRlczogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJleGNsdWRlc1wiLCBjb250ZXh0KSksXG4gICAgICAgIGdyb3VwOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImdyb3VwXCIsIGNvbnRleHQpKSxcbiAgICAgICAgc3Bhbm5pbmc6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwic3Bhbm5pbmdcIiwgY29udGV4dCkpLFxuICAgICAgICBjb2RlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImNvZGVcIiwgY29udGV4dCkpLFxuICAgICAgICBhdHRyczogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgIGV4dGVuc2lvbkF0dHJpYnV0ZXMubWFwKChleHRlbnNpb25BdHRyaWJ1dGUpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlLm5hbWUsXG4gICAgICAgICAgICAgIHsgZGVmYXVsdDogKF9hMiA9IGV4dGVuc2lvbkF0dHJpYnV0ZSA9PSBudWxsID8gdm9pZCAwIDogZXh0ZW5zaW9uQXR0cmlidXRlLmF0dHJpYnV0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5kZWZhdWx0LCB2YWxpZGF0ZTogKF9iID0gZXh0ZW5zaW9uQXR0cmlidXRlID09IG51bGwgPyB2b2lkIDAgOiBleHRlbnNpb25BdHRyaWJ1dGUuYXR0cmlidXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2IudmFsaWRhdGUgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHBhcnNlSFRNTCA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwicGFyc2VIVE1MXCIsIGNvbnRleHQpKTtcbiAgICAgIGlmIChwYXJzZUhUTUwpIHtcbiAgICAgICAgc2NoZW1hLnBhcnNlRE9NID0gcGFyc2VIVE1MLm1hcChcbiAgICAgICAgICAocGFyc2VSdWxlKSA9PiBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUocGFyc2VSdWxlLCBleHRlbnNpb25BdHRyaWJ1dGVzKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVuZGVySFRNTCA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJyZW5kZXJIVE1MXCIsIGNvbnRleHQpO1xuICAgICAgaWYgKHJlbmRlckhUTUwpIHtcbiAgICAgICAgc2NoZW1hLnRvRE9NID0gKG1hcmspID0+IHJlbmRlckhUTUwoe1xuICAgICAgICAgIG1hcmssXG4gICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IGdldFJlbmRlcmVkQXR0cmlidXRlcyhtYXJrLCBleHRlbnNpb25BdHRyaWJ1dGVzKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIHNjaGVtYV07XG4gICAgfSlcbiAgKTtcbiAgcmV0dXJuIG5ldyBTY2hlbWEyKHtcbiAgICB0b3BOb2RlLFxuICAgIG5vZGVzLFxuICAgIG1hcmtzXG4gIH0pO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL2ZpbmREdXBsaWNhdGVzLnRzXG5mdW5jdGlvbiBmaW5kRHVwbGljYXRlcyhpdGVtcykge1xuICBjb25zdCBmaWx0ZXJlZCA9IGl0ZW1zLmZpbHRlcigoZWwsIGluZGV4KSA9PiBpdGVtcy5pbmRleE9mKGVsKSAhPT0gaW5kZXgpO1xuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGZpbHRlcmVkKSk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL3NvcnRFeHRlbnNpb25zLnRzXG5mdW5jdGlvbiBzb3J0RXh0ZW5zaW9ucyhleHRlbnNpb25zKSB7XG4gIGNvbnN0IGRlZmF1bHRQcmlvcml0eSA9IDEwMDtcbiAgcmV0dXJuIGV4dGVuc2lvbnMuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHByaW9yaXR5QSA9IGdldEV4dGVuc2lvbkZpZWxkKGEsIFwicHJpb3JpdHlcIikgfHwgZGVmYXVsdFByaW9yaXR5O1xuICAgIGNvbnN0IHByaW9yaXR5QiA9IGdldEV4dGVuc2lvbkZpZWxkKGIsIFwicHJpb3JpdHlcIikgfHwgZGVmYXVsdFByaW9yaXR5O1xuICAgIGlmIChwcmlvcml0eUEgPiBwcmlvcml0eUIpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKHByaW9yaXR5QSA8IHByaW9yaXR5Qikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9KTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvcmVzb2x2ZUV4dGVuc2lvbnMudHNcbmZ1bmN0aW9uIHJlc29sdmVFeHRlbnNpb25zKGV4dGVuc2lvbnMpIHtcbiAgY29uc3QgcmVzb2x2ZWRFeHRlbnNpb25zID0gc29ydEV4dGVuc2lvbnMoZmxhdHRlbkV4dGVuc2lvbnMoZXh0ZW5zaW9ucykpO1xuICBjb25zdCBkdXBsaWNhdGVkTmFtZXMgPSBmaW5kRHVwbGljYXRlcyhyZXNvbHZlZEV4dGVuc2lvbnMubWFwKChleHRlbnNpb24pID0+IGV4dGVuc2lvbi5uYW1lKSk7XG4gIGlmIChkdXBsaWNhdGVkTmFtZXMubGVuZ3RoKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYFt0aXB0YXAgd2Fybl06IER1cGxpY2F0ZSBleHRlbnNpb24gbmFtZXMgZm91bmQ6IFske2R1cGxpY2F0ZWROYW1lcy5tYXAoKGl0ZW0pID0+IGAnJHtpdGVtfSdgKS5qb2luKFwiLCBcIil9XS4gVGhpcyBjYW4gbGVhZCB0byBpc3N1ZXMuYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc29sdmVkRXh0ZW5zaW9ucztcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0U2NoZW1hLnRzXG5mdW5jdGlvbiBnZXRTY2hlbWEoZXh0ZW5zaW9ucywgZWRpdG9yKSB7XG4gIGNvbnN0IHJlc29sdmVkRXh0ZW5zaW9ucyA9IHJlc29sdmVFeHRlbnNpb25zKGV4dGVuc2lvbnMpO1xuICByZXR1cm4gZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMocmVzb2x2ZWRFeHRlbnNpb25zLCBlZGl0b3IpO1xufVxuXG4vLyBzcmMvaGVscGVycy9nZW5lcmF0ZUhUTUwudHNcbmZ1bmN0aW9uIGdlbmVyYXRlSFRNTChkb2MsIGV4dGVuc2lvbnMpIHtcbiAgY29uc3Qgc2NoZW1hID0gZ2V0U2NoZW1hKGV4dGVuc2lvbnMpO1xuICBjb25zdCBjb250ZW50Tm9kZSA9IE5vZGUuZnJvbUpTT04oc2NoZW1hLCBkb2MpO1xuICByZXR1cm4gZ2V0SFRNTEZyb21GcmFnbWVudChjb250ZW50Tm9kZS5jb250ZW50LCBzY2hlbWEpO1xufVxuXG4vLyBzcmMvaGVscGVycy9nZW5lcmF0ZUpTT04udHNcbmltcG9ydCB7IERPTVBhcnNlciBhcyBET01QYXJzZXIyIH0gZnJvbSBcIkB0aXB0YXAvcG0vbW9kZWxcIjtcbmZ1bmN0aW9uIGdlbmVyYXRlSlNPTihodG1sLCBleHRlbnNpb25zKSB7XG4gIGNvbnN0IHNjaGVtYSA9IGdldFNjaGVtYShleHRlbnNpb25zKTtcbiAgY29uc3QgZG9tID0gZWxlbWVudEZyb21TdHJpbmcoaHRtbCk7XG4gIHJldHVybiBET01QYXJzZXIyLmZyb21TY2hlbWEoc2NoZW1hKS5wYXJzZShkb20pLnRvSlNPTigpO1xufVxuXG4vLyBzcmMvaGVscGVycy9nZW5lcmF0ZVRleHQudHNcbmltcG9ydCB7IE5vZGUgYXMgTm9kZTIgfSBmcm9tIFwiQHRpcHRhcC9wbS9tb2RlbFwiO1xuXG4vLyBzcmMvaGVscGVycy9nZXRUZXh0QmV0d2Vlbi50c1xuZnVuY3Rpb24gZ2V0VGV4dEJldHdlZW4oc3RhcnROb2RlLCByYW5nZSwgb3B0aW9ucykge1xuICBjb25zdCB7IGZyb20sIHRvIH0gPSByYW5nZTtcbiAgY29uc3QgeyBibG9ja1NlcGFyYXRvciA9IFwiXFxuXFxuXCIsIHRleHRTZXJpYWxpemVycyA9IHt9IH0gPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgdGV4dCA9IFwiXCI7XG4gIHN0YXJ0Tm9kZS5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MsIHBhcmVudCwgaW5kZXgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKG5vZGUuaXNCbG9jayAmJiBwb3MgPiBmcm9tKSB7XG4gICAgICB0ZXh0ICs9IGJsb2NrU2VwYXJhdG9yO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0U2VyaWFsaXplciA9IHRleHRTZXJpYWxpemVycyA9PSBudWxsID8gdm9pZCAwIDogdGV4dFNlcmlhbGl6ZXJzW25vZGUudHlwZS5uYW1lXTtcbiAgICBpZiAodGV4dFNlcmlhbGl6ZXIpIHtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgdGV4dCArPSB0ZXh0U2VyaWFsaXplcih7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBwb3MsXG4gICAgICAgICAgcGFyZW50LFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIHJhbmdlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgIHRleHQgKz0gKF9hID0gbm9kZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZS50ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2xpY2UoTWF0aC5tYXgoZnJvbSwgcG9zKSAtIHBvcywgdG8gLSBwb3MpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0ZXh0O1xufVxuXG4vLyBzcmMvaGVscGVycy9nZXRUZXh0LnRzXG5mdW5jdGlvbiBnZXRUZXh0KG5vZGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmFuZ2UgPSB7XG4gICAgZnJvbTogMCxcbiAgICB0bzogbm9kZS5jb250ZW50LnNpemVcbiAgfTtcbiAgcmV0dXJuIGdldFRleHRCZXR3ZWVuKG5vZGUsIHJhbmdlLCBvcHRpb25zKTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYS50c1xuZnVuY3Rpb24gZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhzY2hlbWEubm9kZXMpLmZpbHRlcigoWywgbm9kZV0pID0+IG5vZGUuc3BlYy50b1RleHQpLm1hcCgoW25hbWUsIG5vZGVdKSA9PiBbbmFtZSwgbm9kZS5zcGVjLnRvVGV4dF0pXG4gICk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dlbmVyYXRlVGV4dC50c1xuZnVuY3Rpb24gZ2VuZXJhdGVUZXh0KGRvYywgZXh0ZW5zaW9ucywgb3B0aW9ucykge1xuICBjb25zdCB7IGJsb2NrU2VwYXJhdG9yID0gXCJcXG5cXG5cIiwgdGV4dFNlcmlhbGl6ZXJzID0ge30gfSA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHNjaGVtYSA9IGdldFNjaGVtYShleHRlbnNpb25zKTtcbiAgY29uc3QgY29udGVudE5vZGUgPSBOb2RlMi5mcm9tSlNPTihzY2hlbWEsIGRvYyk7XG4gIHJldHVybiBnZXRUZXh0KGNvbnRlbnROb2RlLCB7XG4gICAgYmxvY2tTZXBhcmF0b3IsXG4gICAgdGV4dFNlcmlhbGl6ZXJzOiB7XG4gICAgICAuLi5nZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hKHNjaGVtYSksXG4gICAgICAuLi50ZXh0U2VyaWFsaXplcnNcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvaGVscGVycy9nZXROb2RlQXR0cmlidXRlcy50c1xuZnVuY3Rpb24gZ2V0Tm9kZUF0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUpIHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUyKSA9PiB7XG4gICAgbm9kZXMucHVzaChub2RlMik7XG4gIH0pO1xuICBjb25zdCBub2RlID0gbm9kZXMucmV2ZXJzZSgpLmZpbmQoKG5vZGVJdGVtKSA9PiBub2RlSXRlbS50eXBlLm5hbWUgPT09IHR5cGUubmFtZSk7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4geyAuLi5ub2RlLmF0dHJzIH07XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dldEF0dHJpYnV0ZXMudHNcbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUpIHtcbiAgY29uc3Qgc2NoZW1hVHlwZSA9IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKFxuICAgIHR5cGVvZiB0eXBlT3JOYW1lID09PSBcInN0cmluZ1wiID8gdHlwZU9yTmFtZSA6IHR5cGVPck5hbWUubmFtZSxcbiAgICBzdGF0ZS5zY2hlbWFcbiAgKTtcbiAgaWYgKHNjaGVtYVR5cGUgPT09IFwibm9kZVwiKSB7XG4gICAgcmV0dXJuIGdldE5vZGVBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlT3JOYW1lKTtcbiAgfVxuICBpZiAoc2NoZW1hVHlwZSA9PT0gXCJtYXJrXCIpIHtcbiAgICByZXR1cm4gZ2V0TWFya0F0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUpO1xuICB9XG4gIHJldHVybiB7fTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9yZW1vdmVEdXBsaWNhdGVzLnRzXG5mdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVzKGFycmF5LCBieSA9IEpTT04uc3RyaW5naWZ5KSB7XG4gIGNvbnN0IHNlZW4gPSB7fTtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcigoaXRlbSkgPT4ge1xuICAgIGNvbnN0IGtleSA9IGJ5KGl0ZW0pO1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2Vlbiwga2V5KSA/IGZhbHNlIDogc2VlbltrZXldID0gdHJ1ZTtcbiAgfSk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dldENoYW5nZWRSYW5nZXMudHNcbmZ1bmN0aW9uIHNpbXBsaWZ5Q2hhbmdlZFJhbmdlcyhjaGFuZ2VzKSB7XG4gIGNvbnN0IHVuaXF1ZUNoYW5nZXMgPSByZW1vdmVEdXBsaWNhdGVzKGNoYW5nZXMpO1xuICByZXR1cm4gdW5pcXVlQ2hhbmdlcy5sZW5ndGggPT09IDEgPyB1bmlxdWVDaGFuZ2VzIDogdW5pcXVlQ2hhbmdlcy5maWx0ZXIoKGNoYW5nZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCByZXN0ID0gdW5pcXVlQ2hhbmdlcy5maWx0ZXIoKF8sIGkpID0+IGkgIT09IGluZGV4KTtcbiAgICByZXR1cm4gIXJlc3Quc29tZSgob3RoZXJDaGFuZ2UpID0+IHtcbiAgICAgIHJldHVybiBjaGFuZ2Uub2xkUmFuZ2UuZnJvbSA+PSBvdGhlckNoYW5nZS5vbGRSYW5nZS5mcm9tICYmIGNoYW5nZS5vbGRSYW5nZS50byA8PSBvdGhlckNoYW5nZS5vbGRSYW5nZS50byAmJiBjaGFuZ2UubmV3UmFuZ2UuZnJvbSA+PSBvdGhlckNoYW5nZS5uZXdSYW5nZS5mcm9tICYmIGNoYW5nZS5uZXdSYW5nZS50byA8PSBvdGhlckNoYW5nZS5uZXdSYW5nZS50bztcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRDaGFuZ2VkUmFuZ2VzKHRyYW5zZm9ybSkge1xuICBjb25zdCB7IG1hcHBpbmcsIHN0ZXBzIH0gPSB0cmFuc2Zvcm07XG4gIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgbWFwcGluZy5tYXBzLmZvckVhY2goKHN0ZXBNYXAsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcmFuZ2VzID0gW107XG4gICAgaWYgKCFzdGVwTWFwLnJhbmdlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHN0ZXBzW2luZGV4XTtcbiAgICAgIGlmIChmcm9tID09PSB2b2lkIDAgfHwgdG8gPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGVwTWFwLmZvckVhY2goKGZyb20sIHRvKSA9PiB7XG4gICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmFuZ2VzLmZvckVhY2goKHsgZnJvbSwgdG8gfSkgPT4ge1xuICAgICAgY29uc3QgbmV3U3RhcnQgPSBtYXBwaW5nLnNsaWNlKGluZGV4KS5tYXAoZnJvbSwgLTEpO1xuICAgICAgY29uc3QgbmV3RW5kID0gbWFwcGluZy5zbGljZShpbmRleCkubWFwKHRvKTtcbiAgICAgIGNvbnN0IG9sZFN0YXJ0ID0gbWFwcGluZy5pbnZlcnQoKS5tYXAobmV3U3RhcnQsIC0xKTtcbiAgICAgIGNvbnN0IG9sZEVuZCA9IG1hcHBpbmcuaW52ZXJ0KCkubWFwKG5ld0VuZCk7XG4gICAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgICBvbGRSYW5nZToge1xuICAgICAgICAgIGZyb206IG9sZFN0YXJ0LFxuICAgICAgICAgIHRvOiBvbGRFbmRcbiAgICAgICAgfSxcbiAgICAgICAgbmV3UmFuZ2U6IHtcbiAgICAgICAgICBmcm9tOiBuZXdTdGFydCxcbiAgICAgICAgICB0bzogbmV3RW5kXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHNpbXBsaWZ5Q2hhbmdlZFJhbmdlcyhjaGFuZ2VzKTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0RGVidWdKU09OLnRzXG5mdW5jdGlvbiBnZXREZWJ1Z0pTT04obm9kZSwgc3RhcnRPZmZzZXQgPSAwKSB7XG4gIGNvbnN0IGlzVG9wTm9kZSA9IG5vZGUudHlwZSA9PT0gbm9kZS50eXBlLnNjaGVtYS50b3BOb2RlVHlwZTtcbiAgY29uc3QgaW5jcmVtZW50ID0gaXNUb3BOb2RlID8gMCA6IDE7XG4gIGNvbnN0IGZyb20gPSBzdGFydE9mZnNldDtcbiAgY29uc3QgdG8gPSBmcm9tICsgbm9kZS5ub2RlU2l6ZTtcbiAgY29uc3QgbWFya3MgPSBub2RlLm1hcmtzLm1hcCgobWFyaykgPT4ge1xuICAgIGNvbnN0IG91dHB1dDIgPSB7XG4gICAgICB0eXBlOiBtYXJrLnR5cGUubmFtZVxuICAgIH07XG4gICAgaWYgKE9iamVjdC5rZXlzKG1hcmsuYXR0cnMpLmxlbmd0aCkge1xuICAgICAgb3V0cHV0Mi5hdHRycyA9IHsgLi4ubWFyay5hdHRycyB9O1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0MjtcbiAgfSk7XG4gIGNvbnN0IGF0dHJzID0geyAuLi5ub2RlLmF0dHJzIH07XG4gIGNvbnN0IG91dHB1dCA9IHtcbiAgICB0eXBlOiBub2RlLnR5cGUubmFtZSxcbiAgICBmcm9tLFxuICAgIHRvXG4gIH07XG4gIGlmIChPYmplY3Qua2V5cyhhdHRycykubGVuZ3RoKSB7XG4gICAgb3V0cHV0LmF0dHJzID0gYXR0cnM7XG4gIH1cbiAgaWYgKG1hcmtzLmxlbmd0aCkge1xuICAgIG91dHB1dC5tYXJrcyA9IG1hcmtzO1xuICB9XG4gIGlmIChub2RlLmNvbnRlbnQuY2hpbGRDb3VudCkge1xuICAgIG91dHB1dC5jb250ZW50ID0gW107XG4gICAgbm9kZS5mb3JFYWNoKChjaGlsZCwgb2Zmc2V0KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSBvdXRwdXQuY29udGVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnB1c2goZ2V0RGVidWdKU09OKGNoaWxkLCBzdGFydE9mZnNldCArIG9mZnNldCArIGluY3JlbWVudCkpO1xuICAgIH0pO1xuICB9XG4gIGlmIChub2RlLnRleHQpIHtcbiAgICBvdXRwdXQudGV4dCA9IG5vZGUudGV4dDtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vLyBzcmMvaGVscGVycy9nZXRNYXJrc0JldHdlZW4udHNcbmZ1bmN0aW9uIGdldE1hcmtzQmV0d2Vlbihmcm9tLCB0bywgZG9jKSB7XG4gIGNvbnN0IG1hcmtzID0gW107XG4gIGlmIChmcm9tID09PSB0bykge1xuICAgIGRvYy5yZXNvbHZlKGZyb20pLm1hcmtzKCkuZm9yRWFjaCgobWFyaykgPT4ge1xuICAgICAgY29uc3QgJHBvcyA9IGRvYy5yZXNvbHZlKGZyb20pO1xuICAgICAgY29uc3QgcmFuZ2UgPSBnZXRNYXJrUmFuZ2UoJHBvcywgbWFyay50eXBlKTtcbiAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgIG1hcmssXG4gICAgICAgIC4uLnJhbmdlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICBpZiAoIW5vZGUgfHwgKG5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGUubm9kZVNpemUpID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbWFya3MucHVzaChcbiAgICAgICAgLi4ubm9kZS5tYXJrcy5tYXAoKG1hcmspID0+ICh7XG4gICAgICAgICAgZnJvbTogcG9zLFxuICAgICAgICAgIHRvOiBwb3MgKyBub2RlLm5vZGVTaXplLFxuICAgICAgICAgIG1hcmtcbiAgICAgICAgfSkpXG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBtYXJrcztcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0Tm9kZUF0UG9zaXRpb24udHNcbnZhciBnZXROb2RlQXRQb3NpdGlvbiA9IChzdGF0ZSwgdHlwZU9yTmFtZSwgcG9zLCBtYXhEZXB0aCA9IDIwKSA9PiB7XG4gIGNvbnN0ICRwb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwb3MpO1xuICBsZXQgY3VycmVudERlcHRoID0gbWF4RGVwdGg7XG4gIGxldCBub2RlID0gbnVsbDtcbiAgd2hpbGUgKGN1cnJlbnREZXB0aCA+IDAgJiYgbm9kZSA9PT0gbnVsbCkge1xuICAgIGNvbnN0IGN1cnJlbnROb2RlID0gJHBvcy5ub2RlKGN1cnJlbnREZXB0aCk7XG4gICAgaWYgKChjdXJyZW50Tm9kZSA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudE5vZGUudHlwZS5uYW1lKSA9PT0gdHlwZU9yTmFtZSkge1xuICAgICAgbm9kZSA9IGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50RGVwdGggLT0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtub2RlLCBjdXJyZW50RGVwdGhdO1xufTtcblxuLy8gc3JjL2hlbHBlcnMvZ2V0U2NoZW1hVHlwZUJ5TmFtZS50c1xuZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZUJ5TmFtZShuYW1lLCBzY2hlbWEpIHtcbiAgcmV0dXJuIHNjaGVtYS5ub2Rlc1tuYW1lXSB8fCBzY2hlbWEubWFya3NbbmFtZV0gfHwgbnVsbDtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzLnRzXG5mdW5jdGlvbiBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMoZXh0ZW5zaW9uQXR0cmlidXRlcywgdHlwZU5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5maWx0ZXIoKFtuYW1lXSkgPT4ge1xuICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlID0gZXh0ZW5zaW9uQXR0cmlidXRlcy5maW5kKChpdGVtKSA9PiB7XG4gICAgICAgIHJldHVybiBpdGVtLnR5cGUgPT09IHR5cGVOYW1lICYmIGl0ZW0ubmFtZSA9PT0gbmFtZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFleHRlbnNpb25BdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4dGVuc2lvbkF0dHJpYnV0ZS5hdHRyaWJ1dGUua2VlcE9uU3BsaXQ7XG4gICAgfSlcbiAgKTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMudHNcbnZhciBnZXRUZXh0Q29udGVudEZyb21Ob2RlcyA9ICgkZnJvbSwgbWF4TWF0Y2ggPSA1MDApID0+IHtcbiAgbGV0IHRleHRCZWZvcmUgPSBcIlwiO1xuICBjb25zdCBzbGljZUVuZFBvcyA9ICRmcm9tLnBhcmVudE9mZnNldDtcbiAgJGZyb20ucGFyZW50Lm5vZGVzQmV0d2VlbihNYXRoLm1heCgwLCBzbGljZUVuZFBvcyAtIG1heE1hdGNoKSwgc2xpY2VFbmRQb3MsIChub2RlLCBwb3MsIHBhcmVudCwgaW5kZXgpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGNodW5rID0gKChfYiA9IChfYSA9IG5vZGUudHlwZS5zcGVjKS50b1RleHQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB7XG4gICAgICBub2RlLFxuICAgICAgcG9zLFxuICAgICAgcGFyZW50LFxuICAgICAgaW5kZXhcbiAgICB9KSkgfHwgbm9kZS50ZXh0Q29udGVudCB8fCBcIiVsZWFmJVwiO1xuICAgIHRleHRCZWZvcmUgKz0gbm9kZS5pc0F0b20gJiYgIW5vZGUuaXNUZXh0ID8gY2h1bmsgOiBjaHVuay5zbGljZSgwLCBNYXRoLm1heCgwLCBzbGljZUVuZFBvcyAtIHBvcykpO1xuICB9KTtcbiAgcmV0dXJuIHRleHRCZWZvcmU7XG59O1xuXG4vLyBzcmMvaGVscGVycy9pc01hcmtBY3RpdmUudHNcbmZ1bmN0aW9uIGlzTWFya0FjdGl2ZShzdGF0ZSwgdHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSB7XG4gIGNvbnN0IHsgZW1wdHksIHJhbmdlcyB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICBjb25zdCB0eXBlID0gdHlwZU9yTmFtZSA/IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSkgOiBudWxsO1xuICBpZiAoZW1wdHkpIHtcbiAgICByZXR1cm4gISEoc3RhdGUuc3RvcmVkTWFya3MgfHwgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpLmZpbHRlcigobWFyaykgPT4ge1xuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gbWFyay50eXBlLm5hbWU7XG4gICAgfSkuZmluZCgobWFyaykgPT4gb2JqZWN0SW5jbHVkZXMobWFyay5hdHRycywgYXR0cmlidXRlcywgeyBzdHJpY3Q6IGZhbHNlIH0pKTtcbiAgfVxuICBsZXQgc2VsZWN0aW9uUmFuZ2UgPSAwO1xuICBjb25zdCBtYXJrUmFuZ2VzID0gW107XG4gIHJhbmdlcy5mb3JFYWNoKCh7ICRmcm9tLCAkdG8gfSkgPT4ge1xuICAgIGNvbnN0IGZyb20gPSAkZnJvbS5wb3M7XG4gICAgY29uc3QgdG8gPSAkdG8ucG9zO1xuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgIGlmICghbm9kZS5pc1RleHQgJiYgIW5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbGF0aXZlRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcyk7XG4gICAgICBjb25zdCByZWxhdGl2ZVRvID0gTWF0aC5taW4odG8sIHBvcyArIG5vZGUubm9kZVNpemUpO1xuICAgICAgY29uc3QgcmFuZ2UyID0gcmVsYXRpdmVUbyAtIHJlbGF0aXZlRnJvbTtcbiAgICAgIHNlbGVjdGlvblJhbmdlICs9IHJhbmdlMjtcbiAgICAgIG1hcmtSYW5nZXMucHVzaChcbiAgICAgICAgLi4ubm9kZS5tYXJrcy5tYXAoKG1hcmspID0+ICh7XG4gICAgICAgICAgbWFyayxcbiAgICAgICAgICBmcm9tOiByZWxhdGl2ZUZyb20sXG4gICAgICAgICAgdG86IHJlbGF0aXZlVG9cbiAgICAgICAgfSkpXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbiAgaWYgKHNlbGVjdGlvblJhbmdlID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG1hdGNoZWRSYW5nZSA9IG1hcmtSYW5nZXMuZmlsdGVyKChtYXJrUmFuZ2UpID0+IHtcbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZS5uYW1lID09PSBtYXJrUmFuZ2UubWFyay50eXBlLm5hbWU7XG4gIH0pLmZpbHRlcigobWFya1JhbmdlKSA9PiBvYmplY3RJbmNsdWRlcyhtYXJrUmFuZ2UubWFyay5hdHRycywgYXR0cmlidXRlcywgeyBzdHJpY3Q6IGZhbHNlIH0pKS5yZWR1Y2UoKHN1bSwgbWFya1JhbmdlKSA9PiBzdW0gKyBtYXJrUmFuZ2UudG8gLSBtYXJrUmFuZ2UuZnJvbSwgMCk7XG4gIGNvbnN0IGV4Y2x1ZGVkUmFuZ2UgPSBtYXJrUmFuZ2VzLmZpbHRlcigobWFya1JhbmdlKSA9PiB7XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtSYW5nZS5tYXJrLnR5cGUgIT09IHR5cGUgJiYgbWFya1JhbmdlLm1hcmsudHlwZS5leGNsdWRlcyh0eXBlKTtcbiAgfSkucmVkdWNlKChzdW0sIG1hcmtSYW5nZSkgPT4gc3VtICsgbWFya1JhbmdlLnRvIC0gbWFya1JhbmdlLmZyb20sIDApO1xuICBjb25zdCByYW5nZSA9IG1hdGNoZWRSYW5nZSA+IDAgPyBtYXRjaGVkUmFuZ2UgKyBleGNsdWRlZFJhbmdlIDogbWF0Y2hlZFJhbmdlO1xuICByZXR1cm4gcmFuZ2UgPj0gc2VsZWN0aW9uUmFuZ2U7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2lzQWN0aXZlLnRzXG5mdW5jdGlvbiBpc0FjdGl2ZShzdGF0ZSwgbmFtZSwgYXR0cmlidXRlcyA9IHt9KSB7XG4gIGlmICghbmFtZSkge1xuICAgIHJldHVybiBpc05vZGVBY3RpdmUoc3RhdGUsIG51bGwsIGF0dHJpYnV0ZXMpIHx8IGlzTWFya0FjdGl2ZShzdGF0ZSwgbnVsbCwgYXR0cmlidXRlcyk7XG4gIH1cbiAgY29uc3Qgc2NoZW1hVHlwZSA9IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKG5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGlmIChzY2hlbWFUeXBlID09PSBcIm5vZGVcIikge1xuICAgIHJldHVybiBpc05vZGVBY3RpdmUoc3RhdGUsIG5hbWUsIGF0dHJpYnV0ZXMpO1xuICB9XG4gIGlmIChzY2hlbWFUeXBlID09PSBcIm1hcmtcIikge1xuICAgIHJldHVybiBpc01hcmtBY3RpdmUoc3RhdGUsIG5hbWUsIGF0dHJpYnV0ZXMpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvaXNBdEVuZE9mTm9kZS50c1xudmFyIGlzQXRFbmRPZk5vZGUgPSAoc3RhdGUsIG5vZGVUeXBlKSA9PiB7XG4gIGNvbnN0IHsgJGZyb20sICR0bywgJGFuY2hvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICBpZiAobm9kZVR5cGUpIHtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gZmluZFBhcmVudE5vZGUoKG5vZGUpID0+IG5vZGUudHlwZS5uYW1lID09PSBub2RlVHlwZSkoc3RhdGUuc2VsZWN0aW9uKTtcbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgJHBhcmVudFBvcyA9IHN0YXRlLmRvYy5yZXNvbHZlKHBhcmVudE5vZGUucG9zICsgMSk7XG4gICAgaWYgKCRhbmNob3IucG9zICsgMSA9PT0gJHBhcmVudFBvcy5lbmQoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoJHRvLnBhcmVudE9mZnNldCA8ICR0by5wYXJlbnQubm9kZVNpemUgLSAyIHx8ICRmcm9tLnBvcyAhPT0gJHRvLnBvcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9oZWxwZXJzL2lzQXRTdGFydE9mTm9kZS50c1xudmFyIGlzQXRTdGFydE9mTm9kZSA9IChzdGF0ZSkgPT4ge1xuICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgaWYgKCRmcm9tLnBhcmVudE9mZnNldCA+IDAgfHwgJGZyb20ucG9zICE9PSAkdG8ucG9zKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2hlbHBlcnMvaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQudHNcbmZ1bmN0aW9uIGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkKGV4dGVuc2lvbiwgZW5hYmxlZCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShlbmFibGVkKSkge1xuICAgIHJldHVybiBlbmFibGVkLnNvbWUoKGVuYWJsZWRFeHRlbnNpb24pID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgZW5hYmxlZEV4dGVuc2lvbiA9PT0gXCJzdHJpbmdcIiA/IGVuYWJsZWRFeHRlbnNpb24gOiBlbmFibGVkRXh0ZW5zaW9uLm5hbWU7XG4gICAgICByZXR1cm4gbmFtZSA9PT0gZXh0ZW5zaW9uLm5hbWU7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGVuYWJsZWQ7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2lzTGlzdC50c1xuZnVuY3Rpb24gaXNMaXN0KG5hbWUsIGV4dGVuc2lvbnMpIHtcbiAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpO1xuICBjb25zdCBleHRlbnNpb24gPSBub2RlRXh0ZW5zaW9ucy5maW5kKChpdGVtKSA9PiBpdGVtLm5hbWUgPT09IG5hbWUpO1xuICBpZiAoIWV4dGVuc2lvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlXG4gIH07XG4gIGNvbnN0IGdyb3VwID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJncm91cFwiLCBjb250ZXh0KSk7XG4gIGlmICh0eXBlb2YgZ3JvdXAgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGdyb3VwLnNwbGl0KFwiIFwiKS5pbmNsdWRlcyhcImxpc3RcIik7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2lzTm9kZUVtcHR5LnRzXG5mdW5jdGlvbiBpc05vZGVFbXB0eShub2RlLCB7XG4gIGNoZWNrQ2hpbGRyZW4gPSB0cnVlLFxuICBpZ25vcmVXaGl0ZXNwYWNlID0gZmFsc2Vcbn0gPSB7fSkge1xuICB2YXIgX2E7XG4gIGlmIChpZ25vcmVXaGl0ZXNwYWNlKSB7XG4gICAgaWYgKG5vZGUudHlwZS5uYW1lID09PSBcImhhcmRCcmVha1wiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICByZXR1cm4gL15cXHMqJC9tLnRlc3QoKF9hID0gbm9kZS50ZXh0KSAhPSBudWxsID8gX2EgOiBcIlwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgcmV0dXJuICFub2RlLnRleHQ7XG4gIH1cbiAgaWYgKG5vZGUuaXNBdG9tIHx8IG5vZGUuaXNMZWFmKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChub2RlLmNvbnRlbnQuY2hpbGRDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChjaGVja0NoaWxkcmVuKSB7XG4gICAgbGV0IGlzQ29udGVudEVtcHR5ID0gdHJ1ZTtcbiAgICBub2RlLmNvbnRlbnQuZm9yRWFjaCgoY2hpbGROb2RlKSA9PiB7XG4gICAgICBpZiAoaXNDb250ZW50RW1wdHkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNOb2RlRW1wdHkoY2hpbGROb2RlLCB7IGlnbm9yZVdoaXRlc3BhY2UsIGNoZWNrQ2hpbGRyZW4gfSkpIHtcbiAgICAgICAgaXNDb250ZW50RW1wdHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaXNDb250ZW50RW1wdHk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBzcmMvaGVscGVycy9pc05vZGVTZWxlY3Rpb24udHNcbmltcG9ydCB7IE5vZGVTZWxlY3Rpb24gfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuZnVuY3Rpb24gaXNOb2RlU2VsZWN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb247XG59XG5cbi8vIHNyYy9oZWxwZXJzL3Bvc1RvRE9NUmVjdC50c1xuZnVuY3Rpb24gcG9zVG9ET01SZWN0KHZpZXcsIGZyb20sIHRvKSB7XG4gIGNvbnN0IG1pblBvcyA9IDA7XG4gIGNvbnN0IG1heFBvcyA9IHZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZTtcbiAgY29uc3QgcmVzb2x2ZWRGcm9tID0gbWluTWF4KGZyb20sIG1pblBvcywgbWF4UG9zKTtcbiAgY29uc3QgcmVzb2x2ZWRFbmQgPSBtaW5NYXgodG8sIG1pblBvcywgbWF4UG9zKTtcbiAgY29uc3Qgc3RhcnQgPSB2aWV3LmNvb3Jkc0F0UG9zKHJlc29sdmVkRnJvbSk7XG4gIGNvbnN0IGVuZCA9IHZpZXcuY29vcmRzQXRQb3MocmVzb2x2ZWRFbmQsIC0xKTtcbiAgY29uc3QgdG9wID0gTWF0aC5taW4oc3RhcnQudG9wLCBlbmQudG9wKTtcbiAgY29uc3QgYm90dG9tID0gTWF0aC5tYXgoc3RhcnQuYm90dG9tLCBlbmQuYm90dG9tKTtcbiAgY29uc3QgbGVmdCA9IE1hdGgubWluKHN0YXJ0LmxlZnQsIGVuZC5sZWZ0KTtcbiAgY29uc3QgcmlnaHQgPSBNYXRoLm1heChzdGFydC5yaWdodCwgZW5kLnJpZ2h0KTtcbiAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgY29uc3QgeCA9IGxlZnQ7XG4gIGNvbnN0IHkgPSB0b3A7XG4gIGNvbnN0IGRhdGEgPSB7XG4gICAgdG9wLFxuICAgIGJvdHRvbSxcbiAgICBsZWZ0LFxuICAgIHJpZ2h0LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIHRvSlNPTjogKCkgPT4gZGF0YVxuICB9O1xufVxuXG4vLyBzcmMvaGVscGVycy9yZXdyaXRlVW5rbm93bkNvbnRlbnQudHNcbmZ1bmN0aW9uIHJld3JpdGVVbmtub3duQ29udGVudElubmVyKHtcbiAganNvbixcbiAgdmFsaWRNYXJrcyxcbiAgdmFsaWROb2RlcyxcbiAgb3B0aW9ucyxcbiAgcmV3cml0dGVuQ29udGVudCA9IFtdXG59KSB7XG4gIGlmIChqc29uLm1hcmtzICYmIEFycmF5LmlzQXJyYXkoanNvbi5tYXJrcykpIHtcbiAgICBqc29uLm1hcmtzID0ganNvbi5tYXJrcy5maWx0ZXIoKG1hcmspID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgbWFyayA9PT0gXCJzdHJpbmdcIiA/IG1hcmsgOiBtYXJrLnR5cGU7XG4gICAgICBpZiAodmFsaWRNYXJrcy5oYXMobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXdyaXR0ZW5Db250ZW50LnB1c2goe1xuICAgICAgICBvcmlnaW5hbDogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtYXJrKSksXG4gICAgICAgIHVuc3VwcG9ydGVkOiBuYW1lXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgfVxuICBpZiAoanNvbi5jb250ZW50ICYmIEFycmF5LmlzQXJyYXkoanNvbi5jb250ZW50KSkge1xuICAgIGpzb24uY29udGVudCA9IGpzb24uY29udGVudC5tYXAoXG4gICAgICAodmFsdWUpID0+IHJld3JpdGVVbmtub3duQ29udGVudElubmVyKHtcbiAgICAgICAganNvbjogdmFsdWUsXG4gICAgICAgIHZhbGlkTWFya3MsXG4gICAgICAgIHZhbGlkTm9kZXMsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIHJld3JpdHRlbkNvbnRlbnRcbiAgICAgIH0pLmpzb25cbiAgICApLmZpbHRlcigoYSkgPT4gYSAhPT0gbnVsbCAmJiBhICE9PSB2b2lkIDApO1xuICB9XG4gIGlmIChqc29uLnR5cGUgJiYgIXZhbGlkTm9kZXMuaGFzKGpzb24udHlwZSkpIHtcbiAgICByZXdyaXR0ZW5Db250ZW50LnB1c2goe1xuICAgICAgb3JpZ2luYWw6IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoanNvbikpLFxuICAgICAgdW5zdXBwb3J0ZWQ6IGpzb24udHlwZVxuICAgIH0pO1xuICAgIGlmIChqc29uLmNvbnRlbnQgJiYgQXJyYXkuaXNBcnJheShqc29uLmNvbnRlbnQpICYmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmZhbGxiYWNrVG9QYXJhZ3JhcGgpICE9PSBmYWxzZSkge1xuICAgICAganNvbi50eXBlID0gXCJwYXJhZ3JhcGhcIjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpzb24sXG4gICAgICAgIHJld3JpdHRlbkNvbnRlbnRcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBqc29uOiBudWxsLFxuICAgICAgcmV3cml0dGVuQ29udGVudFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHsganNvbiwgcmV3cml0dGVuQ29udGVudCB9O1xufVxuZnVuY3Rpb24gcmV3cml0ZVVua25vd25Db250ZW50KGpzb24sIHNjaGVtYSwgb3B0aW9ucykge1xuICByZXR1cm4gcmV3cml0ZVVua25vd25Db250ZW50SW5uZXIoe1xuICAgIGpzb24sXG4gICAgdmFsaWROb2RlczogbmV3IFNldChPYmplY3Qua2V5cyhzY2hlbWEubm9kZXMpKSxcbiAgICB2YWxpZE1hcmtzOiBuZXcgU2V0KE9iamVjdC5rZXlzKHNjaGVtYS5tYXJrcykpLFxuICAgIG9wdGlvbnNcbiAgfSk7XG59XG5cbi8vIHNyYy9jb21tYW5kcy9zZXRNYXJrLnRzXG5mdW5jdGlvbiBjYW5TZXRNYXJrKHN0YXRlLCB0ciwgbmV3TWFya1R5cGUpIHtcbiAgdmFyIF9hO1xuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHI7XG4gIGxldCBjdXJzb3IgPSBudWxsO1xuICBpZiAoaXNUZXh0U2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBjdXJzb3IgPSBzZWxlY3Rpb24uJGN1cnNvcjtcbiAgfVxuICBpZiAoY3Vyc29yKSB7XG4gICAgY29uc3QgY3VycmVudE1hcmtzID0gKF9hID0gc3RhdGUuc3RvcmVkTWFya3MpICE9IG51bGwgPyBfYSA6IGN1cnNvci5tYXJrcygpO1xuICAgIGNvbnN0IHBhcmVudEFsbG93c01hcmtUeXBlID0gY3Vyc29yLnBhcmVudC50eXBlLmFsbG93c01hcmtUeXBlKG5ld01hcmtUeXBlKTtcbiAgICByZXR1cm4gcGFyZW50QWxsb3dzTWFya1R5cGUgJiYgKCEhbmV3TWFya1R5cGUuaXNJblNldChjdXJyZW50TWFya3MpIHx8ICFjdXJyZW50TWFya3Muc29tZSgobWFyaykgPT4gbWFyay50eXBlLmV4Y2x1ZGVzKG5ld01hcmtUeXBlKSkpO1xuICB9XG4gIGNvbnN0IHsgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XG4gIHJldHVybiByYW5nZXMuc29tZSgoeyAkZnJvbSwgJHRvIH0pID0+IHtcbiAgICBsZXQgc29tZU5vZGVTdXBwb3J0c01hcmsgPSAkZnJvbS5kZXB0aCA9PT0gMCA/IHN0YXRlLmRvYy5pbmxpbmVDb250ZW50ICYmIHN0YXRlLmRvYy50eXBlLmFsbG93c01hcmtUeXBlKG5ld01hcmtUeXBlKSA6IGZhbHNlO1xuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCAobm9kZSwgX3BvcywgcGFyZW50KSA9PiB7XG4gICAgICBpZiAoc29tZU5vZGVTdXBwb3J0c01hcmspIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuaXNJbmxpbmUpIHtcbiAgICAgICAgY29uc3QgcGFyZW50QWxsb3dzTWFya1R5cGUgPSAhcGFyZW50IHx8IHBhcmVudC50eXBlLmFsbG93c01hcmtUeXBlKG5ld01hcmtUeXBlKTtcbiAgICAgICAgY29uc3QgY3VycmVudE1hcmtzQWxsb3dNYXJrVHlwZSA9ICEhbmV3TWFya1R5cGUuaXNJblNldChub2RlLm1hcmtzKSB8fCAhbm9kZS5tYXJrcy5zb21lKChvdGhlck1hcmspID0+IG90aGVyTWFyay50eXBlLmV4Y2x1ZGVzKG5ld01hcmtUeXBlKSk7XG4gICAgICAgIHNvbWVOb2RlU3VwcG9ydHNNYXJrID0gcGFyZW50QWxsb3dzTWFya1R5cGUgJiYgY3VycmVudE1hcmtzQWxsb3dNYXJrVHlwZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhc29tZU5vZGVTdXBwb3J0c01hcms7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNvbWVOb2RlU3VwcG9ydHNNYXJrO1xuICB9KTtcbn1cbnZhciBzZXRNYXJrID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cjtcbiAgY29uc3QgeyBlbXB0eSwgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBpZiAoZW1wdHkpIHtcbiAgICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSBnZXRNYXJrQXR0cmlidXRlcyhzdGF0ZSwgdHlwZSk7XG4gICAgICB0ci5hZGRTdG9yZWRNYXJrKFxuICAgICAgICB0eXBlLmNyZWF0ZSh7XG4gICAgICAgICAgLi4ub2xkQXR0cmlidXRlcyxcbiAgICAgICAgICAuLi5hdHRyaWJ1dGVzXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZXMuZm9yRWFjaCgocmFuZ2UpID0+IHtcbiAgICAgICAgY29uc3QgZnJvbSA9IHJhbmdlLiRmcm9tLnBvcztcbiAgICAgICAgY29uc3QgdG8gPSByYW5nZS4kdG8ucG9zO1xuICAgICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgY29uc3QgdHJpbW1lZEZyb20gPSBNYXRoLm1heChwb3MsIGZyb20pO1xuICAgICAgICAgIGNvbnN0IHRyaW1tZWRUbyA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcbiAgICAgICAgICBjb25zdCBzb21lSGFzTWFyayA9IG5vZGUubWFya3MuZmluZCgobWFyaykgPT4gbWFyay50eXBlID09PSB0eXBlKTtcbiAgICAgICAgICBpZiAoc29tZUhhc01hcmspIHtcbiAgICAgICAgICAgIG5vZGUubWFya3MuZm9yRWFjaCgobWFyaykgPT4ge1xuICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gbWFyay50eXBlKSB7XG4gICAgICAgICAgICAgICAgdHIuYWRkTWFyayhcbiAgICAgICAgICAgICAgICAgIHRyaW1tZWRGcm9tLFxuICAgICAgICAgICAgICAgICAgdHJpbW1lZFRvLFxuICAgICAgICAgICAgICAgICAgdHlwZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAuLi5tYXJrLmF0dHJzLFxuICAgICAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ci5hZGRNYXJrKHRyaW1tZWRGcm9tLCB0cmltbWVkVG8sIHR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW5TZXRNYXJrKHN0YXRlLCB0ciwgdHlwZSk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvc2V0TWV0YS50c1xudmFyIHNldE1ldGEgPSAoa2V5LCB2YWx1ZSkgPT4gKHsgdHIgfSkgPT4ge1xuICB0ci5zZXRNZXRhKGtleSwgdmFsdWUpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zZXROb2RlLnRzXG5pbXBvcnQgeyBzZXRCbG9ja1R5cGUgfSBmcm9tIFwiQHRpcHRhcC9wbS9jb21tYW5kc1wiO1xudmFyIHNldE5vZGUgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2gsIGNoYWluIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGxldCBhdHRyaWJ1dGVzVG9Db3B5O1xuICBpZiAoc3RhdGUuc2VsZWN0aW9uLiRhbmNob3Iuc2FtZVBhcmVudChzdGF0ZS5zZWxlY3Rpb24uJGhlYWQpKSB7XG4gICAgYXR0cmlidXRlc1RvQ29weSA9IHN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yLnBhcmVudC5hdHRycztcbiAgfVxuICBpZiAoIXR5cGUuaXNUZXh0YmxvY2spIHtcbiAgICBjb25zb2xlLndhcm4oJ1t0aXB0YXAgd2Fybl06IEN1cnJlbnRseSBcInNldE5vZGUoKVwiIG9ubHkgc3VwcG9ydHMgdGV4dCBibG9jayBub2Rlcy4nKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGNoYWluKCkuY29tbWFuZCgoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgY29uc3QgY2FuU2V0QmxvY2sgPSBzZXRCbG9ja1R5cGUodHlwZSwgeyAuLi5hdHRyaWJ1dGVzVG9Db3B5LCAuLi5hdHRyaWJ1dGVzIH0pKHN0YXRlKTtcbiAgICBpZiAoY2FuU2V0QmxvY2spIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gY29tbWFuZHMuY2xlYXJOb2RlcygpO1xuICB9KS5jb21tYW5kKCh7IHN0YXRlOiB1cGRhdGVkU3RhdGUgfSkgPT4ge1xuICAgIHJldHVybiBzZXRCbG9ja1R5cGUodHlwZSwgeyAuLi5hdHRyaWJ1dGVzVG9Db3B5LCAuLi5hdHRyaWJ1dGVzIH0pKHVwZGF0ZWRTdGF0ZSwgZGlzcGF0Y2gpO1xuICB9KS5ydW4oKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zZXROb2RlU2VsZWN0aW9uLnRzXG5pbXBvcnQgeyBOb2RlU2VsZWN0aW9uIGFzIE5vZGVTZWxlY3Rpb24yIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbnZhciBzZXROb2RlU2VsZWN0aW9uID0gKHBvc2l0aW9uKSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCB7IGRvYyB9ID0gdHI7XG4gICAgY29uc3QgZnJvbSA9IG1pbk1heChwb3NpdGlvbiwgMCwgZG9jLmNvbnRlbnQuc2l6ZSk7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gTm9kZVNlbGVjdGlvbjIuY3JlYXRlKGRvYywgZnJvbSk7XG4gICAgdHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvc2V0VGV4dFNlbGVjdGlvbi50c1xuaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiBhcyBUZXh0U2VsZWN0aW9uNSB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG52YXIgc2V0VGV4dFNlbGVjdGlvbiA9IChwb3NpdGlvbikgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgeyBkb2MgfSA9IHRyO1xuICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHR5cGVvZiBwb3NpdGlvbiA9PT0gXCJudW1iZXJcIiA/IHsgZnJvbTogcG9zaXRpb24sIHRvOiBwb3NpdGlvbiB9IDogcG9zaXRpb247XG4gICAgY29uc3QgbWluUG9zID0gVGV4dFNlbGVjdGlvbjUuYXRTdGFydChkb2MpLmZyb207XG4gICAgY29uc3QgbWF4UG9zID0gVGV4dFNlbGVjdGlvbjUuYXRFbmQoZG9jKS50bztcbiAgICBjb25zdCByZXNvbHZlZEZyb20gPSBtaW5NYXgoZnJvbSwgbWluUG9zLCBtYXhQb3MpO1xuICAgIGNvbnN0IHJlc29sdmVkRW5kID0gbWluTWF4KHRvLCBtaW5Qb3MsIG1heFBvcyk7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gVGV4dFNlbGVjdGlvbjUuY3JlYXRlKGRvYywgcmVzb2x2ZWRGcm9tLCByZXNvbHZlZEVuZCk7XG4gICAgdHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvc2lua0xpc3RJdGVtLnRzXG5pbXBvcnQgeyBzaW5rTGlzdEl0ZW0gYXMgb3JpZ2luYWxTaW5rTGlzdEl0ZW0gfSBmcm9tIFwiQHRpcHRhcC9wbS9zY2hlbWEtbGlzdFwiO1xudmFyIHNpbmtMaXN0SXRlbSA9ICh0eXBlT3JOYW1lKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgcmV0dXJuIG9yaWdpbmFsU2lua0xpc3RJdGVtKHR5cGUpKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvc3BsaXRCbG9jay50c1xuaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiBhcyBOb2RlU2VsZWN0aW9uMywgVGV4dFNlbGVjdGlvbiBhcyBUZXh0U2VsZWN0aW9uNiB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG5pbXBvcnQgeyBjYW5TcGxpdCB9IGZyb20gXCJAdGlwdGFwL3BtL3RyYW5zZm9ybVwiO1xuZnVuY3Rpb24gZW5zdXJlTWFya3Moc3RhdGUsIHNwbGl0dGFibGVNYXJrcykge1xuICBjb25zdCBtYXJrcyA9IHN0YXRlLnN0b3JlZE1hcmtzIHx8IHN0YXRlLnNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5tYXJrcygpO1xuICBpZiAobWFya3MpIHtcbiAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKChtYXJrKSA9PiBzcGxpdHRhYmxlTWFya3MgPT0gbnVsbCA/IHZvaWQgMCA6IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpO1xuICAgIHN0YXRlLnRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpO1xuICB9XG59XG52YXIgc3BsaXRCbG9jayA9ICh7IGtlZXBNYXJrcyA9IHRydWUgfSA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoLCBlZGl0b3IgfSkgPT4ge1xuICBjb25zdCB7IHNlbGVjdGlvbiwgZG9jIH0gPSB0cjtcbiAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzZWxlY3Rpb247XG4gIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5hdHRyaWJ1dGVzO1xuICBjb25zdCBuZXdBdHRyaWJ1dGVzID0gZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKGV4dGVuc2lvbkF0dHJpYnV0ZXMsICRmcm9tLm5vZGUoKS50eXBlLm5hbWUsICRmcm9tLm5vZGUoKS5hdHRycyk7XG4gIGlmIChzZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uMyAmJiBzZWxlY3Rpb24ubm9kZS5pc0Jsb2NrKSB7XG4gICAgaWYgKCEkZnJvbS5wYXJlbnRPZmZzZXQgfHwgIWNhblNwbGl0KGRvYywgJGZyb20ucG9zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGlmIChrZWVwTWFya3MpIHtcbiAgICAgICAgZW5zdXJlTWFya3Moc3RhdGUsIGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLnNwbGl0dGFibGVNYXJrcyk7XG4gICAgICB9XG4gICAgICB0ci5zcGxpdCgkZnJvbS5wb3MpLnNjcm9sbEludG9WaWV3KCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghJGZyb20ucGFyZW50LmlzQmxvY2spIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYXRFbmQgPSAkdG8ucGFyZW50T2Zmc2V0ID09PSAkdG8ucGFyZW50LmNvbnRlbnQuc2l6ZTtcbiAgY29uc3QgZGVmbHQgPSAkZnJvbS5kZXB0aCA9PT0gMCA/IHZvaWQgMCA6IGRlZmF1bHRCbG9ja0F0KCRmcm9tLm5vZGUoLTEpLmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4QWZ0ZXIoLTEpKSk7XG4gIGxldCB0eXBlcyA9IGF0RW5kICYmIGRlZmx0ID8gW1xuICAgIHtcbiAgICAgIHR5cGU6IGRlZmx0LFxuICAgICAgYXR0cnM6IG5ld0F0dHJpYnV0ZXNcbiAgICB9XG4gIF0gOiB2b2lkIDA7XG4gIGxldCBjYW4gPSBjYW5TcGxpdCh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIHR5cGVzKTtcbiAgaWYgKCF0eXBlcyAmJiAhY2FuICYmIGNhblNwbGl0KHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgZGVmbHQgPyBbeyB0eXBlOiBkZWZsdCB9XSA6IHZvaWQgMCkpIHtcbiAgICBjYW4gPSB0cnVlO1xuICAgIHR5cGVzID0gZGVmbHQgPyBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IGRlZmx0LFxuICAgICAgICBhdHRyczogbmV3QXR0cmlidXRlc1xuICAgICAgfVxuICAgIF0gOiB2b2lkIDA7XG4gIH1cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgaWYgKGNhbikge1xuICAgICAgaWYgKHNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb242KSB7XG4gICAgICAgIHRyLmRlbGV0ZVNlbGVjdGlvbigpO1xuICAgICAgfVxuICAgICAgdHIuc3BsaXQodHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgdHlwZXMpO1xuICAgICAgaWYgKGRlZmx0ICYmICFhdEVuZCAmJiAhJGZyb20ucGFyZW50T2Zmc2V0ICYmICRmcm9tLnBhcmVudC50eXBlICE9PSBkZWZsdCkge1xuICAgICAgICBjb25zdCBmaXJzdDIgPSB0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoKSk7XG4gICAgICAgIGNvbnN0ICRmaXJzdCA9IHRyLmRvYy5yZXNvbHZlKGZpcnN0Mik7XG4gICAgICAgIGlmICgkZnJvbS5ub2RlKC0xKS5jYW5SZXBsYWNlV2l0aCgkZmlyc3QuaW5kZXgoKSwgJGZpcnN0LmluZGV4KCkgKyAxLCBkZWZsdCkpIHtcbiAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZSgpKSwgZGVmbHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZWVwTWFya3MpIHtcbiAgICAgIGVuc3VyZU1hcmtzKHN0YXRlLCBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5zcGxpdHRhYmxlTWFya3MpO1xuICAgIH1cbiAgICB0ci5zY3JvbGxJbnRvVmlldygpO1xuICB9XG4gIHJldHVybiBjYW47XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvc3BsaXRMaXN0SXRlbS50c1xuaW1wb3J0IHsgRnJhZ21lbnQgYXMgRnJhZ21lbnQzLCBTbGljZSB9IGZyb20gXCJAdGlwdGFwL3BtL21vZGVsXCI7XG5pbXBvcnQgeyBUZXh0U2VsZWN0aW9uIGFzIFRleHRTZWxlY3Rpb243IH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbmltcG9ydCB7IGNhblNwbGl0IGFzIGNhblNwbGl0MiB9IGZyb20gXCJAdGlwdGFwL3BtL3RyYW5zZm9ybVwiO1xudmFyIHNwbGl0TGlzdEl0ZW0gPSAodHlwZU9yTmFtZSwgb3ZlcnJpZGVBdHRycyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoLCBlZGl0b3IgfSkgPT4ge1xuICB2YXIgX2E7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgY29uc3Qgbm9kZSA9IHN0YXRlLnNlbGVjdGlvbi5ub2RlO1xuICBpZiAobm9kZSAmJiBub2RlLmlzQmxvY2sgfHwgJGZyb20uZGVwdGggPCAyIHx8ICEkZnJvbS5zYW1lUGFyZW50KCR0bykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZ3JhbmRQYXJlbnQgPSAkZnJvbS5ub2RlKC0xKTtcbiAgaWYgKGdyYW5kUGFyZW50LnR5cGUgIT09IHR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmF0dHJpYnV0ZXM7XG4gIGlmICgkZnJvbS5wYXJlbnQuY29udGVudC5zaXplID09PSAwICYmICRmcm9tLm5vZGUoLTEpLmNoaWxkQ291bnQgPT09ICRmcm9tLmluZGV4QWZ0ZXIoLTEpKSB7XG4gICAgaWYgKCRmcm9tLmRlcHRoID09PSAyIHx8ICRmcm9tLm5vZGUoLTMpLnR5cGUgIT09IHR5cGUgfHwgJGZyb20uaW5kZXgoLTIpICE9PSAkZnJvbS5ub2RlKC0yKS5jaGlsZENvdW50IC0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGxldCB3cmFwID0gRnJhZ21lbnQzLmVtcHR5O1xuICAgICAgY29uc3QgZGVwdGhCZWZvcmUgPSAkZnJvbS5pbmRleCgtMSkgPyAxIDogJGZyb20uaW5kZXgoLTIpID8gMiA6IDM7XG4gICAgICBmb3IgKGxldCBkID0gJGZyb20uZGVwdGggLSBkZXB0aEJlZm9yZTsgZCA+PSAkZnJvbS5kZXB0aCAtIDM7IGQgLT0gMSkge1xuICAgICAgICB3cmFwID0gRnJhZ21lbnQzLmZyb20oJGZyb20ubm9kZShkKS5jb3B5KHdyYXApKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlcHRoQWZ0ZXIgPSAoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAkZnJvbS5pbmRleEFmdGVyKC0xKSA8ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgPyAxIDogJGZyb20uaW5kZXhBZnRlcigtMikgPCAkZnJvbS5ub2RlKC0zKS5jaGlsZENvdW50ID8gMiA6IDNcbiAgICAgICk7XG4gICAgICBjb25zdCBuZXdOZXh0VHlwZUF0dHJpYnV0ZXMyID0ge1xuICAgICAgICAuLi5nZXRTcGxpdHRlZEF0dHJpYnV0ZXMoZXh0ZW5zaW9uQXR0cmlidXRlcywgJGZyb20ubm9kZSgpLnR5cGUubmFtZSwgJGZyb20ubm9kZSgpLmF0dHJzKSxcbiAgICAgICAgLi4ub3ZlcnJpZGVBdHRyc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG5leHRUeXBlMiA9ICgoX2EgPSB0eXBlLmNvbnRlbnRNYXRjaC5kZWZhdWx0VHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNyZWF0ZUFuZEZpbGwobmV3TmV4dFR5cGVBdHRyaWJ1dGVzMikpIHx8IHZvaWQgMDtcbiAgICAgIHdyYXAgPSB3cmFwLmFwcGVuZChGcmFnbWVudDMuZnJvbSh0eXBlLmNyZWF0ZUFuZEZpbGwobnVsbCwgbmV4dFR5cGUyKSB8fCB2b2lkIDApKTtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gJGZyb20uYmVmb3JlKCRmcm9tLmRlcHRoIC0gKGRlcHRoQmVmb3JlIC0gMSkpO1xuICAgICAgdHIucmVwbGFjZShzdGFydCwgJGZyb20uYWZ0ZXIoLWRlcHRoQWZ0ZXIpLCBuZXcgU2xpY2Uod3JhcCwgNCAtIGRlcHRoQmVmb3JlLCAwKSk7XG4gICAgICBsZXQgc2VsID0gLTE7XG4gICAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKHN0YXJ0LCB0ci5kb2MuY29udGVudC5zaXplLCAobiwgcG9zKSA9PiB7XG4gICAgICAgIGlmIChzZWwgPiAtMSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobi5pc1RleHRibG9jayAmJiBuLmNvbnRlbnQuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHNlbCA9IHBvcyArIDE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHNlbCA+IC0xKSB7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uNy5uZWFyKHRyLmRvYy5yZXNvbHZlKHNlbCkpKTtcbiAgICAgIH1cbiAgICAgIHRyLnNjcm9sbEludG9WaWV3KCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IG5leHRUeXBlID0gJHRvLnBvcyA9PT0gJGZyb20uZW5kKCkgPyBncmFuZFBhcmVudC5jb250ZW50TWF0Y2hBdCgwKS5kZWZhdWx0VHlwZSA6IG51bGw7XG4gIGNvbnN0IG5ld1R5cGVBdHRyaWJ1dGVzID0ge1xuICAgIC4uLmdldFNwbGl0dGVkQXR0cmlidXRlcyhleHRlbnNpb25BdHRyaWJ1dGVzLCBncmFuZFBhcmVudC50eXBlLm5hbWUsIGdyYW5kUGFyZW50LmF0dHJzKSxcbiAgICAuLi5vdmVycmlkZUF0dHJzXG4gIH07XG4gIGNvbnN0IG5ld05leHRUeXBlQXR0cmlidXRlcyA9IHtcbiAgICAuLi5nZXRTcGxpdHRlZEF0dHJpYnV0ZXMoZXh0ZW5zaW9uQXR0cmlidXRlcywgJGZyb20ubm9kZSgpLnR5cGUubmFtZSwgJGZyb20ubm9kZSgpLmF0dHJzKSxcbiAgICAuLi5vdmVycmlkZUF0dHJzXG4gIH07XG4gIHRyLmRlbGV0ZSgkZnJvbS5wb3MsICR0by5wb3MpO1xuICBjb25zdCB0eXBlcyA9IG5leHRUeXBlID8gW1xuICAgIHsgdHlwZSwgYXR0cnM6IG5ld1R5cGVBdHRyaWJ1dGVzIH0sXG4gICAgeyB0eXBlOiBuZXh0VHlwZSwgYXR0cnM6IG5ld05leHRUeXBlQXR0cmlidXRlcyB9XG4gIF0gOiBbeyB0eXBlLCBhdHRyczogbmV3VHlwZUF0dHJpYnV0ZXMgfV07XG4gIGlmICghY2FuU3BsaXQyKHRyLmRvYywgJGZyb20ucG9zLCAyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCB7IHNlbGVjdGlvbiwgc3RvcmVkTWFya3MgfSA9IHN0YXRlO1xuICAgIGNvbnN0IHsgc3BsaXR0YWJsZU1hcmtzIH0gPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlcjtcbiAgICBjb25zdCBtYXJrcyA9IHN0b3JlZE1hcmtzIHx8IHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpO1xuICAgIHRyLnNwbGl0KCRmcm9tLnBvcywgMiwgdHlwZXMpLnNjcm9sbEludG9WaWV3KCk7XG4gICAgaWYgKCFtYXJrcyB8fCAhZGlzcGF0Y2gpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKChtYXJrKSA9PiBzcGxpdHRhYmxlTWFya3MuaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKTtcbiAgICB0ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy90b2dnbGVMaXN0LnRzXG5pbXBvcnQgeyBjYW5Kb2luIH0gZnJvbSBcIkB0aXB0YXAvcG0vdHJhbnNmb3JtXCI7XG52YXIgam9pbkxpc3RCYWNrd2FyZHMgPSAodHIsIGxpc3RUeXBlKSA9PiB7XG4gIGNvbnN0IGxpc3QgPSBmaW5kUGFyZW50Tm9kZSgobm9kZSkgPT4gbm9kZS50eXBlID09PSBsaXN0VHlwZSkodHIuc2VsZWN0aW9uKTtcbiAgaWYgKCFsaXN0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgYmVmb3JlID0gdHIuZG9jLnJlc29sdmUoTWF0aC5tYXgoMCwgbGlzdC5wb3MgLSAxKSkuYmVmb3JlKGxpc3QuZGVwdGgpO1xuICBpZiAoYmVmb3JlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBub2RlQmVmb3JlID0gdHIuZG9jLm5vZGVBdChiZWZvcmUpO1xuICBjb25zdCBjYW5Kb2luQmFja3dhcmRzID0gbGlzdC5ub2RlLnR5cGUgPT09IChub2RlQmVmb3JlID09IG51bGwgPyB2b2lkIDAgOiBub2RlQmVmb3JlLnR5cGUpICYmIGNhbkpvaW4odHIuZG9jLCBsaXN0LnBvcyk7XG4gIGlmICghY2FuSm9pbkJhY2t3YXJkcykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRyLmpvaW4obGlzdC5wb3MpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgam9pbkxpc3RGb3J3YXJkcyA9ICh0ciwgbGlzdFR5cGUpID0+IHtcbiAgY29uc3QgbGlzdCA9IGZpbmRQYXJlbnROb2RlKChub2RlKSA9PiBub2RlLnR5cGUgPT09IGxpc3RUeXBlKSh0ci5zZWxlY3Rpb24pO1xuICBpZiAoIWxpc3QpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBhZnRlciA9IHRyLmRvYy5yZXNvbHZlKGxpc3Quc3RhcnQpLmFmdGVyKGxpc3QuZGVwdGgpO1xuICBpZiAoYWZ0ZXIgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IG5vZGVBZnRlciA9IHRyLmRvYy5ub2RlQXQoYWZ0ZXIpO1xuICBjb25zdCBjYW5Kb2luRm9yd2FyZHMgPSBsaXN0Lm5vZGUudHlwZSA9PT0gKG5vZGVBZnRlciA9PSBudWxsID8gdm9pZCAwIDogbm9kZUFmdGVyLnR5cGUpICYmIGNhbkpvaW4odHIuZG9jLCBhZnRlcik7XG4gIGlmICghY2FuSm9pbkZvcndhcmRzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHIuam9pbihhZnRlcik7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciB0b2dnbGVMaXN0ID0gKGxpc3RUeXBlT3JOYW1lLCBpdGVtVHlwZU9yTmFtZSwga2VlcE1hcmtzLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IGVkaXRvciwgdHIsIHN0YXRlLCBkaXNwYXRjaCwgY2hhaW4sIGNvbW1hbmRzLCBjYW4gfSkgPT4ge1xuICBjb25zdCB7IGV4dGVuc2lvbnMsIHNwbGl0dGFibGVNYXJrcyB9ID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXI7XG4gIGNvbnN0IGxpc3RUeXBlID0gZ2V0Tm9kZVR5cGUobGlzdFR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGNvbnN0IGl0ZW1UeXBlID0gZ2V0Tm9kZVR5cGUoaXRlbVR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGNvbnN0IHsgc2VsZWN0aW9uLCBzdG9yZWRNYXJrcyB9ID0gc3RhdGU7XG4gIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc2VsZWN0aW9uO1xuICBjb25zdCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKTtcbiAgY29uc3QgbWFya3MgPSBzdG9yZWRNYXJrcyB8fCBzZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzZWxlY3Rpb24uJGZyb20ubWFya3MoKTtcbiAgaWYgKCFyYW5nZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBwYXJlbnRMaXN0ID0gZmluZFBhcmVudE5vZGUoKG5vZGUpID0+IGlzTGlzdChub2RlLnR5cGUubmFtZSwgZXh0ZW5zaW9ucykpKHNlbGVjdGlvbik7XG4gIGlmIChyYW5nZS5kZXB0aCA+PSAxICYmIHBhcmVudExpc3QgJiYgcmFuZ2UuZGVwdGggLSBwYXJlbnRMaXN0LmRlcHRoIDw9IDEpIHtcbiAgICBpZiAocGFyZW50TGlzdC5ub2RlLnR5cGUgPT09IGxpc3RUeXBlKSB7XG4gICAgICByZXR1cm4gY29tbWFuZHMubGlmdExpc3RJdGVtKGl0ZW1UeXBlKTtcbiAgICB9XG4gICAgaWYgKGlzTGlzdChwYXJlbnRMaXN0Lm5vZGUudHlwZS5uYW1lLCBleHRlbnNpb25zKSAmJiBsaXN0VHlwZS52YWxpZENvbnRlbnQocGFyZW50TGlzdC5ub2RlLmNvbnRlbnQpICYmIGRpc3BhdGNoKSB7XG4gICAgICByZXR1cm4gY2hhaW4oKS5jb21tYW5kKCgpID0+IHtcbiAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwYXJlbnRMaXN0LnBvcywgbGlzdFR5cGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RCYWNrd2FyZHModHIsIGxpc3RUeXBlKSkuY29tbWFuZCgoKSA9PiBqb2luTGlzdEZvcndhcmRzKHRyLCBsaXN0VHlwZSkpLnJ1bigpO1xuICAgIH1cbiAgfVxuICBpZiAoIWtlZXBNYXJrcyB8fCAhbWFya3MgfHwgIWRpc3BhdGNoKSB7XG4gICAgcmV0dXJuIGNoYWluKCkuY29tbWFuZCgoKSA9PiB7XG4gICAgICBjb25zdCBjYW5XcmFwSW5MaXN0ID0gY2FuKCkud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcyk7XG4gICAgICBpZiAoY2FuV3JhcEluTGlzdCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKCk7XG4gICAgfSkud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcykuY29tbWFuZCgoKSA9PiBqb2luTGlzdEJhY2t3YXJkcyh0ciwgbGlzdFR5cGUpKS5jb21tYW5kKCgpID0+IGpvaW5MaXN0Rm9yd2FyZHModHIsIGxpc3RUeXBlKSkucnVuKCk7XG4gIH1cbiAgcmV0dXJuIGNoYWluKCkuY29tbWFuZCgoKSA9PiB7XG4gICAgY29uc3QgY2FuV3JhcEluTGlzdCA9IGNhbigpLndyYXBJbkxpc3QobGlzdFR5cGUsIGF0dHJpYnV0ZXMpO1xuICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrcy5maWx0ZXIoKG1hcmspID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpO1xuICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpO1xuICAgIGlmIChjYW5XcmFwSW5MaXN0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKTtcbiAgfSkud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcykuY29tbWFuZCgoKSA9PiBqb2luTGlzdEJhY2t3YXJkcyh0ciwgbGlzdFR5cGUpKS5jb21tYW5kKCgpID0+IGpvaW5MaXN0Rm9yd2FyZHModHIsIGxpc3RUeXBlKSkucnVuKCk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvdG9nZ2xlTWFyay50c1xudmFyIHRvZ2dsZU1hcmsgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9LCBvcHRpb25zID0ge30pID0+ICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XG4gIGNvbnN0IHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2UgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGNvbnN0IGlzQWN0aXZlMiA9IGlzTWFya0FjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcyk7XG4gIGlmIChpc0FjdGl2ZTIpIHtcbiAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHR5cGUsIHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2UgfSk7XG4gIH1cbiAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodHlwZSwgYXR0cmlidXRlcyk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvdG9nZ2xlTm9kZS50c1xudmFyIHRvZ2dsZU5vZGUgPSAodHlwZU9yTmFtZSwgdG9nZ2xlVHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgY29uc3QgdG9nZ2xlVHlwZSA9IGdldE5vZGVUeXBlKHRvZ2dsZVR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGNvbnN0IGlzQWN0aXZlMiA9IGlzTm9kZUFjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcyk7XG4gIGxldCBhdHRyaWJ1dGVzVG9Db3B5O1xuICBpZiAoc3RhdGUuc2VsZWN0aW9uLiRhbmNob3Iuc2FtZVBhcmVudChzdGF0ZS5zZWxlY3Rpb24uJGhlYWQpKSB7XG4gICAgYXR0cmlidXRlc1RvQ29weSA9IHN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yLnBhcmVudC5hdHRycztcbiAgfVxuICBpZiAoaXNBY3RpdmUyKSB7XG4gICAgcmV0dXJuIGNvbW1hbmRzLnNldE5vZGUodG9nZ2xlVHlwZSwgYXR0cmlidXRlc1RvQ29weSk7XG4gIH1cbiAgcmV0dXJuIGNvbW1hbmRzLnNldE5vZGUodHlwZSwgeyAuLi5hdHRyaWJ1dGVzVG9Db3B5LCAuLi5hdHRyaWJ1dGVzIH0pO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3RvZ2dsZVdyYXAudHNcbnZhciB0b2dnbGVXcmFwID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGNvbW1hbmRzIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGNvbnN0IGlzQWN0aXZlMiA9IGlzTm9kZUFjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcyk7XG4gIGlmIChpc0FjdGl2ZTIpIHtcbiAgICByZXR1cm4gY29tbWFuZHMubGlmdCh0eXBlKTtcbiAgfVxuICByZXR1cm4gY29tbWFuZHMud3JhcEluKHR5cGUsIGF0dHJpYnV0ZXMpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3VuZG9JbnB1dFJ1bGUudHNcbnZhciB1bmRvSW5wdXRSdWxlID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgcGx1Z2lucyA9IHN0YXRlLnBsdWdpbnM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgbGV0IHVuZG9hYmxlO1xuICAgIGlmIChwbHVnaW4uc3BlYy5pc0lucHV0UnVsZXMgJiYgKHVuZG9hYmxlID0gcGx1Z2luLmdldFN0YXRlKHN0YXRlKSkpIHtcbiAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBjb25zdCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICBjb25zdCB0b1VuZG8gPSB1bmRvYWJsZS50cmFuc2Zvcm07XG4gICAgICAgIGZvciAobGV0IGogPSB0b1VuZG8uc3RlcHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqIC09IDEpIHtcbiAgICAgICAgICB0ci5zdGVwKHRvVW5kby5zdGVwc1tqXS5pbnZlcnQodG9VbmRvLmRvY3Nbal0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5kb2FibGUudGV4dCkge1xuICAgICAgICAgIGNvbnN0IG1hcmtzID0gdHIuZG9jLnJlc29sdmUodW5kb2FibGUuZnJvbSkubWFya3MoKTtcbiAgICAgICAgICB0ci5yZXBsYWNlV2l0aCh1bmRvYWJsZS5mcm9tLCB1bmRvYWJsZS50bywgc3RhdGUuc2NoZW1hLnRleHQodW5kb2FibGUudGV4dCwgbWFya3MpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ci5kZWxldGUodW5kb2FibGUuZnJvbSwgdW5kb2FibGUudG8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3Vuc2V0QWxsTWFya3MudHNcbnZhciB1bnNldEFsbE1hcmtzID0gKCkgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyO1xuICBjb25zdCB7IGVtcHR5LCByYW5nZXMgfSA9IHNlbGVjdGlvbjtcbiAgaWYgKGVtcHR5KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgcmFuZ2VzLmZvckVhY2goKHJhbmdlKSA9PiB7XG4gICAgICB0ci5yZW1vdmVNYXJrKHJhbmdlLiRmcm9tLnBvcywgcmFuZ2UuJHRvLnBvcyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvdW5zZXRNYXJrLnRzXG52YXIgdW5zZXRNYXJrID0gKHR5cGVPck5hbWUsIG9wdGlvbnMgPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgeyBleHRlbmRFbXB0eU1hcmtSYW5nZSA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHI7XG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICBjb25zdCB7ICRmcm9tLCBlbXB0eSwgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XG4gIGlmICghZGlzcGF0Y2gpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZW1wdHkgJiYgZXh0ZW5kRW1wdHlNYXJrUmFuZ2UpIHtcbiAgICBsZXQgeyBmcm9tLCB0byB9ID0gc2VsZWN0aW9uO1xuICAgIGNvbnN0IGF0dHJzID0gKF9hID0gJGZyb20ubWFya3MoKS5maW5kKChtYXJrKSA9PiBtYXJrLnR5cGUgPT09IHR5cGUpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYXR0cnM7XG4gICAgY29uc3QgcmFuZ2UgPSBnZXRNYXJrUmFuZ2UoJGZyb20sIHR5cGUsIGF0dHJzKTtcbiAgICBpZiAocmFuZ2UpIHtcbiAgICAgIGZyb20gPSByYW5nZS5mcm9tO1xuICAgICAgdG8gPSByYW5nZS50bztcbiAgICB9XG4gICAgdHIucmVtb3ZlTWFyayhmcm9tLCB0bywgdHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmFuZ2VzLmZvckVhY2goKHJhbmdlKSA9PiB7XG4gICAgICB0ci5yZW1vdmVNYXJrKHJhbmdlLiRmcm9tLnBvcywgcmFuZ2UuJHRvLnBvcywgdHlwZSk7XG4gICAgfSk7XG4gIH1cbiAgdHIucmVtb3ZlU3RvcmVkTWFyayh0eXBlKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvdXBkYXRlQXR0cmlidXRlcy50c1xudmFyIHVwZGF0ZUF0dHJpYnV0ZXMgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgbGV0IG5vZGVUeXBlID0gbnVsbDtcbiAgbGV0IG1hcmtUeXBlID0gbnVsbDtcbiAgY29uc3Qgc2NoZW1hVHlwZSA9IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKFxuICAgIHR5cGVvZiB0eXBlT3JOYW1lID09PSBcInN0cmluZ1wiID8gdHlwZU9yTmFtZSA6IHR5cGVPck5hbWUubmFtZSxcbiAgICBzdGF0ZS5zY2hlbWFcbiAgKTtcbiAgaWYgKCFzY2hlbWFUeXBlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChzY2hlbWFUeXBlID09PSBcIm5vZGVcIikge1xuICAgIG5vZGVUeXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgfVxuICBpZiAoc2NoZW1hVHlwZSA9PT0gXCJtYXJrXCIpIHtcbiAgICBtYXJrVHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIH1cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgdHIuc2VsZWN0aW9uLnJhbmdlcy5mb3JFYWNoKChyYW5nZSkgPT4ge1xuICAgICAgY29uc3QgZnJvbSA9IHJhbmdlLiRmcm9tLnBvcztcbiAgICAgIGNvbnN0IHRvID0gcmFuZ2UuJHRvLnBvcztcbiAgICAgIGxldCBsYXN0UG9zO1xuICAgICAgbGV0IGxhc3ROb2RlO1xuICAgICAgbGV0IHRyaW1tZWRGcm9tO1xuICAgICAgbGV0IHRyaW1tZWRUbztcbiAgICAgIGlmICh0ci5zZWxlY3Rpb24uZW1wdHkpIHtcbiAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgIGlmIChub2RlVHlwZSAmJiBub2RlVHlwZSA9PT0gbm9kZS50eXBlKSB7XG4gICAgICAgICAgICB0cmltbWVkRnJvbSA9IE1hdGgubWF4KHBvcywgZnJvbSk7XG4gICAgICAgICAgICB0cmltbWVkVG8gPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICAgICAgICBsYXN0UG9zID0gcG9zO1xuICAgICAgICAgICAgbGFzdE5vZGUgPSBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgaWYgKHBvcyA8IGZyb20gJiYgbm9kZVR5cGUgJiYgbm9kZVR5cGUgPT09IG5vZGUudHlwZSkge1xuICAgICAgICAgICAgdHJpbW1lZEZyb20gPSBNYXRoLm1heChwb3MsIGZyb20pO1xuICAgICAgICAgICAgdHJpbW1lZFRvID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pO1xuICAgICAgICAgICAgbGFzdFBvcyA9IHBvcztcbiAgICAgICAgICAgIGxhc3ROb2RlID0gbm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBvcyA+PSBmcm9tICYmIHBvcyA8PSB0bykge1xuICAgICAgICAgICAgaWYgKG5vZGVUeXBlICYmIG5vZGVUeXBlID09PSBub2RlLnR5cGUpIHtcbiAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3MsIHZvaWQgMCwge1xuICAgICAgICAgICAgICAgIC4uLm5vZGUuYXR0cnMsXG4gICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXJrVHlwZSAmJiBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBub2RlLm1hcmtzLmZvckVhY2goKG1hcmspID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobWFya1R5cGUgPT09IG1hcmsudHlwZSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZEZyb20yID0gTWF0aC5tYXgocG9zLCBmcm9tKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRUbzIgPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKFxuICAgICAgICAgICAgICAgICAgICB0cmltbWVkRnJvbTIsXG4gICAgICAgICAgICAgICAgICAgIHRyaW1tZWRUbzIsXG4gICAgICAgICAgICAgICAgICAgIG1hcmtUeXBlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgLi4ubWFyay5hdHRycyxcbiAgICAgICAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0Tm9kZSkge1xuICAgICAgICBpZiAobGFzdFBvcyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChsYXN0UG9zLCB2b2lkIDAsIHtcbiAgICAgICAgICAgIC4uLmxhc3ROb2RlLmF0dHJzLFxuICAgICAgICAgICAgLi4uYXR0cmlidXRlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrVHlwZSAmJiBsYXN0Tm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICBsYXN0Tm9kZS5tYXJrcy5mb3JFYWNoKChtYXJrKSA9PiB7XG4gICAgICAgICAgICBpZiAobWFya1R5cGUgPT09IG1hcmsudHlwZSkge1xuICAgICAgICAgICAgICB0ci5hZGRNYXJrKFxuICAgICAgICAgICAgICAgIHRyaW1tZWRGcm9tLFxuICAgICAgICAgICAgICAgIHRyaW1tZWRUbyxcbiAgICAgICAgICAgICAgICBtYXJrVHlwZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgLi4ubWFyay5hdHRycyxcbiAgICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvd3JhcEluLnRzXG5pbXBvcnQgeyB3cmFwSW4gYXMgb3JpZ2luYWxXcmFwSW4gfSBmcm9tIFwiQHRpcHRhcC9wbS9jb21tYW5kc1wiO1xudmFyIHdyYXBJbiA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICByZXR1cm4gb3JpZ2luYWxXcmFwSW4odHlwZSwgYXR0cmlidXRlcykoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy93cmFwSW5MaXN0LnRzXG5pbXBvcnQgeyB3cmFwSW5MaXN0IGFzIG9yaWdpbmFsV3JhcEluTGlzdCB9IGZyb20gXCJAdGlwdGFwL3BtL3NjaGVtYS1saXN0XCI7XG52YXIgd3JhcEluTGlzdCA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICByZXR1cm4gb3JpZ2luYWxXcmFwSW5MaXN0KHR5cGUsIGF0dHJpYnV0ZXMpKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG4vLyBzcmMvRWRpdG9yLnRzXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG5pbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSBcIkB0aXB0YXAvcG0vdmlld1wiO1xuXG4vLyBzcmMvRXZlbnRFbWl0dGVyLnRzXG52YXIgRXZlbnRFbWl0dGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IHt9O1xuICB9XG4gIG9uKGV2ZW50LCBmbikge1xuICAgIGlmICghdGhpcy5jYWxsYmFja3NbZXZlbnRdKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrc1tldmVudF0gPSBbXTtcbiAgICB9XG4gICAgdGhpcy5jYWxsYmFja3NbZXZlbnRdLnB1c2goZm4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrc1tldmVudF07XG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgY2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9mZihldmVudCwgZm4pIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrc1tldmVudF07XG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzW2V2ZW50XSA9IGNhbGxiYWNrcy5maWx0ZXIoKGNhbGxiYWNrKSA9PiBjYWxsYmFjayAhPT0gZm4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tzW2V2ZW50XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb25jZShldmVudCwgZm4pIHtcbiAgICBjb25zdCBvbmNlRm4gPSAoLi4uYXJncykgPT4ge1xuICAgICAgdGhpcy5vZmYoZXZlbnQsIG9uY2VGbik7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLm9uKGV2ZW50LCBvbmNlRm4pO1xuICB9XG4gIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IHt9O1xuICB9XG59O1xuXG4vLyBzcmMvRXh0ZW5zaW9uTWFuYWdlci50c1xuaW1wb3J0IHsga2V5bWFwIH0gZnJvbSBcIkB0aXB0YXAvcG0va2V5bWFwXCI7XG5cbi8vIHNyYy9JbnB1dFJ1bGUudHNcbmltcG9ydCB7IEZyYWdtZW50IGFzIEZyYWdtZW50NCB9IGZyb20gXCJAdGlwdGFwL3BtL21vZGVsXCI7XG5pbXBvcnQgeyBQbHVnaW4gfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xudmFyIElucHV0UnVsZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuZmluZCA9IGNvbmZpZy5maW5kO1xuICAgIHRoaXMuaGFuZGxlciA9IGNvbmZpZy5oYW5kbGVyO1xuICAgIHRoaXMudW5kb2FibGUgPSAoX2EgPSBjb25maWcudW5kb2FibGUpICE9IG51bGwgPyBfYSA6IHRydWU7XG4gIH1cbn07XG52YXIgaW5wdXRSdWxlTWF0Y2hlckhhbmRsZXIgPSAodGV4dCwgZmluZCkgPT4ge1xuICBpZiAoaXNSZWdFeHAoZmluZCkpIHtcbiAgICByZXR1cm4gZmluZC5leGVjKHRleHQpO1xuICB9XG4gIGNvbnN0IGlucHV0UnVsZU1hdGNoID0gZmluZCh0ZXh0KTtcbiAgaWYgKCFpbnB1dFJ1bGVNYXRjaCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtpbnB1dFJ1bGVNYXRjaC50ZXh0XTtcbiAgcmVzdWx0LmluZGV4ID0gaW5wdXRSdWxlTWF0Y2guaW5kZXg7XG4gIHJlc3VsdC5pbnB1dCA9IHRleHQ7XG4gIHJlc3VsdC5kYXRhID0gaW5wdXRSdWxlTWF0Y2guZGF0YTtcbiAgaWYgKGlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoKSB7XG4gICAgaWYgKCFpbnB1dFJ1bGVNYXRjaC50ZXh0LmluY2x1ZGVzKGlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoKSkge1xuICAgICAgY29uc29sZS53YXJuKCdbdGlwdGFwIHdhcm5dOiBcImlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoXCIgbXVzdCBiZSBwYXJ0IG9mIFwiaW5wdXRSdWxlTWF0Y2gudGV4dFwiLicpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5mdW5jdGlvbiBydW4oY29uZmlnKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgeyBlZGl0b3IsIGZyb20sIHRvLCB0ZXh0LCBydWxlcywgcGx1Z2luIH0gPSBjb25maWc7XG4gIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yO1xuICBpZiAodmlldy5jb21wb3NpbmcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgJGZyb20gPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGZyb20pO1xuICBpZiAoXG4gICAgLy8gY2hlY2sgZm9yIGNvZGUgbm9kZVxuICAgICRmcm9tLnBhcmVudC50eXBlLnNwZWMuY29kZSB8fCAvLyBjaGVjayBmb3IgY29kZSBtYXJrXG4gICAgISEoKF9hID0gJGZyb20ubm9kZUJlZm9yZSB8fCAkZnJvbS5ub2RlQWZ0ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYS5tYXJrcy5maW5kKChtYXJrKSA9PiBtYXJrLnR5cGUuc3BlYy5jb2RlKSlcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBtYXRjaGVkID0gZmFsc2U7XG4gIGNvbnN0IHRleHRCZWZvcmUgPSBnZXRUZXh0Q29udGVudEZyb21Ob2RlcygkZnJvbSkgKyB0ZXh0O1xuICBydWxlcy5mb3JFYWNoKChydWxlKSA9PiB7XG4gICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSBpbnB1dFJ1bGVNYXRjaGVySGFuZGxlcih0ZXh0QmVmb3JlLCBydWxlLmZpbmQpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHIgPSB2aWV3LnN0YXRlLnRyO1xuICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgc3RhdGU6IHZpZXcuc3RhdGUsXG4gICAgICB0cmFuc2FjdGlvbjogdHJcbiAgICB9KTtcbiAgICBjb25zdCByYW5nZSA9IHtcbiAgICAgIGZyb206IGZyb20gLSAobWF0Y2hbMF0ubGVuZ3RoIC0gdGV4dC5sZW5ndGgpLFxuICAgICAgdG9cbiAgICB9O1xuICAgIGNvbnN0IHsgY29tbWFuZHMsIGNoYWluLCBjYW4gfSA9IG5ldyBDb21tYW5kTWFuYWdlcih7XG4gICAgICBlZGl0b3IsXG4gICAgICBzdGF0ZVxuICAgIH0pO1xuICAgIGNvbnN0IGhhbmRsZXIgPSBydWxlLmhhbmRsZXIoe1xuICAgICAgc3RhdGUsXG4gICAgICByYW5nZSxcbiAgICAgIG1hdGNoLFxuICAgICAgY29tbWFuZHMsXG4gICAgICBjaGFpbixcbiAgICAgIGNhblxuICAgIH0pO1xuICAgIGlmIChoYW5kbGVyID09PSBudWxsIHx8ICF0ci5zdGVwcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJ1bGUudW5kb2FibGUpIHtcbiAgICAgIHRyLnNldE1ldGEocGx1Z2luLCB7XG4gICAgICAgIHRyYW5zZm9ybTogdHIsXG4gICAgICAgIGZyb20sXG4gICAgICAgIHRvLFxuICAgICAgICB0ZXh0XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgbWF0Y2hlZCA9IHRydWU7XG4gIH0pO1xuICByZXR1cm4gbWF0Y2hlZDtcbn1cbmZ1bmN0aW9uIGlucHV0UnVsZXNQbHVnaW4ocHJvcHMpIHtcbiAgY29uc3QgeyBlZGl0b3IsIHJ1bGVzIH0gPSBwcm9wcztcbiAgY29uc3QgcGx1Z2luID0gbmV3IFBsdWdpbih7XG4gICAgc3RhdGU6IHtcbiAgICAgIGluaXQoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIGFwcGx5KHRyLCBwcmV2LCBzdGF0ZSkge1xuICAgICAgICBjb25zdCBzdG9yZWQgPSB0ci5nZXRNZXRhKHBsdWdpbik7XG4gICAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgICByZXR1cm4gc3RvcmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpbXVsYXRlZElucHV0TWV0YSA9IHRyLmdldE1ldGEoXCJhcHBseUlucHV0UnVsZXNcIik7XG4gICAgICAgIGNvbnN0IGlzU2ltdWxhdGVkSW5wdXQgPSAhIXNpbXVsYXRlZElucHV0TWV0YTtcbiAgICAgICAgaWYgKGlzU2ltdWxhdGVkSW5wdXQpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGxldCB7IHRleHQgfSA9IHNpbXVsYXRlZElucHV0TWV0YTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICB0ZXh0ID0gdGV4dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRleHQgPSBnZXRIVE1MRnJvbUZyYWdtZW50KEZyYWdtZW50NC5mcm9tKHRleHQpLCBzdGF0ZS5zY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBmcm9tIH0gPSBzaW11bGF0ZWRJbnB1dE1ldGE7XG4gICAgICAgICAgICBjb25zdCB0byA9IGZyb20gKyB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHJ1bih7XG4gICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgIHJ1bGVzLFxuICAgICAgICAgICAgICBwbHVnaW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ci5zZWxlY3Rpb25TZXQgfHwgdHIuZG9jQ2hhbmdlZCA/IG51bGwgOiBwcmV2O1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgIGhhbmRsZVRleHRJbnB1dCh2aWV3LCBmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICByZXR1cm4gcnVuKHtcbiAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgZnJvbSxcbiAgICAgICAgICB0byxcbiAgICAgICAgICB0ZXh0LFxuICAgICAgICAgIHJ1bGVzLFxuICAgICAgICAgIHBsdWdpblxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgY29tcG9zaXRpb25lbmQ6ICh2aWV3KSA9PiB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7ICRjdXJzb3IgfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgaWYgKCRjdXJzb3IpIHtcbiAgICAgICAgICAgICAgcnVuKHtcbiAgICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgICAgZnJvbTogJGN1cnNvci5wb3MsXG4gICAgICAgICAgICAgICAgdG86ICRjdXJzb3IucG9zLFxuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgcnVsZXMsXG4gICAgICAgICAgICAgICAgcGx1Z2luXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIGFkZCBzdXBwb3J0IGZvciBpbnB1dCBydWxlcyB0byB0cmlnZ2VyIG9uIGVudGVyXG4gICAgICAvLyB0aGlzIGlzIHVzZWZ1bCBmb3IgZXhhbXBsZSBmb3IgY29kZSBibG9ja3NcbiAgICAgIGhhbmRsZUtleURvd24odmlldywgZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleSAhPT0gXCJFbnRlclwiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgJGN1cnNvciB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmICgkY3Vyc29yKSB7XG4gICAgICAgICAgcmV0dXJuIHJ1bih7XG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBmcm9tOiAkY3Vyc29yLnBvcyxcbiAgICAgICAgICAgIHRvOiAkY3Vyc29yLnBvcyxcbiAgICAgICAgICAgIHRleHQ6IFwiXFxuXCIsXG4gICAgICAgICAgICBydWxlcyxcbiAgICAgICAgICAgIHBsdWdpblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpc0lucHV0UnVsZXM6IHRydWVcbiAgfSk7XG4gIHJldHVybiBwbHVnaW47XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvaXNQbGFpbk9iamVjdC50c1xuZnVuY3Rpb24gZ2V0VHlwZSh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSk7XG59XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmIChnZXRUeXBlKHZhbHVlKSAhPT0gXCJPYmplY3RcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL21lcmdlRGVlcC50c1xuZnVuY3Rpb24gbWVyZ2VEZWVwKHRhcmdldCwgc291cmNlKSB7XG4gIGNvbnN0IG91dHB1dCA9IHsgLi4udGFyZ2V0IH07XG4gIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSAmJiBpc1BsYWluT2JqZWN0KHRhcmdldFtrZXldKSkge1xuICAgICAgICBvdXRwdXRba2V5XSA9IG1lcmdlRGVlcCh0YXJnZXRba2V5XSwgc291cmNlW2tleV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vLyBzcmMvRXh0ZW5kYWJsZS50c1xudmFyIEV4dGVuZGFibGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgdGhpcy50eXBlID0gXCJleHRlbmRhYmxlXCI7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuY2hpbGQgPSBudWxsO1xuICAgIHRoaXMubmFtZSA9IFwiXCI7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWVcbiAgICB9O1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgLi4udGhpcy5jb25maWcsXG4gICAgICAuLi5jb25maWdcbiAgICB9O1xuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uZmlnLm5hbWU7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNhbGxPclJldHVybihcbiAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQodGhpcywgXCJhZGRPcHRpb25zXCIsIHtcbiAgICAgICAgICBuYW1lOiB0aGlzLm5hbWVcbiAgICAgICAgfSlcbiAgICAgICkgfHwge31cbiAgICB9O1xuICB9XG4gIGdldCBzdG9yYWdlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5jYWxsT3JSZXR1cm4oXG4gICAgICAgIGdldEV4dGVuc2lvbkZpZWxkKHRoaXMsIFwiYWRkU3RvcmFnZVwiLCB7XG4gICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9uc1xuICAgICAgICB9KVxuICAgICAgKSB8fCB7fVxuICAgIH07XG4gIH1cbiAgY29uZmlndXJlKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRoaXMuZXh0ZW5kKHtcbiAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgYWRkT3B0aW9uczogKCkgPT4ge1xuICAgICAgICByZXR1cm4gbWVyZ2VEZWVwKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZXh0ZW5zaW9uLm5hbWUgPSB0aGlzLm5hbWU7XG4gICAgZXh0ZW5zaW9uLnBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgIHJldHVybiBleHRlbnNpb247XG4gIH1cbiAgZXh0ZW5kKGV4dGVuZGVkQ29uZmlnID0ge30pIHtcbiAgICBjb25zdCBleHRlbnNpb24gPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih7IC4uLnRoaXMuY29uZmlnLCAuLi5leHRlbmRlZENvbmZpZyB9KTtcbiAgICBleHRlbnNpb24ucGFyZW50ID0gdGhpcztcbiAgICB0aGlzLmNoaWxkID0gZXh0ZW5zaW9uO1xuICAgIGV4dGVuc2lvbi5uYW1lID0gXCJuYW1lXCIgaW4gZXh0ZW5kZWRDb25maWcgPyBleHRlbmRlZENvbmZpZy5uYW1lIDogZXh0ZW5zaW9uLnBhcmVudC5uYW1lO1xuICAgIHJldHVybiBleHRlbnNpb247XG4gIH1cbn07XG5cbi8vIHNyYy9NYXJrLnRzXG52YXIgTWFyayA9IGNsYXNzIF9NYXJrIGV4dGVuZHMgRXh0ZW5kYWJsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gXCJtYXJrXCI7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBNYXJrIGluc3RhbmNlXG4gICAqIEBwYXJhbSBjb25maWcgLSBNYXJrIGNvbmZpZ3VyYXRpb24gb2JqZWN0IG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICovXG4gIHN0YXRpYyBjcmVhdGUoY29uZmlnID0ge30pIHtcbiAgICBjb25zdCByZXNvbHZlZENvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09IFwiZnVuY3Rpb25cIiA/IGNvbmZpZygpIDogY29uZmlnO1xuICAgIHJldHVybiBuZXcgX01hcmsocmVzb2x2ZWRDb25maWcpO1xuICB9XG4gIHN0YXRpYyBoYW5kbGVFeGl0KHsgZWRpdG9yLCBtYXJrIH0pIHtcbiAgICBjb25zdCB7IHRyIH0gPSBlZGl0b3Iuc3RhdGU7XG4gICAgY29uc3QgY3VycmVudFBvcyA9IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uJGZyb207XG4gICAgY29uc3QgaXNBdEVuZCA9IGN1cnJlbnRQb3MucG9zID09PSBjdXJyZW50UG9zLmVuZCgpO1xuICAgIGlmIChpc0F0RW5kKSB7XG4gICAgICBjb25zdCBjdXJyZW50TWFya3MgPSBjdXJyZW50UG9zLm1hcmtzKCk7XG4gICAgICBjb25zdCBpc0luTWFyayA9ICEhY3VycmVudE1hcmtzLmZpbmQoKG0pID0+IChtID09IG51bGwgPyB2b2lkIDAgOiBtLnR5cGUubmFtZSkgPT09IG1hcmsubmFtZSk7XG4gICAgICBpZiAoIWlzSW5NYXJrKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbW92ZU1hcmsgPSBjdXJyZW50TWFya3MuZmluZCgobSkgPT4gKG0gPT0gbnVsbCA/IHZvaWQgMCA6IG0udHlwZS5uYW1lKSA9PT0gbWFyay5uYW1lKTtcbiAgICAgIGlmIChyZW1vdmVNYXJrKSB7XG4gICAgICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsocmVtb3ZlTWFyayk7XG4gICAgICB9XG4gICAgICB0ci5pbnNlcnRUZXh0KFwiIFwiLCBjdXJyZW50UG9zLnBvcyk7XG4gICAgICBlZGl0b3Iudmlldy5kaXNwYXRjaCh0cik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbmZpZ3VyZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNvbmZpZ3VyZShvcHRpb25zKTtcbiAgfVxuICBleHRlbmQoZXh0ZW5kZWRDb25maWcpIHtcbiAgICBjb25zdCByZXNvbHZlZENvbmZpZyA9IHR5cGVvZiBleHRlbmRlZENvbmZpZyA9PT0gXCJmdW5jdGlvblwiID8gZXh0ZW5kZWRDb25maWcoKSA6IGV4dGVuZGVkQ29uZmlnO1xuICAgIHJldHVybiBzdXBlci5leHRlbmQocmVzb2x2ZWRDb25maWcpO1xuICB9XG59O1xuXG4vLyBzcmMvUGFzdGVSdWxlLnRzXG5pbXBvcnQgeyBGcmFnbWVudCBhcyBGcmFnbWVudDUgfSBmcm9tIFwiQHRpcHRhcC9wbS9tb2RlbFwiO1xuaW1wb3J0IHsgUGx1Z2luIGFzIFBsdWdpbjIgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuXG4vLyBzcmMvdXRpbGl0aWVzL2lzTnVtYmVyLnRzXG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xufVxuXG4vLyBzcmMvUGFzdGVSdWxlLnRzXG52YXIgUGFzdGVSdWxlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmZpbmQgPSBjb25maWcuZmluZDtcbiAgICB0aGlzLmhhbmRsZXIgPSBjb25maWcuaGFuZGxlcjtcbiAgfVxufTtcbnZhciBwYXN0ZVJ1bGVNYXRjaGVySGFuZGxlciA9ICh0ZXh0LCBmaW5kLCBldmVudCkgPT4ge1xuICBpZiAoaXNSZWdFeHAoZmluZCkpIHtcbiAgICByZXR1cm4gWy4uLnRleHQubWF0Y2hBbGwoZmluZCldO1xuICB9XG4gIGNvbnN0IG1hdGNoZXMgPSBmaW5kKHRleHQsIGV2ZW50KTtcbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBtYXRjaGVzLm1hcCgocGFzdGVSdWxlTWF0Y2gpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBbcGFzdGVSdWxlTWF0Y2gudGV4dF07XG4gICAgcmVzdWx0LmluZGV4ID0gcGFzdGVSdWxlTWF0Y2guaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gdGV4dDtcbiAgICByZXN1bHQuZGF0YSA9IHBhc3RlUnVsZU1hdGNoLmRhdGE7XG4gICAgaWYgKHBhc3RlUnVsZU1hdGNoLnJlcGxhY2VXaXRoKSB7XG4gICAgICBpZiAoIXBhc3RlUnVsZU1hdGNoLnRleHQuaW5jbHVkZXMocGFzdGVSdWxlTWF0Y2gucmVwbGFjZVdpdGgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW3RpcHRhcCB3YXJuXTogXCJwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aFwiIG11c3QgYmUgcGFydCBvZiBcInBhc3RlUnVsZU1hdGNoLnRleHRcIi4nKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHBhc3RlUnVsZU1hdGNoLnJlcGxhY2VXaXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG59O1xuZnVuY3Rpb24gcnVuMihjb25maWcpIHtcbiAgY29uc3QgeyBlZGl0b3IsIHN0YXRlLCBmcm9tLCB0bywgcnVsZSwgcGFzdGVFdmVudCwgZHJvcEV2ZW50IH0gPSBjb25maWc7XG4gIGNvbnN0IHsgY29tbWFuZHMsIGNoYWluLCBjYW4gfSA9IG5ldyBDb21tYW5kTWFuYWdlcih7XG4gICAgZWRpdG9yLFxuICAgIHN0YXRlXG4gIH0pO1xuICBjb25zdCBoYW5kbGVycyA9IFtdO1xuICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBpZiAoKChfYiA9IChfYSA9IG5vZGUudHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNwZWMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jb2RlKSB8fCAhKG5vZGUuaXNUZXh0IHx8IG5vZGUuaXNUZXh0YmxvY2sgfHwgbm9kZS5pc0lubGluZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29udGVudFNpemUgPSAoX2UgPSAoX2QgPSAoX2MgPSBub2RlLmNvbnRlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5zaXplKSAhPSBudWxsID8gX2QgOiBub2RlLm5vZGVTaXplKSAhPSBudWxsID8gX2UgOiAwO1xuICAgIGNvbnN0IHJlc29sdmVkRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcyk7XG4gICAgY29uc3QgcmVzb2x2ZWRUbyA9IE1hdGgubWluKHRvLCBwb3MgKyBjb250ZW50U2l6ZSk7XG4gICAgaWYgKHJlc29sdmVkRnJvbSA+PSByZXNvbHZlZFRvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRleHRUb01hdGNoID0gbm9kZS5pc1RleHQgPyBub2RlLnRleHQgfHwgXCJcIiA6IG5vZGUudGV4dEJldHdlZW4ocmVzb2x2ZWRGcm9tIC0gcG9zLCByZXNvbHZlZFRvIC0gcG9zLCB2b2lkIDAsIFwiXFx1RkZGQ1wiKTtcbiAgICBjb25zdCBtYXRjaGVzID0gcGFzdGVSdWxlTWF0Y2hlckhhbmRsZXIodGV4dFRvTWF0Y2gsIHJ1bGUuZmluZCwgcGFzdGVFdmVudCk7XG4gICAgbWF0Y2hlcy5mb3JFYWNoKChtYXRjaCkgPT4ge1xuICAgICAgaWYgKG1hdGNoLmluZGV4ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnQgPSByZXNvbHZlZEZyb20gKyBtYXRjaC5pbmRleCArIDE7XG4gICAgICBjb25zdCBlbmQgPSBzdGFydCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIGNvbnN0IHJhbmdlID0ge1xuICAgICAgICBmcm9tOiBzdGF0ZS50ci5tYXBwaW5nLm1hcChzdGFydCksXG4gICAgICAgIHRvOiBzdGF0ZS50ci5tYXBwaW5nLm1hcChlbmQpXG4gICAgICB9O1xuICAgICAgY29uc3QgaGFuZGxlciA9IHJ1bGUuaGFuZGxlcih7XG4gICAgICAgIHN0YXRlLFxuICAgICAgICByYW5nZSxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIGNvbW1hbmRzLFxuICAgICAgICBjaGFpbixcbiAgICAgICAgY2FuLFxuICAgICAgICBwYXN0ZUV2ZW50LFxuICAgICAgICBkcm9wRXZlbnRcbiAgICAgIH0pO1xuICAgICAgaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICB9KTtcbiAgfSk7XG4gIGNvbnN0IHN1Y2Nlc3MgPSBoYW5kbGVycy5ldmVyeSgoaGFuZGxlcikgPT4gaGFuZGxlciAhPT0gbnVsbCk7XG4gIHJldHVybiBzdWNjZXNzO1xufVxudmFyIHRpcHRhcERyYWdGcm9tT3RoZXJFZGl0b3IgPSBudWxsO1xudmFyIGNyZWF0ZUNsaXBib2FyZFBhc3RlRXZlbnQgPSAodGV4dCkgPT4ge1xuICB2YXIgX2E7XG4gIGNvbnN0IGV2ZW50ID0gbmV3IENsaXBib2FyZEV2ZW50KFwicGFzdGVcIiwge1xuICAgIGNsaXBib2FyZERhdGE6IG5ldyBEYXRhVHJhbnNmZXIoKVxuICB9KTtcbiAgKF9hID0gZXZlbnQuY2xpcGJvYXJkRGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNldERhdGEoXCJ0ZXh0L2h0bWxcIiwgdGV4dCk7XG4gIHJldHVybiBldmVudDtcbn07XG5mdW5jdGlvbiBwYXN0ZVJ1bGVzUGx1Z2luKHByb3BzKSB7XG4gIGNvbnN0IHsgZWRpdG9yLCBydWxlcyB9ID0gcHJvcHM7XG4gIGxldCBkcmFnU291cmNlRWxlbWVudCA9IG51bGw7XG4gIGxldCBpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvciA9IGZhbHNlO1xuICBsZXQgaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yID0gZmFsc2U7XG4gIGxldCBwYXN0ZUV2ZW50ID0gdHlwZW9mIENsaXBib2FyZEV2ZW50ICE9PSBcInVuZGVmaW5lZFwiID8gbmV3IENsaXBib2FyZEV2ZW50KFwicGFzdGVcIikgOiBudWxsO1xuICBsZXQgZHJvcEV2ZW50O1xuICB0cnkge1xuICAgIGRyb3BFdmVudCA9IHR5cGVvZiBEcmFnRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgPyBuZXcgRHJhZ0V2ZW50KFwiZHJvcFwiKSA6IG51bGw7XG4gIH0gY2F0Y2gge1xuICAgIGRyb3BFdmVudCA9IG51bGw7XG4gIH1cbiAgY29uc3QgcHJvY2Vzc0V2ZW50ID0gKHtcbiAgICBzdGF0ZSxcbiAgICBmcm9tLFxuICAgIHRvLFxuICAgIHJ1bGUsXG4gICAgcGFzdGVFdnRcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHRyID0gc3RhdGUudHI7XG4gICAgY29uc3QgY2hhaW5hYmxlU3RhdGUgPSBjcmVhdGVDaGFpbmFibGVTdGF0ZSh7XG4gICAgICBzdGF0ZSxcbiAgICAgIHRyYW5zYWN0aW9uOiB0clxuICAgIH0pO1xuICAgIGNvbnN0IGhhbmRsZXIgPSBydW4yKHtcbiAgICAgIGVkaXRvcixcbiAgICAgIHN0YXRlOiBjaGFpbmFibGVTdGF0ZSxcbiAgICAgIGZyb206IE1hdGgubWF4KGZyb20gLSAxLCAwKSxcbiAgICAgIHRvOiB0by5iIC0gMSxcbiAgICAgIHJ1bGUsXG4gICAgICBwYXN0ZUV2ZW50OiBwYXN0ZUV2dCxcbiAgICAgIGRyb3BFdmVudFxuICAgIH0pO1xuICAgIGlmICghaGFuZGxlciB8fCAhdHIuc3RlcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBkcm9wRXZlbnQgPSB0eXBlb2YgRHJhZ0V2ZW50ICE9PSBcInVuZGVmaW5lZFwiID8gbmV3IERyYWdFdmVudChcImRyb3BcIikgOiBudWxsO1xuICAgIH0gY2F0Y2gge1xuICAgICAgZHJvcEV2ZW50ID0gbnVsbDtcbiAgICB9XG4gICAgcGFzdGVFdmVudCA9IHR5cGVvZiBDbGlwYm9hcmRFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IG5ldyBDbGlwYm9hcmRFdmVudChcInBhc3RlXCIpIDogbnVsbDtcbiAgICByZXR1cm4gdHI7XG4gIH07XG4gIGNvbnN0IHBsdWdpbnMgPSBydWxlcy5tYXAoKHJ1bGUpID0+IHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbjIoe1xuICAgICAgLy8gd2UgcmVnaXN0ZXIgYSBnbG9iYWwgZHJhZyBoYW5kbGVyIHRvIHRyYWNrIHRoZSBjdXJyZW50IGRyYWcgc291cmNlIGVsZW1lbnRcbiAgICAgIHZpZXcodmlldykge1xuICAgICAgICBjb25zdCBoYW5kbGVEcmFnc3RhcnQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgZHJhZ1NvdXJjZUVsZW1lbnQgPSAoKF9hID0gdmlldy5kb20ucGFyZW50RWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpID8gdmlldy5kb20ucGFyZW50RWxlbWVudCA6IG51bGw7XG4gICAgICAgICAgaWYgKGRyYWdTb3VyY2VFbGVtZW50KSB7XG4gICAgICAgICAgICB0aXB0YXBEcmFnRnJvbU90aGVyRWRpdG9yID0gZWRpdG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaGFuZGxlRHJhZ2VuZCA9ICgpID0+IHtcbiAgICAgICAgICBpZiAodGlwdGFwRHJhZ0Zyb21PdGhlckVkaXRvcikge1xuICAgICAgICAgICAgdGlwdGFwRHJhZ0Zyb21PdGhlckVkaXRvciA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLCBoYW5kbGVEcmFnc3RhcnQpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdlbmRcIiwgaGFuZGxlRHJhZ2VuZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGVzdHJveSgpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZHJhZ3N0YXJ0XCIsIGhhbmRsZURyYWdzdGFydCk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRyYWdlbmRcIiwgaGFuZGxlRHJhZ2VuZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgIGRyb3A6ICh2aWV3LCBldmVudCkgPT4ge1xuICAgICAgICAgICAgaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yID0gZHJhZ1NvdXJjZUVsZW1lbnQgPT09IHZpZXcuZG9tLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBkcm9wRXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgIGlmICghaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRyYWdGcm9tT3RoZXJFZGl0b3IgPSB0aXB0YXBEcmFnRnJvbU90aGVyRWRpdG9yO1xuICAgICAgICAgICAgICBpZiAoZHJhZ0Zyb21PdGhlckVkaXRvciA9PSBudWxsID8gdm9pZCAwIDogZHJhZ0Zyb21PdGhlckVkaXRvci5pc0VkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBkcmFnRnJvbU90aGVyRWRpdG9yLnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0Zyb21PdGhlckVkaXRvci5jb21tYW5kcy5kZWxldGVSYW5nZSh7IGZyb206IHNlbGVjdGlvbi5mcm9tLCB0bzogc2VsZWN0aW9uLnRvIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcGFzdGU6IChfdmlldywgZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGh0bWwgPSAoX2EgPSBldmVudC5jbGlwYm9hcmREYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZ2V0RGF0YShcInRleHQvaHRtbFwiKTtcbiAgICAgICAgICAgIHBhc3RlRXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgIGlzUGFzdGVkRnJvbVByb3NlTWlycm9yID0gISEoaHRtbCA9PSBudWxsID8gdm9pZCAwIDogaHRtbC5pbmNsdWRlcyhcImRhdGEtcG0tc2xpY2VcIikpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFwcGVuZFRyYW5zYWN0aW9uOiAodHJhbnNhY3Rpb25zLCBvbGRTdGF0ZSwgc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbnNbMF07XG4gICAgICAgIGNvbnN0IGlzUGFzdGUgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKFwidWlFdmVudFwiKSA9PT0gXCJwYXN0ZVwiICYmICFpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvcjtcbiAgICAgICAgY29uc3QgaXNEcm9wID0gdHJhbnNhY3Rpb24uZ2V0TWV0YShcInVpRXZlbnRcIikgPT09IFwiZHJvcFwiICYmICFpc0Ryb3BwZWRGcm9tUHJvc2VNaXJyb3I7XG4gICAgICAgIGNvbnN0IHNpbXVsYXRlZFBhc3RlTWV0YSA9IHRyYW5zYWN0aW9uLmdldE1ldGEoXCJhcHBseVBhc3RlUnVsZXNcIik7XG4gICAgICAgIGNvbnN0IGlzU2ltdWxhdGVkUGFzdGUgPSAhIXNpbXVsYXRlZFBhc3RlTWV0YTtcbiAgICAgICAgaWYgKCFpc1Bhc3RlICYmICFpc0Ryb3AgJiYgIWlzU2ltdWxhdGVkUGFzdGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU2ltdWxhdGVkUGFzdGUpIHtcbiAgICAgICAgICBsZXQgeyB0ZXh0IH0gPSBzaW11bGF0ZWRQYXN0ZU1ldGE7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dCA9IGdldEhUTUxGcm9tRnJhZ21lbnQoRnJhZ21lbnQ1LmZyb20odGV4dCksIHN0YXRlLnNjaGVtYSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHsgZnJvbTogZnJvbTIgfSA9IHNpbXVsYXRlZFBhc3RlTWV0YTtcbiAgICAgICAgICBjb25zdCB0bzIgPSBmcm9tMiArIHRleHQubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IHBhc3RlRXZ0ID0gY3JlYXRlQ2xpcGJvYXJkUGFzdGVFdmVudCh0ZXh0KTtcbiAgICAgICAgICByZXR1cm4gcHJvY2Vzc0V2ZW50KHtcbiAgICAgICAgICAgIHJ1bGUsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIGZyb206IGZyb20yLFxuICAgICAgICAgICAgdG86IHsgYjogdG8yIH0sXG4gICAgICAgICAgICBwYXN0ZUV2dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyb20gPSBvbGRTdGF0ZS5kb2MuY29udGVudC5maW5kRGlmZlN0YXJ0KHN0YXRlLmRvYy5jb250ZW50KTtcbiAgICAgICAgY29uc3QgdG8gPSBvbGRTdGF0ZS5kb2MuY29udGVudC5maW5kRGlmZkVuZChzdGF0ZS5kb2MuY29udGVudCk7XG4gICAgICAgIGlmICghaXNOdW1iZXIoZnJvbSkgfHwgIXRvIHx8IGZyb20gPT09IHRvLmIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2Nlc3NFdmVudCh7XG4gICAgICAgICAgcnVsZSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBmcm9tLFxuICAgICAgICAgIHRvLFxuICAgICAgICAgIHBhc3RlRXZ0OiBwYXN0ZUV2ZW50XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHBsdWdpbnM7XG59XG5cbi8vIHNyYy9FeHRlbnNpb25NYW5hZ2VyLnRzXG52YXIgRXh0ZW5zaW9uTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZXh0ZW5zaW9ucywgZWRpdG9yKSB7XG4gICAgdGhpcy5zcGxpdHRhYmxlTWFya3MgPSBbXTtcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICB0aGlzLmJhc2VFeHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSByZXNvbHZlRXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgICB0aGlzLnNjaGVtYSA9IGdldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zKHRoaXMuZXh0ZW5zaW9ucywgZWRpdG9yKTtcbiAgICB0aGlzLnNldHVwRXh0ZW5zaW9ucygpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYWxsIGNvbW1hbmRzIGZyb20gdGhlIGV4dGVuc2lvbnMuXG4gICAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIGFsbCBjb21tYW5kcyB3aGVyZSB0aGUga2V5IGlzIHRoZSBjb21tYW5kIG5hbWUgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgY29tbWFuZCBmdW5jdGlvblxuICAgKi9cbiAgZ2V0IGNvbW1hbmRzKCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnMucmVkdWNlKChjb21tYW5kcywgZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgIHN0b3JhZ2U6IHRoaXMuZWRpdG9yLmV4dGVuc2lvblN0b3JhZ2VbZXh0ZW5zaW9uLm5hbWVdLFxuICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICB0eXBlOiBnZXRTY2hlbWFUeXBlQnlOYW1lKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSlcbiAgICAgIH07XG4gICAgICBjb25zdCBhZGRDb21tYW5kcyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJhZGRDb21tYW5kc1wiLCBjb250ZXh0KTtcbiAgICAgIGlmICghYWRkQ29tbWFuZHMpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY29tbWFuZHMsXG4gICAgICAgIC4uLmFkZENvbW1hbmRzKClcbiAgICAgIH07XG4gICAgfSwge30pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYWxsIHJlZ2lzdGVyZWQgUHJvc2VtaXJyb3IgcGx1Z2lucyBmcm9tIHRoZSBleHRlbnNpb25zLlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBQcm9zZW1pcnJvciBwbHVnaW5zXG4gICAqL1xuICBnZXQgcGx1Z2lucygpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcztcbiAgICBjb25zdCBleHRlbnNpb25zID0gc29ydEV4dGVuc2lvbnMoWy4uLnRoaXMuZXh0ZW5zaW9uc10ucmV2ZXJzZSgpKTtcbiAgICBjb25zdCBhbGxQbHVnaW5zID0gZXh0ZW5zaW9ucy5mbGF0TWFwKChleHRlbnNpb24pID0+IHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgc3RvcmFnZTogdGhpcy5lZGl0b3IuZXh0ZW5zaW9uU3RvcmFnZVtleHRlbnNpb24ubmFtZV0sXG4gICAgICAgIGVkaXRvcixcbiAgICAgICAgdHlwZTogZ2V0U2NoZW1hVHlwZUJ5TmFtZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpXG4gICAgICB9O1xuICAgICAgY29uc3QgcGx1Z2lucyA9IFtdO1xuICAgICAgY29uc3QgYWRkS2V5Ym9hcmRTaG9ydGN1dHMgPSBnZXRFeHRlbnNpb25GaWVsZChcbiAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICBcImFkZEtleWJvYXJkU2hvcnRjdXRzXCIsXG4gICAgICAgIGNvbnRleHRcbiAgICAgICk7XG4gICAgICBsZXQgZGVmYXVsdEJpbmRpbmdzID0ge307XG4gICAgICBpZiAoZXh0ZW5zaW9uLnR5cGUgPT09IFwibWFya1wiICYmIGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJleGl0YWJsZVwiLCBjb250ZXh0KSkge1xuICAgICAgICBkZWZhdWx0QmluZGluZ3MuQXJyb3dSaWdodCA9ICgpID0+IE1hcmsuaGFuZGxlRXhpdCh7IGVkaXRvciwgbWFyazogZXh0ZW5zaW9uIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGFkZEtleWJvYXJkU2hvcnRjdXRzKSB7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGFkZEtleWJvYXJkU2hvcnRjdXRzKCkpLm1hcCgoW3Nob3J0Y3V0LCBtZXRob2RdKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW3Nob3J0Y3V0LCAoKSA9PiBtZXRob2QoeyBlZGl0b3IgfSldO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGRlZmF1bHRCaW5kaW5ncyA9IHsgLi4uZGVmYXVsdEJpbmRpbmdzLCAuLi5iaW5kaW5ncyB9O1xuICAgICAgfVxuICAgICAgY29uc3Qga2V5TWFwUGx1Z2luID0ga2V5bWFwKGRlZmF1bHRCaW5kaW5ncyk7XG4gICAgICBwbHVnaW5zLnB1c2goa2V5TWFwUGx1Z2luKTtcbiAgICAgIGNvbnN0IGFkZElucHV0UnVsZXMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwiYWRkSW5wdXRSdWxlc1wiLCBjb250ZXh0KTtcbiAgICAgIGlmIChpc0V4dGVuc2lvblJ1bGVzRW5hYmxlZChleHRlbnNpb24sIGVkaXRvci5vcHRpb25zLmVuYWJsZUlucHV0UnVsZXMpICYmIGFkZElucHV0UnVsZXMpIHtcbiAgICAgICAgY29uc3QgcnVsZXMgPSBhZGRJbnB1dFJ1bGVzKCk7XG4gICAgICAgIGlmIChydWxlcyAmJiBydWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBpbnB1dFJlc3VsdCA9IGlucHV0UnVsZXNQbHVnaW4oe1xuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgcnVsZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBpbnB1dFBsdWdpbnMgPSBBcnJheS5pc0FycmF5KGlucHV0UmVzdWx0KSA/IGlucHV0UmVzdWx0IDogW2lucHV0UmVzdWx0XTtcbiAgICAgICAgICBwbHVnaW5zLnB1c2goLi4uaW5wdXRQbHVnaW5zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgYWRkUGFzdGVSdWxlcyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJhZGRQYXN0ZVJ1bGVzXCIsIGNvbnRleHQpO1xuICAgICAgaWYgKGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkKGV4dGVuc2lvbiwgZWRpdG9yLm9wdGlvbnMuZW5hYmxlUGFzdGVSdWxlcykgJiYgYWRkUGFzdGVSdWxlcykge1xuICAgICAgICBjb25zdCBydWxlcyA9IGFkZFBhc3RlUnVsZXMoKTtcbiAgICAgICAgaWYgKHJ1bGVzICYmIHJ1bGVzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHBhc3RlUnVsZXMgPSBwYXN0ZVJ1bGVzUGx1Z2luKHsgZWRpdG9yLCBydWxlcyB9KTtcbiAgICAgICAgICBwbHVnaW5zLnB1c2goLi4ucGFzdGVSdWxlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGFkZFByb3NlTWlycm9yUGx1Z2lucyA9IGdldEV4dGVuc2lvbkZpZWxkKFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgIFwiYWRkUHJvc2VNaXJyb3JQbHVnaW5zXCIsXG4gICAgICAgIGNvbnRleHRcbiAgICAgICk7XG4gICAgICBpZiAoYWRkUHJvc2VNaXJyb3JQbHVnaW5zKSB7XG4gICAgICAgIGNvbnN0IHByb3NlTWlycm9yUGx1Z2lucyA9IGFkZFByb3NlTWlycm9yUGx1Z2lucygpO1xuICAgICAgICBwbHVnaW5zLnB1c2goLi4ucHJvc2VNaXJyb3JQbHVnaW5zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwbHVnaW5zO1xuICAgIH0pO1xuICAgIHJldHVybiBhbGxQbHVnaW5zO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYWxsIGF0dHJpYnV0ZXMgZnJvbSB0aGUgZXh0ZW5zaW9ucy5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgYXR0cmlidXRlc1xuICAgKi9cbiAgZ2V0IGF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyh0aGlzLmV4dGVuc2lvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYWxsIG5vZGUgdmlld3MgZnJvbSB0aGUgZXh0ZW5zaW9ucy5cbiAgICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggYWxsIG5vZGUgdmlld3Mgd2hlcmUgdGhlIGtleSBpcyB0aGUgbm9kZSBuYW1lIGFuZCB0aGUgdmFsdWUgaXMgdGhlIG5vZGUgdmlldyBmdW5jdGlvblxuICAgKi9cbiAgZ2V0IG5vZGVWaWV3cygpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcztcbiAgICBjb25zdCB7IG5vZGVFeHRlbnNpb25zIH0gPSBzcGxpdEV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zKTtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgbm9kZUV4dGVuc2lvbnMuZmlsdGVyKChleHRlbnNpb24pID0+ICEhZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImFkZE5vZGVWaWV3XCIpKS5tYXAoKGV4dGVuc2lvbikgPT4ge1xuICAgICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzLmZpbHRlcigoYXR0cmlidXRlKSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gZXh0ZW5zaW9uLm5hbWUpO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgIHN0b3JhZ2U6IHRoaXMuZWRpdG9yLmV4dGVuc2lvblN0b3JhZ2VbZXh0ZW5zaW9uLm5hbWVdLFxuICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICB0eXBlOiBnZXROb2RlVHlwZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFkZE5vZGVWaWV3ID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImFkZE5vZGVWaWV3XCIsIGNvbnRleHQpO1xuICAgICAgICBpZiAoIWFkZE5vZGVWaWV3KSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGV2aWV3ID0gKG5vZGUsIHZpZXcsIGdldFBvcywgZGVjb3JhdGlvbnMsIGlubmVyRGVjb3JhdGlvbnMpID0+IHtcbiAgICAgICAgICBjb25zdCBIVE1MQXR0cmlidXRlcyA9IGdldFJlbmRlcmVkQXR0cmlidXRlcyhub2RlLCBleHRlbnNpb25BdHRyaWJ1dGVzKTtcbiAgICAgICAgICByZXR1cm4gYWRkTm9kZVZpZXcoKSh7XG4gICAgICAgICAgICAvLyBwYXNzLXRocm91Z2hcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICB2aWV3LFxuICAgICAgICAgICAgZ2V0UG9zLFxuICAgICAgICAgICAgZGVjb3JhdGlvbnMsXG4gICAgICAgICAgICBpbm5lckRlY29yYXRpb25zLFxuICAgICAgICAgICAgLy8gdGlwdGFwLXNwZWNpZmljXG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gW2V4dGVuc2lvbi5uYW1lLCBub2Rldmlld107XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgZ2V0IG1hcmtWaWV3cygpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcztcbiAgICBjb25zdCB7IG1hcmtFeHRlbnNpb25zIH0gPSBzcGxpdEV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zKTtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgbWFya0V4dGVuc2lvbnMuZmlsdGVyKChleHRlbnNpb24pID0+ICEhZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImFkZE1hcmtWaWV3XCIpKS5tYXAoKGV4dGVuc2lvbikgPT4ge1xuICAgICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzLmZpbHRlcigoYXR0cmlidXRlKSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gZXh0ZW5zaW9uLm5hbWUpO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgIHN0b3JhZ2U6IHRoaXMuZWRpdG9yLmV4dGVuc2lvblN0b3JhZ2VbZXh0ZW5zaW9uLm5hbWVdLFxuICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICB0eXBlOiBnZXRNYXJrVHlwZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFkZE1hcmtWaWV3ID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImFkZE1hcmtWaWV3XCIsIGNvbnRleHQpO1xuICAgICAgICBpZiAoIWFkZE1hcmtWaWV3KSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hcmtWaWV3ID0gKG1hcmssIHZpZXcsIGlubGluZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IEhUTUxBdHRyaWJ1dGVzID0gZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKG1hcmssIGV4dGVuc2lvbkF0dHJpYnV0ZXMpO1xuICAgICAgICAgIHJldHVybiBhZGRNYXJrVmlldygpKHtcbiAgICAgICAgICAgIC8vIHBhc3MtdGhyb3VnaFxuICAgICAgICAgICAgbWFyayxcbiAgICAgICAgICAgIHZpZXcsXG4gICAgICAgICAgICBpbmxpbmUsXG4gICAgICAgICAgICAvLyB0aXB0YXAtc3BlY2lmaWNcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgdXBkYXRlQXR0cmlidXRlczogKGF0dHJzKSA9PiB7XG4gICAgICAgICAgICAgIHVwZGF0ZU1hcmtWaWV3QXR0cmlidXRlcyhtYXJrLCBlZGl0b3IsIGF0dHJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFtleHRlbnNpb24ubmFtZSwgbWFya1ZpZXddO1xuICAgICAgfSlcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBHbyB0aHJvdWdoIGFsbCBleHRlbnNpb25zLCBjcmVhdGUgZXh0ZW5zaW9uIHN0b3JhZ2VzICYgc2V0dXAgbWFya3NcbiAgICogJiBiaW5kIGVkaXRvciBldmVudCBsaXN0ZW5lci5cbiAgICovXG4gIHNldHVwRXh0ZW5zaW9ucygpIHtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIHRoaXMuZWRpdG9yLmV4dGVuc2lvblN0b3JhZ2UgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBleHRlbnNpb25zLm1hcCgoZXh0ZW5zaW9uKSA9PiBbZXh0ZW5zaW9uLm5hbWUsIGV4dGVuc2lvbi5zdG9yYWdlXSlcbiAgICApO1xuICAgIGV4dGVuc2lvbnMuZm9yRWFjaCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgIHN0b3JhZ2U6IHRoaXMuZWRpdG9yLmV4dGVuc2lvblN0b3JhZ2VbZXh0ZW5zaW9uLm5hbWVdLFxuICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICB0eXBlOiBnZXRTY2hlbWFUeXBlQnlOYW1lKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSlcbiAgICAgIH07XG4gICAgICBpZiAoZXh0ZW5zaW9uLnR5cGUgPT09IFwibWFya1wiKSB7XG4gICAgICAgIGNvbnN0IGtlZXBPblNwbGl0ID0gKF9hID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJrZWVwT25TcGxpdFwiLCBjb250ZXh0KSkpICE9IG51bGwgPyBfYSA6IHRydWU7XG4gICAgICAgIGlmIChrZWVwT25TcGxpdCkge1xuICAgICAgICAgIHRoaXMuc3BsaXR0YWJsZU1hcmtzLnB1c2goZXh0ZW5zaW9uLm5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBvbkJlZm9yZUNyZWF0ZSA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJvbkJlZm9yZUNyZWF0ZVwiLCBjb250ZXh0KTtcbiAgICAgIGNvbnN0IG9uQ3JlYXRlID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcIm9uQ3JlYXRlXCIsIGNvbnRleHQpO1xuICAgICAgY29uc3Qgb25VcGRhdGUgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwib25VcGRhdGVcIiwgY29udGV4dCk7XG4gICAgICBjb25zdCBvblNlbGVjdGlvblVwZGF0ZSA9IGdldEV4dGVuc2lvbkZpZWxkKFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgIFwib25TZWxlY3Rpb25VcGRhdGVcIixcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICAgIGNvbnN0IG9uVHJhbnNhY3Rpb24gPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwib25UcmFuc2FjdGlvblwiLCBjb250ZXh0KTtcbiAgICAgIGNvbnN0IG9uRm9jdXMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwib25Gb2N1c1wiLCBjb250ZXh0KTtcbiAgICAgIGNvbnN0IG9uQmx1ciA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJvbkJsdXJcIiwgY29udGV4dCk7XG4gICAgICBjb25zdCBvbkRlc3Ryb3kgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwib25EZXN0cm95XCIsIGNvbnRleHQpO1xuICAgICAgaWYgKG9uQmVmb3JlQ3JlYXRlKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKFwiYmVmb3JlQ3JlYXRlXCIsIG9uQmVmb3JlQ3JlYXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvbkNyZWF0ZSkge1xuICAgICAgICB0aGlzLmVkaXRvci5vbihcImNyZWF0ZVwiLCBvbkNyZWF0ZSk7XG4gICAgICB9XG4gICAgICBpZiAob25VcGRhdGUpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oXCJ1cGRhdGVcIiwgb25VcGRhdGUpO1xuICAgICAgfVxuICAgICAgaWYgKG9uU2VsZWN0aW9uVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKFwic2VsZWN0aW9uVXBkYXRlXCIsIG9uU2VsZWN0aW9uVXBkYXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvblRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKFwidHJhbnNhY3Rpb25cIiwgb25UcmFuc2FjdGlvbik7XG4gICAgICB9XG4gICAgICBpZiAob25Gb2N1cykge1xuICAgICAgICB0aGlzLmVkaXRvci5vbihcImZvY3VzXCIsIG9uRm9jdXMpO1xuICAgICAgfVxuICAgICAgaWYgKG9uQmx1cikge1xuICAgICAgICB0aGlzLmVkaXRvci5vbihcImJsdXJcIiwgb25CbHVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChvbkRlc3Ryb3kpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oXCJkZXN0cm95XCIsIG9uRGVzdHJveSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5FeHRlbnNpb25NYW5hZ2VyLnJlc29sdmUgPSByZXNvbHZlRXh0ZW5zaW9ucztcbkV4dGVuc2lvbk1hbmFnZXIuc29ydCA9IHNvcnRFeHRlbnNpb25zO1xuRXh0ZW5zaW9uTWFuYWdlci5mbGF0dGVuID0gZmxhdHRlbkV4dGVuc2lvbnM7XG5cbi8vIHNyYy9leHRlbnNpb25zL2luZGV4LnRzXG52YXIgZXh0ZW5zaW9uc19leHBvcnRzID0ge307XG5fX2V4cG9ydChleHRlbnNpb25zX2V4cG9ydHMsIHtcbiAgQ2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXI6ICgpID0+IENsaXBib2FyZFRleHRTZXJpYWxpemVyLFxuICBDb21tYW5kczogKCkgPT4gQ29tbWFuZHMsXG4gIERlbGV0ZTogKCkgPT4gRGVsZXRlLFxuICBEcm9wOiAoKSA9PiBEcm9wLFxuICBFZGl0YWJsZTogKCkgPT4gRWRpdGFibGUsXG4gIEZvY3VzRXZlbnRzOiAoKSA9PiBGb2N1c0V2ZW50cyxcbiAgS2V5bWFwOiAoKSA9PiBLZXltYXAsXG4gIFBhc3RlOiAoKSA9PiBQYXN0ZSxcbiAgVGFiaW5kZXg6ICgpID0+IFRhYmluZGV4LFxuICBmb2N1c0V2ZW50c1BsdWdpbktleTogKCkgPT4gZm9jdXNFdmVudHNQbHVnaW5LZXlcbn0pO1xuXG4vLyBzcmMvZXh0ZW5zaW9ucy9jbGlwYm9hcmRUZXh0U2VyaWFsaXplci50c1xuaW1wb3J0IHsgUGx1Z2luIGFzIFBsdWdpbjMsIFBsdWdpbktleSB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG5cbi8vIHNyYy9FeHRlbnNpb24udHNcbnZhciBFeHRlbnNpb24gPSBjbGFzcyBfRXh0ZW5zaW9uIGV4dGVuZHMgRXh0ZW5kYWJsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gXCJleHRlbnNpb25cIjtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEV4dGVuc2lvbiBpbnN0YW5jZVxuICAgKiBAcGFyYW0gY29uZmlnIC0gRXh0ZW5zaW9uIGNvbmZpZ3VyYXRpb24gb2JqZWN0IG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICovXG4gIHN0YXRpYyBjcmVhdGUoY29uZmlnID0ge30pIHtcbiAgICBjb25zdCByZXNvbHZlZENvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09IFwiZnVuY3Rpb25cIiA/IGNvbmZpZygpIDogY29uZmlnO1xuICAgIHJldHVybiBuZXcgX0V4dGVuc2lvbihyZXNvbHZlZENvbmZpZyk7XG4gIH1cbiAgY29uZmlndXJlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc3VwZXIuY29uZmlndXJlKG9wdGlvbnMpO1xuICB9XG4gIGV4dGVuZChleHRlbmRlZENvbmZpZykge1xuICAgIGNvbnN0IHJlc29sdmVkQ29uZmlnID0gdHlwZW9mIGV4dGVuZGVkQ29uZmlnID09PSBcImZ1bmN0aW9uXCIgPyBleHRlbmRlZENvbmZpZygpIDogZXh0ZW5kZWRDb25maWc7XG4gICAgcmV0dXJuIHN1cGVyLmV4dGVuZChyZXNvbHZlZENvbmZpZyk7XG4gIH1cbn07XG5cbi8vIHNyYy9leHRlbnNpb25zL2NsaXBib2FyZFRleHRTZXJpYWxpemVyLnRzXG52YXIgQ2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogXCJjbGlwYm9hcmRUZXh0U2VyaWFsaXplclwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBibG9ja1NlcGFyYXRvcjogdm9pZCAwXG4gICAgfTtcbiAgfSxcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luMyh7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleShcImNsaXBib2FyZFRleHRTZXJpYWxpemVyXCIpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGNsaXBib2FyZFRleHRTZXJpYWxpemVyOiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUsIHNjaGVtYSB9ID0gZWRpdG9yO1xuICAgICAgICAgICAgY29uc3QgeyBkb2MsIHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCB7IHJhbmdlcyB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IE1hdGgubWluKC4uLnJhbmdlcy5tYXAoKHJhbmdlMikgPT4gcmFuZ2UyLiRmcm9tLnBvcykpO1xuICAgICAgICAgICAgY29uc3QgdG8gPSBNYXRoLm1heCguLi5yYW5nZXMubWFwKChyYW5nZTIpID0+IHJhbmdlMi4kdG8ucG9zKSk7XG4gICAgICAgICAgICBjb25zdCB0ZXh0U2VyaWFsaXplcnMgPSBnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hKHNjaGVtYSk7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHsgZnJvbSwgdG8gfTtcbiAgICAgICAgICAgIHJldHVybiBnZXRUZXh0QmV0d2Vlbihkb2MsIHJhbmdlLCB7XG4gICAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucy5ibG9ja1NlcGFyYXRvciAhPT0gdm9pZCAwID8geyBibG9ja1NlcGFyYXRvcjogdGhpcy5vcHRpb25zLmJsb2NrU2VwYXJhdG9yIH0gOiB7fSxcbiAgICAgICAgICAgICAgdGV4dFNlcmlhbGl6ZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9leHRlbnNpb25zL2NvbW1hbmRzLnRzXG52YXIgQ29tbWFuZHMgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogXCJjb21tYW5kc1wiLFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29tbWFuZHNfZXhwb3J0c1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvZXh0ZW5zaW9ucy9kZWxldGUudHNcbmltcG9ydCB7IFJlbW92ZU1hcmtTdGVwIH0gZnJvbSBcIkB0aXB0YXAvcG0vdHJhbnNmb3JtXCI7XG52YXIgRGVsZXRlID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6IFwiZGVsZXRlXCIsXG4gIG9uVXBkYXRlKHsgdHJhbnNhY3Rpb24sIGFwcGVuZGVkVHJhbnNhY3Rpb25zIH0pIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHZhciBfYTIsIF9iMiwgX2MyLCBfZDtcbiAgICAgIGlmICgoX2QgPSAoX2MyID0gKF9iMiA9IChfYTIgPSB0aGlzLmVkaXRvci5vcHRpb25zLmNvcmVFeHRlbnNpb25PcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmRlbGV0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5maWx0ZXJUcmFuc2FjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jMi5jYWxsKF9iMiwgdHJhbnNhY3Rpb24pKSAhPSBudWxsID8gX2QgOiB0cmFuc2FjdGlvbi5nZXRNZXRhKFwieS1zeW5jJFwiKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0VHJhbnNhY3Rpb24gPSBjb21iaW5lVHJhbnNhY3Rpb25TdGVwcyh0cmFuc2FjdGlvbi5iZWZvcmUsIFt0cmFuc2FjdGlvbiwgLi4uYXBwZW5kZWRUcmFuc2FjdGlvbnNdKTtcbiAgICAgIGNvbnN0IGNoYW5nZXMgPSBnZXRDaGFuZ2VkUmFuZ2VzKG5leHRUcmFuc2FjdGlvbik7XG4gICAgICBjaGFuZ2VzLmZvckVhY2goKGNoYW5nZSkgPT4ge1xuICAgICAgICBpZiAobmV4dFRyYW5zYWN0aW9uLm1hcHBpbmcubWFwUmVzdWx0KGNoYW5nZS5vbGRSYW5nZS5mcm9tKS5kZWxldGVkQWZ0ZXIgJiYgbmV4dFRyYW5zYWN0aW9uLm1hcHBpbmcubWFwUmVzdWx0KGNoYW5nZS5vbGRSYW5nZS50bykuZGVsZXRlZEJlZm9yZSkge1xuICAgICAgICAgIG5leHRUcmFuc2FjdGlvbi5iZWZvcmUubm9kZXNCZXR3ZWVuKGNoYW5nZS5vbGRSYW5nZS5mcm9tLCBjaGFuZ2Uub2xkUmFuZ2UudG8sIChub2RlLCBmcm9tKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0byA9IGZyb20gKyBub2RlLm5vZGVTaXplIC0gMjtcbiAgICAgICAgICAgIGNvbnN0IGlzRnVsbHlXaXRoaW5SYW5nZSA9IGNoYW5nZS5vbGRSYW5nZS5mcm9tIDw9IGZyb20gJiYgdG8gPD0gY2hhbmdlLm9sZFJhbmdlLnRvO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IuZW1pdChcImRlbGV0ZVwiLCB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibm9kZVwiLFxuICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgbmV3RnJvbTogbmV4dFRyYW5zYWN0aW9uLm1hcHBpbmcubWFwKGZyb20pLFxuICAgICAgICAgICAgICBuZXdUbzogbmV4dFRyYW5zYWN0aW9uLm1hcHBpbmcubWFwKHRvKSxcbiAgICAgICAgICAgICAgZGVsZXRlZFJhbmdlOiBjaGFuZ2Uub2xkUmFuZ2UsXG4gICAgICAgICAgICAgIG5ld1JhbmdlOiBjaGFuZ2UubmV3UmFuZ2UsXG4gICAgICAgICAgICAgIHBhcnRpYWw6ICFpc0Z1bGx5V2l0aGluUmFuZ2UsXG4gICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICBjb21iaW5lZFRyYW5zZm9ybTogbmV4dFRyYW5zYWN0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBtYXBwaW5nID0gbmV4dFRyYW5zYWN0aW9uLm1hcHBpbmc7XG4gICAgICBuZXh0VHJhbnNhY3Rpb24uc3RlcHMuZm9yRWFjaCgoc3RlcCwgaW5kZXgpID0+IHtcbiAgICAgICAgdmFyIF9hMywgX2IzO1xuICAgICAgICBpZiAoc3RlcCBpbnN0YW5jZW9mIFJlbW92ZU1hcmtTdGVwKSB7XG4gICAgICAgICAgY29uc3QgbmV3U3RhcnQgPSBtYXBwaW5nLnNsaWNlKGluZGV4KS5tYXAoc3RlcC5mcm9tLCAtMSk7XG4gICAgICAgICAgY29uc3QgbmV3RW5kID0gbWFwcGluZy5zbGljZShpbmRleCkubWFwKHN0ZXAudG8pO1xuICAgICAgICAgIGNvbnN0IG9sZFN0YXJ0ID0gbWFwcGluZy5pbnZlcnQoKS5tYXAobmV3U3RhcnQsIC0xKTtcbiAgICAgICAgICBjb25zdCBvbGRFbmQgPSBtYXBwaW5nLmludmVydCgpLm1hcChuZXdFbmQpO1xuICAgICAgICAgIGNvbnN0IGZvdW5kQmVmb3JlTWFyayA9IChfYTMgPSBuZXh0VHJhbnNhY3Rpb24uZG9jLm5vZGVBdChuZXdTdGFydCAtIDEpKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLm1hcmtzLnNvbWUoKG1hcmspID0+IG1hcmsuZXEoc3RlcC5tYXJrKSk7XG4gICAgICAgICAgY29uc3QgZm91bmRBZnRlck1hcmsgPSAoX2IzID0gbmV4dFRyYW5zYWN0aW9uLmRvYy5ub2RlQXQobmV3RW5kKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMy5tYXJrcy5zb21lKChtYXJrKSA9PiBtYXJrLmVxKHN0ZXAubWFyaykpO1xuICAgICAgICAgIHRoaXMuZWRpdG9yLmVtaXQoXCJkZWxldGVcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJtYXJrXCIsXG4gICAgICAgICAgICBtYXJrOiBzdGVwLm1hcmssXG4gICAgICAgICAgICBmcm9tOiBzdGVwLmZyb20sXG4gICAgICAgICAgICB0bzogc3RlcC50byxcbiAgICAgICAgICAgIGRlbGV0ZWRSYW5nZToge1xuICAgICAgICAgICAgICBmcm9tOiBvbGRTdGFydCxcbiAgICAgICAgICAgICAgdG86IG9sZEVuZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5ld1JhbmdlOiB7XG4gICAgICAgICAgICAgIGZyb206IG5ld1N0YXJ0LFxuICAgICAgICAgICAgICB0bzogbmV3RW5kXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFydGlhbDogQm9vbGVhbihmb3VuZEFmdGVyTWFyayB8fCBmb3VuZEJlZm9yZU1hcmspLFxuICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgY29tYmluZWRUcmFuc2Zvcm06IG5leHRUcmFuc2FjdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmICgoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmVkaXRvci5vcHRpb25zLmNvcmVFeHRlbnNpb25PcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZGVsZXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuYXN5bmMpICE9IG51bGwgPyBfYyA6IHRydWUpIHtcbiAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIHNyYy9leHRlbnNpb25zL2Ryb3AudHNcbmltcG9ydCB7IFBsdWdpbiBhcyBQbHVnaW40LCBQbHVnaW5LZXkgYXMgUGx1Z2luS2V5MiB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG52YXIgRHJvcCA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiBcImRyb3BcIixcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luNCh7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleTIoXCJ0aXB0YXBEcm9wXCIpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGhhbmRsZURyb3A6IChfLCBlLCBzbGljZSwgbW92ZWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLmVtaXQoXCJkcm9wXCIsIHtcbiAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgICAgICAgIHNsaWNlLFxuICAgICAgICAgICAgICBtb3ZlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvZXh0ZW5zaW9ucy9lZGl0YWJsZS50c1xuaW1wb3J0IHsgUGx1Z2luIGFzIFBsdWdpbjUsIFBsdWdpbktleSBhcyBQbHVnaW5LZXkzIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbnZhciBFZGl0YWJsZSA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiBcImVkaXRhYmxlXCIsXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbjUoe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkzKFwiZWRpdGFibGVcIiksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgZWRpdGFibGU6ICgpID0+IHRoaXMuZWRpdG9yLm9wdGlvbnMuZWRpdGFibGVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2V4dGVuc2lvbnMvZm9jdXNFdmVudHMudHNcbmltcG9ydCB7IFBsdWdpbiBhcyBQbHVnaW42LCBQbHVnaW5LZXkgYXMgUGx1Z2luS2V5NCB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG52YXIgZm9jdXNFdmVudHNQbHVnaW5LZXkgPSBuZXcgUGx1Z2luS2V5NChcImZvY3VzRXZlbnRzXCIpO1xudmFyIEZvY3VzRXZlbnRzID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6IFwiZm9jdXNFdmVudHNcIixcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzO1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luNih7XG4gICAgICAgIGtleTogZm9jdXNFdmVudHNQbHVnaW5LZXksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICBmb2N1czogKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIGVkaXRvci5pc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGVkaXRvci5zdGF0ZS50ci5zZXRNZXRhKFwiZm9jdXNcIiwgeyBldmVudCB9KS5zZXRNZXRhKFwiYWRkVG9IaXN0b3J5XCIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBibHVyOiAodmlldywgZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgZWRpdG9yLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGVkaXRvci5zdGF0ZS50ci5zZXRNZXRhKFwiYmx1clwiLCB7IGV2ZW50IH0pLnNldE1ldGEoXCJhZGRUb0hpc3RvcnlcIiwgZmFsc2UpO1xuICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2V4dGVuc2lvbnMva2V5bWFwLnRzXG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luNywgUGx1Z2luS2V5IGFzIFBsdWdpbktleTUsIFNlbGVjdGlvbiBhcyBTZWxlY3Rpb24zIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbnZhciBLZXltYXAgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogXCJrZXltYXBcIixcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgY29uc3QgaGFuZGxlQmFja3NwYWNlID0gKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuZmlyc3QoKHsgY29tbWFuZHMgfSkgPT4gW1xuICAgICAgKCkgPT4gY29tbWFuZHMudW5kb0lucHV0UnVsZSgpLFxuICAgICAgLy8gbWF5YmUgY29udmVydCBmaXJzdCB0ZXh0IGJsb2NrIG5vZGUgdG8gZGVmYXVsdCBub2RlXG4gICAgICAoKSA9PiBjb21tYW5kcy5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24sIGRvYyB9ID0gdHI7XG4gICAgICAgIGNvbnN0IHsgZW1wdHksICRhbmNob3IgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgY29uc3QgeyBwb3MsIHBhcmVudCB9ID0gJGFuY2hvcjtcbiAgICAgICAgY29uc3QgJHBhcmVudFBvcyA9ICRhbmNob3IucGFyZW50LmlzVGV4dGJsb2NrICYmIHBvcyA+IDAgPyB0ci5kb2MucmVzb2x2ZShwb3MgLSAxKSA6ICRhbmNob3I7XG4gICAgICAgIGNvbnN0IHBhcmVudElzSXNvbGF0aW5nID0gJHBhcmVudFBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZztcbiAgICAgICAgY29uc3QgcGFyZW50UG9zID0gJGFuY2hvci5wb3MgLSAkYW5jaG9yLnBhcmVudE9mZnNldDtcbiAgICAgICAgY29uc3QgaXNBdFN0YXJ0ID0gcGFyZW50SXNJc29sYXRpbmcgJiYgJHBhcmVudFBvcy5wYXJlbnQuY2hpbGRDb3VudCA9PT0gMSA/IHBhcmVudFBvcyA9PT0gJGFuY2hvci5wb3MgOiBTZWxlY3Rpb24zLmF0U3RhcnQoZG9jKS5mcm9tID09PSBwb3M7XG4gICAgICAgIGlmICghZW1wdHkgfHwgIXBhcmVudC50eXBlLmlzVGV4dGJsb2NrIHx8IHBhcmVudC50ZXh0Q29udGVudC5sZW5ndGggfHwgIWlzQXRTdGFydCB8fCBpc0F0U3RhcnQgJiYgJGFuY2hvci5wYXJlbnQudHlwZS5uYW1lID09PSBcInBhcmFncmFwaFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKCk7XG4gICAgICB9KSxcbiAgICAgICgpID0+IGNvbW1hbmRzLmRlbGV0ZVNlbGVjdGlvbigpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuam9pbkJhY2t3YXJkKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5zZWxlY3ROb2RlQmFja3dhcmQoKVxuICAgIF0pO1xuICAgIGNvbnN0IGhhbmRsZURlbGV0ZSA9ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmZpcnN0KCh7IGNvbW1hbmRzIH0pID0+IFtcbiAgICAgICgpID0+IGNvbW1hbmRzLmRlbGV0ZVNlbGVjdGlvbigpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuZGVsZXRlQ3VycmVudE5vZGUoKSxcbiAgICAgICgpID0+IGNvbW1hbmRzLmpvaW5Gb3J3YXJkKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5zZWxlY3ROb2RlRm9yd2FyZCgpXG4gICAgXSk7XG4gICAgY29uc3QgaGFuZGxlRW50ZXIgPSAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5maXJzdCgoeyBjb21tYW5kcyB9KSA9PiBbXG4gICAgICAoKSA9PiBjb21tYW5kcy5uZXdsaW5lSW5Db2RlKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5jcmVhdGVQYXJhZ3JhcGhOZWFyKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5saWZ0RW1wdHlCbG9jaygpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuc3BsaXRCbG9jaygpXG4gICAgXSk7XG4gICAgY29uc3QgYmFzZUtleW1hcCA9IHtcbiAgICAgIEVudGVyOiBoYW5kbGVFbnRlcixcbiAgICAgIFwiTW9kLUVudGVyXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmV4aXRDb2RlKCksXG4gICAgICBCYWNrc3BhY2U6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgIFwiTW9kLUJhY2tzcGFjZVwiOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICBcIlNoaWZ0LUJhY2tzcGFjZVwiOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICBEZWxldGU6IGhhbmRsZURlbGV0ZSxcbiAgICAgIFwiTW9kLURlbGV0ZVwiOiBoYW5kbGVEZWxldGUsXG4gICAgICBcIk1vZC1hXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNlbGVjdEFsbCgpXG4gICAgfTtcbiAgICBjb25zdCBwY0tleW1hcCA9IHtcbiAgICAgIC4uLmJhc2VLZXltYXBcbiAgICB9O1xuICAgIGNvbnN0IG1hY0tleW1hcCA9IHtcbiAgICAgIC4uLmJhc2VLZXltYXAsXG4gICAgICBcIkN0cmwtaFwiOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICBcIkFsdC1CYWNrc3BhY2VcIjogaGFuZGxlQmFja3NwYWNlLFxuICAgICAgXCJDdHJsLWRcIjogaGFuZGxlRGVsZXRlLFxuICAgICAgXCJDdHJsLUFsdC1CYWNrc3BhY2VcIjogaGFuZGxlRGVsZXRlLFxuICAgICAgXCJBbHQtRGVsZXRlXCI6IGhhbmRsZURlbGV0ZSxcbiAgICAgIFwiQWx0LWRcIjogaGFuZGxlRGVsZXRlLFxuICAgICAgXCJDdHJsLWFcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2VsZWN0VGV4dGJsb2NrU3RhcnQoKSxcbiAgICAgIFwiQ3RybC1lXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNlbGVjdFRleHRibG9ja0VuZCgpXG4gICAgfTtcbiAgICBpZiAoaXNpT1MoKSB8fCBpc01hY09TKCkpIHtcbiAgICAgIHJldHVybiBtYWNLZXltYXA7XG4gICAgfVxuICAgIHJldHVybiBwY0tleW1hcDtcbiAgfSxcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICAvLyBXaXRoIHRoaXMgcGx1Z2luIHdlIGNoZWNrIGlmIHRoZSB3aG9sZSBkb2N1bWVudCB3YXMgc2VsZWN0ZWQgYW5kIGRlbGV0ZWQuXG4gICAgICAvLyBJbiB0aGlzIGNhc2Ugd2Ugd2lsbCBhZGRpdGlvbmFsbHkgY2FsbCBgY2xlYXJOb2RlcygpYCB0byBjb252ZXJ0IGUuZy4gYSBoZWFkaW5nXG4gICAgICAvLyB0byBhIHBhcmFncmFwaCBpZiBuZWNlc3NhcnkuXG4gICAgICAvLyBUaGlzIGlzIGFuIGFsdGVybmF0aXZlIHRvIFByb3NlTWlycm9yJ3MgYEFsbFNlbGVjdGlvbmAsIHdoaWNoIGRvZXNu4oCZdCB3b3JrIHdlbGxcbiAgICAgIC8vIHdpdGggbWFueSBvdGhlciBjb21tYW5kcy5cbiAgICAgIG5ldyBQbHVnaW43KHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5NShcImNsZWFyRG9jdW1lbnRcIiksXG4gICAgICAgIGFwcGVuZFRyYW5zYWN0aW9uOiAodHJhbnNhY3Rpb25zLCBvbGRTdGF0ZSwgbmV3U3RhdGUpID0+IHtcbiAgICAgICAgICBpZiAodHJhbnNhY3Rpb25zLnNvbWUoKHRyMikgPT4gdHIyLmdldE1ldGEoXCJjb21wb3NpdGlvblwiKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZG9jQ2hhbmdlcyA9IHRyYW5zYWN0aW9ucy5zb21lKCh0cmFuc2FjdGlvbikgPT4gdHJhbnNhY3Rpb24uZG9jQ2hhbmdlZCkgJiYgIW9sZFN0YXRlLmRvYy5lcShuZXdTdGF0ZS5kb2MpO1xuICAgICAgICAgIGNvbnN0IGlnbm9yZVRyID0gdHJhbnNhY3Rpb25zLnNvbWUoKHRyYW5zYWN0aW9uKSA9PiB0cmFuc2FjdGlvbi5nZXRNZXRhKFwicHJldmVudENsZWFyRG9jdW1lbnRcIikpO1xuICAgICAgICAgIGlmICghZG9jQ2hhbmdlcyB8fCBpZ25vcmVUcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7IGVtcHR5LCBmcm9tLCB0byB9ID0gb2xkU3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgIGNvbnN0IGFsbEZyb20gPSBTZWxlY3Rpb24zLmF0U3RhcnQob2xkU3RhdGUuZG9jKS5mcm9tO1xuICAgICAgICAgIGNvbnN0IGFsbEVuZCA9IFNlbGVjdGlvbjMuYXRFbmQob2xkU3RhdGUuZG9jKS50bztcbiAgICAgICAgICBjb25zdCBhbGxXYXNTZWxlY3RlZCA9IGZyb20gPT09IGFsbEZyb20gJiYgdG8gPT09IGFsbEVuZDtcbiAgICAgICAgICBpZiAoZW1wdHkgfHwgIWFsbFdhc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGlzRW1wdHkgPSBpc05vZGVFbXB0eShuZXdTdGF0ZS5kb2MpO1xuICAgICAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0ciA9IG5ld1N0YXRlLnRyO1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgICAgICAgc3RhdGU6IG5ld1N0YXRlLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgeyBjb21tYW5kcyB9ID0gbmV3IENvbW1hbmRNYW5hZ2VyKHtcbiAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbW1hbmRzLmNsZWFyTm9kZXMoKTtcbiAgICAgICAgICBpZiAoIXRyLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9leHRlbnNpb25zL3Bhc3RlLnRzXG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luOCwgUGx1Z2luS2V5IGFzIFBsdWdpbktleTYgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xudmFyIFBhc3RlID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6IFwicGFzdGVcIixcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luOCh7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleTYoXCJ0aXB0YXBQYXN0ZVwiKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBoYW5kbGVQYXN0ZTogKF92aWV3LCBlLCBzbGljZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IuZW1pdChcInBhc3RlXCIsIHtcbiAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgICAgICAgIHNsaWNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9leHRlbnNpb25zL3RhYmluZGV4LnRzXG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luOSwgUGx1Z2luS2V5IGFzIFBsdWdpbktleTcgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xudmFyIFRhYmluZGV4ID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6IFwidGFiaW5kZXhcIixcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luOSh7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleTcoXCJ0YWJpbmRleFwiKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBhdHRyaWJ1dGVzOiAoKSA9PiB0aGlzLmVkaXRvci5pc0VkaXRhYmxlID8geyB0YWJpbmRleDogXCIwXCIgfSA6IHt9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9Ob2RlUG9zLnRzXG52YXIgTm9kZVBvcyA9IGNsYXNzIF9Ob2RlUG9zIHtcbiAgY29uc3RydWN0b3IocG9zLCBlZGl0b3IsIGlzQmxvY2sgPSBmYWxzZSwgbm9kZSA9IG51bGwpIHtcbiAgICB0aGlzLmN1cnJlbnROb2RlID0gbnVsbDtcbiAgICB0aGlzLmFjdHVhbERlcHRoID0gbnVsbDtcbiAgICB0aGlzLmlzQmxvY2sgPSBpc0Jsb2NrO1xuICAgIHRoaXMucmVzb2x2ZWRQb3MgPSBwb3M7XG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgdGhpcy5jdXJyZW50Tm9kZSA9IG5vZGU7XG4gIH1cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS50eXBlLm5hbWU7XG4gIH1cbiAgZ2V0IG5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudE5vZGUgfHwgdGhpcy5yZXNvbHZlZFBvcy5ub2RlKCk7XG4gIH1cbiAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yLnZpZXcuZG9tQXRQb3ModGhpcy5wb3MpLm5vZGU7XG4gIH1cbiAgZ2V0IGRlcHRoKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5hY3R1YWxEZXB0aCkgIT0gbnVsbCA/IF9hIDogdGhpcy5yZXNvbHZlZFBvcy5kZXB0aDtcbiAgfVxuICBnZXQgcG9zKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmVkUG9zLnBvcztcbiAgfVxuICBnZXQgY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlLmNvbnRlbnQ7XG4gIH1cbiAgc2V0IGNvbnRlbnQoY29udGVudCkge1xuICAgIGxldCBmcm9tID0gdGhpcy5mcm9tO1xuICAgIGxldCB0byA9IHRoaXMudG87XG4gICAgaWYgKHRoaXMuaXNCbG9jaykge1xuICAgICAgaWYgKHRoaXMuY29udGVudC5zaXplID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFlvdSBjYW5cXHUyMDE5dCBzZXQgY29udGVudCBvbiBhIGJsb2NrIG5vZGUuIFRyaWVkIHRvIHNldCBjb250ZW50IG9uICR7dGhpcy5uYW1lfSBhdCAke3RoaXMucG9zfWApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmcm9tID0gdGhpcy5mcm9tICsgMTtcbiAgICAgIHRvID0gdGhpcy50byAtIDE7XG4gICAgfVxuICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLmluc2VydENvbnRlbnRBdCh7IGZyb20sIHRvIH0sIGNvbnRlbnQpO1xuICB9XG4gIGdldCBhdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUuYXR0cnM7XG4gIH1cbiAgZ2V0IHRleHRDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUudGV4dENvbnRlbnQ7XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS5ub2RlU2l6ZTtcbiAgfVxuICBnZXQgZnJvbSgpIHtcbiAgICBpZiAodGhpcy5pc0Jsb2NrKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3M7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlc29sdmVkUG9zLnN0YXJ0KHRoaXMucmVzb2x2ZWRQb3MuZGVwdGgpO1xuICB9XG4gIGdldCByYW5nZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbTogdGhpcy5mcm9tLFxuICAgICAgdG86IHRoaXMudG9cbiAgICB9O1xuICB9XG4gIGdldCB0bygpIHtcbiAgICBpZiAodGhpcy5pc0Jsb2NrKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3MgKyB0aGlzLnNpemU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlc29sdmVkUG9zLmVuZCh0aGlzLnJlc29sdmVkUG9zLmRlcHRoKSArICh0aGlzLm5vZGUuaXNUZXh0ID8gMCA6IDEpO1xuICB9XG4gIGdldCBwYXJlbnQoKSB7XG4gICAgaWYgKHRoaXMuZGVwdGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRQb3MgPSB0aGlzLnJlc29sdmVkUG9zLnN0YXJ0KHRoaXMucmVzb2x2ZWRQb3MuZGVwdGggLSAxKTtcbiAgICBjb25zdCAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZShwYXJlbnRQb3MpO1xuICAgIHJldHVybiBuZXcgX05vZGVQb3MoJHBvcywgdGhpcy5lZGl0b3IpO1xuICB9XG4gIGdldCBiZWZvcmUoKSB7XG4gICAgbGV0ICRwb3MgPSB0aGlzLnJlc29sdmVkUG9zLmRvYy5yZXNvbHZlKHRoaXMuZnJvbSAtICh0aGlzLmlzQmxvY2sgPyAxIDogMikpO1xuICAgIGlmICgkcG9zLmRlcHRoICE9PSB0aGlzLmRlcHRoKSB7XG4gICAgICAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZSh0aGlzLmZyb20gLSAzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfTm9kZVBvcygkcG9zLCB0aGlzLmVkaXRvcik7XG4gIH1cbiAgZ2V0IGFmdGVyKCkge1xuICAgIGxldCAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZSh0aGlzLnRvICsgKHRoaXMuaXNCbG9jayA/IDIgOiAxKSk7XG4gICAgaWYgKCRwb3MuZGVwdGggIT09IHRoaXMuZGVwdGgpIHtcbiAgICAgICRwb3MgPSB0aGlzLnJlc29sdmVkUG9zLmRvYy5yZXNvbHZlKHRoaXMudG8gKyAzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfTm9kZVBvcygkcG9zLCB0aGlzLmVkaXRvcik7XG4gIH1cbiAgZ2V0IGNoaWxkcmVuKCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gW107XG4gICAgdGhpcy5ub2RlLmNvbnRlbnQuZm9yRWFjaCgobm9kZSwgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBpc0Jsb2NrID0gbm9kZS5pc0Jsb2NrICYmICFub2RlLmlzVGV4dGJsb2NrO1xuICAgICAgY29uc3QgaXNOb25UZXh0QXRvbSA9IG5vZGUuaXNBdG9tICYmICFub2RlLmlzVGV4dDtcbiAgICAgIGNvbnN0IHRhcmdldFBvcyA9IHRoaXMucG9zICsgb2Zmc2V0ICsgKGlzTm9uVGV4dEF0b20gPyAwIDogMSk7XG4gICAgICBpZiAodGFyZ2V0UG9zIDwgMCB8fCB0YXJnZXRQb3MgPiB0aGlzLnJlc29sdmVkUG9zLmRvYy5ub2RlU2l6ZSAtIDIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGFyZ2V0UG9zKTtcbiAgICAgIGlmICghaXNCbG9jayAmJiAkcG9zLmRlcHRoIDw9IHRoaXMuZGVwdGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGROb2RlUG9zID0gbmV3IF9Ob2RlUG9zKCRwb3MsIHRoaXMuZWRpdG9yLCBpc0Jsb2NrLCBpc0Jsb2NrID8gbm9kZSA6IG51bGwpO1xuICAgICAgaWYgKGlzQmxvY2spIHtcbiAgICAgICAgY2hpbGROb2RlUG9zLmFjdHVhbERlcHRoID0gdGhpcy5kZXB0aCArIDE7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wdXNoKG5ldyBfTm9kZVBvcygkcG9zLCB0aGlzLmVkaXRvciwgaXNCbG9jaywgaXNCbG9jayA/IG5vZGUgOiBudWxsKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIGdldCBmaXJzdENoaWxkKCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuWzBdIHx8IG51bGw7XG4gIH1cbiAgZ2V0IGxhc3RDaGlsZCgpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgcmV0dXJuIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdIHx8IG51bGw7XG4gIH1cbiAgY2xvc2VzdChzZWxlY3RvciwgYXR0cmlidXRlcyA9IHt9KSB7XG4gICAgbGV0IG5vZGUgPSBudWxsO1xuICAgIGxldCBjdXJyZW50Tm9kZSA9IHRoaXMucGFyZW50O1xuICAgIHdoaWxlIChjdXJyZW50Tm9kZSAmJiAhbm9kZSkge1xuICAgICAgaWYgKGN1cnJlbnROb2RlLm5vZGUudHlwZS5uYW1lID09PSBzZWxlY3Rvcikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoYXR0cmlidXRlcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IG5vZGVBdHRyaWJ1dGVzID0gY3VycmVudE5vZGUubm9kZS5hdHRycztcbiAgICAgICAgICBjb25zdCBhdHRyS2V5cyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpO1xuICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhdHRyS2V5cy5sZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGF0dHJLZXlzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChub2RlQXR0cmlidXRlc1trZXldICE9PSBhdHRyaWJ1dGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IsIGF0dHJpYnV0ZXMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IsIGF0dHJpYnV0ZXMsIHRydWUpWzBdIHx8IG51bGw7XG4gIH1cbiAgcXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciwgYXR0cmlidXRlcyA9IHt9LCBmaXJzdEl0ZW1Pbmx5ID0gZmFsc2UpIHtcbiAgICBsZXQgbm9kZXMgPSBbXTtcbiAgICBpZiAoIXRoaXMuY2hpbGRyZW4gfHwgdGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgY29uc3QgYXR0cktleXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKTtcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkUG9zKSA9PiB7XG4gICAgICBpZiAoZmlyc3RJdGVtT25seSAmJiBub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZFBvcy5ub2RlLnR5cGUubmFtZSA9PT0gc2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgZG9lc0FsbEF0dHJpYnV0ZXNNYXRjaCA9IGF0dHJLZXlzLmV2ZXJ5KChrZXkpID0+IGF0dHJpYnV0ZXNba2V5XSA9PT0gY2hpbGRQb3Mubm9kZS5hdHRyc1trZXldKTtcbiAgICAgICAgaWYgKGRvZXNBbGxBdHRyaWJ1dGVzTWF0Y2gpIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKGNoaWxkUG9zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZpcnN0SXRlbU9ubHkgJiYgbm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlcyA9IG5vZGVzLmNvbmNhdChjaGlsZFBvcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yLCBhdHRyaWJ1dGVzLCBmaXJzdEl0ZW1Pbmx5KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG4gIHNldEF0dHJpYnV0ZShhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgeyB0ciB9ID0gdGhpcy5lZGl0b3Iuc3RhdGU7XG4gICAgdHIuc2V0Tm9kZU1hcmt1cCh0aGlzLmZyb20sIHZvaWQgMCwge1xuICAgICAgLi4udGhpcy5ub2RlLmF0dHJzLFxuICAgICAgLi4uYXR0cmlidXRlc1xuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yLnZpZXcuZGlzcGF0Y2godHIpO1xuICB9XG59O1xuXG4vLyBzcmMvc3R5bGUudHNcbnZhciBzdHlsZSA9IGAuUHJvc2VNaXJyb3Ige1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG5cbi5Qcm9zZU1pcnJvciB7XG4gIHdvcmQtd3JhcDogYnJlYWstd29yZDtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xuICB3aGl0ZS1zcGFjZTogYnJlYWstc3BhY2VzO1xuICAtd2Via2l0LWZvbnQtdmFyaWFudC1saWdhdHVyZXM6IG5vbmU7XG4gIGZvbnQtdmFyaWFudC1saWdhdHVyZXM6IG5vbmU7XG4gIGZvbnQtZmVhdHVyZS1zZXR0aW5nczogXCJsaWdhXCIgMDsgLyogdGhlIGFib3ZlIGRvZXNuJ3Qgc2VlbSB0byB3b3JrIGluIEVkZ2UgKi9cbn1cblxuLlByb3NlTWlycm9yIFtjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXSB7XG4gIHdoaXRlLXNwYWNlOiBub3JtYWw7XG59XG5cbi5Qcm9zZU1pcnJvciBbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0gW2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIl0ge1xuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG59XG5cbi5Qcm9zZU1pcnJvciBwcmUge1xuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG59XG5cbmltZy5Qcm9zZU1pcnJvci1zZXBhcmF0b3Ige1xuICBkaXNwbGF5OiBpbmxpbmUgIWltcG9ydGFudDtcbiAgYm9yZGVyOiBub25lICFpbXBvcnRhbnQ7XG4gIG1hcmdpbjogMCAhaW1wb3J0YW50O1xuICB3aWR0aDogMCAhaW1wb3J0YW50O1xuICBoZWlnaHQ6IDAgIWltcG9ydGFudDtcbn1cblxuLlByb3NlTWlycm9yLWdhcGN1cnNvciB7XG4gIGRpc3BsYXk6IG5vbmU7XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIG1hcmdpbjogMDtcbn1cblxuLlByb3NlTWlycm9yLWdhcGN1cnNvcjphZnRlciB7XG4gIGNvbnRlbnQ6IFwiXCI7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogLTJweDtcbiAgd2lkdGg6IDIwcHg7XG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCBibGFjaztcbiAgYW5pbWF0aW9uOiBQcm9zZU1pcnJvci1jdXJzb3ItYmxpbmsgMS4xcyBzdGVwcygyLCBzdGFydCkgaW5maW5pdGU7XG59XG5cbkBrZXlmcmFtZXMgUHJvc2VNaXJyb3ItY3Vyc29yLWJsaW5rIHtcbiAgdG8ge1xuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgfVxufVxuXG4uUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvbiAqOjpzZWxlY3Rpb24ge1xuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbn1cblxuLlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb24gKjo6LW1vei1zZWxlY3Rpb24ge1xuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbn1cblxuLlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb24gKiB7XG4gIGNhcmV0LWNvbG9yOiB0cmFuc3BhcmVudDtcbn1cblxuLlByb3NlTWlycm9yLWZvY3VzZWQgLlByb3NlTWlycm9yLWdhcGN1cnNvciB7XG4gIGRpc3BsYXk6IGJsb2NrO1xufWA7XG5cbi8vIHNyYy91dGlsaXRpZXMvY3JlYXRlU3R5bGVUYWcudHNcbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlVGFnKHN0eWxlMiwgbm9uY2UsIHN1ZmZpeCkge1xuICBjb25zdCB0aXB0YXBTdHlsZVRhZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHN0eWxlW2RhdGEtdGlwdGFwLXN0eWxlJHtzdWZmaXggPyBgLSR7c3VmZml4fWAgOiBcIlwifV1gKTtcbiAgaWYgKHRpcHRhcFN0eWxlVGFnICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRpcHRhcFN0eWxlVGFnO1xuICB9XG4gIGNvbnN0IHN0eWxlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgaWYgKG5vbmNlKSB7XG4gICAgc3R5bGVOb2RlLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgfVxuICBzdHlsZU5vZGUuc2V0QXR0cmlidXRlKGBkYXRhLXRpcHRhcC1zdHlsZSR7c3VmZml4ID8gYC0ke3N1ZmZpeH1gIDogXCJcIn1gLCBcIlwiKTtcbiAgc3R5bGVOb2RlLmlubmVySFRNTCA9IHN0eWxlMjtcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZENoaWxkKHN0eWxlTm9kZSk7XG4gIHJldHVybiBzdHlsZU5vZGU7XG59XG5cbi8vIHNyYy9FZGl0b3IudHNcbnZhciBFZGl0b3IgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jc3MgPSBudWxsO1xuICAgIHRoaXMuZWRpdG9yVmlldyA9IG51bGw7XG4gICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIGNvbnNpZGVyZWQgaW5pdGlhbGl6ZWQgYWZ0ZXIgdGhlIGBjcmVhdGVgIGV2ZW50IGhhcyBiZWVuIGVtaXR0ZWQuXG4gICAgICovXG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5leHRlbnNpb25TdG9yYWdlID0ge307XG4gICAgLyoqXG4gICAgICogQSB1bmlxdWUgSUQgZm9yIHRoaXMgZWRpdG9yIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHRoaXMuaW5zdGFuY2VJZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsIDkpO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGVsZW1lbnQ6IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgOiBudWxsLFxuICAgICAgY29udGVudDogXCJcIixcbiAgICAgIGluamVjdENTUzogdHJ1ZSxcbiAgICAgIGluamVjdE5vbmNlOiB2b2lkIDAsXG4gICAgICBleHRlbnNpb25zOiBbXSxcbiAgICAgIGF1dG9mb2N1czogZmFsc2UsXG4gICAgICBlZGl0YWJsZTogdHJ1ZSxcbiAgICAgIGVkaXRvclByb3BzOiB7fSxcbiAgICAgIHBhcnNlT3B0aW9uczoge30sXG4gICAgICBjb3JlRXh0ZW5zaW9uT3B0aW9uczoge30sXG4gICAgICBlbmFibGVJbnB1dFJ1bGVzOiB0cnVlLFxuICAgICAgZW5hYmxlUGFzdGVSdWxlczogdHJ1ZSxcbiAgICAgIGVuYWJsZUNvcmVFeHRlbnNpb25zOiB0cnVlLFxuICAgICAgZW5hYmxlQ29udGVudENoZWNrOiBmYWxzZSxcbiAgICAgIGVtaXRDb250ZW50RXJyb3I6IGZhbHNlLFxuICAgICAgb25CZWZvcmVDcmVhdGU6ICgpID0+IG51bGwsXG4gICAgICBvbkNyZWF0ZTogKCkgPT4gbnVsbCxcbiAgICAgIG9uTW91bnQ6ICgpID0+IG51bGwsXG4gICAgICBvblVubW91bnQ6ICgpID0+IG51bGwsXG4gICAgICBvblVwZGF0ZTogKCkgPT4gbnVsbCxcbiAgICAgIG9uU2VsZWN0aW9uVXBkYXRlOiAoKSA9PiBudWxsLFxuICAgICAgb25UcmFuc2FjdGlvbjogKCkgPT4gbnVsbCxcbiAgICAgIG9uRm9jdXM6ICgpID0+IG51bGwsXG4gICAgICBvbkJsdXI6ICgpID0+IG51bGwsXG4gICAgICBvbkRlc3Ryb3k6ICgpID0+IG51bGwsXG4gICAgICBvbkNvbnRlbnRFcnJvcjogKHsgZXJyb3IgfSkgPT4ge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0sXG4gICAgICBvblBhc3RlOiAoKSA9PiBudWxsLFxuICAgICAgb25Ecm9wOiAoKSA9PiBudWxsLFxuICAgICAgb25EZWxldGU6ICgpID0+IG51bGxcbiAgICB9O1xuICAgIHRoaXMuaXNDYXB0dXJpbmdUcmFuc2FjdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuY3JlYXRlRXh0ZW5zaW9uTWFuYWdlcigpO1xuICAgIHRoaXMuY3JlYXRlQ29tbWFuZE1hbmFnZXIoKTtcbiAgICB0aGlzLmNyZWF0ZVNjaGVtYSgpO1xuICAgIHRoaXMub24oXCJiZWZvcmVDcmVhdGVcIiwgdGhpcy5vcHRpb25zLm9uQmVmb3JlQ3JlYXRlKTtcbiAgICB0aGlzLmVtaXQoXCJiZWZvcmVDcmVhdGVcIiwgeyBlZGl0b3I6IHRoaXMgfSk7XG4gICAgdGhpcy5vbihcIm1vdW50XCIsIHRoaXMub3B0aW9ucy5vbk1vdW50KTtcbiAgICB0aGlzLm9uKFwidW5tb3VudFwiLCB0aGlzLm9wdGlvbnMub25Vbm1vdW50KTtcbiAgICB0aGlzLm9uKFwiY29udGVudEVycm9yXCIsIHRoaXMub3B0aW9ucy5vbkNvbnRlbnRFcnJvcik7XG4gICAgdGhpcy5vbihcImNyZWF0ZVwiLCB0aGlzLm9wdGlvbnMub25DcmVhdGUpO1xuICAgIHRoaXMub24oXCJ1cGRhdGVcIiwgdGhpcy5vcHRpb25zLm9uVXBkYXRlKTtcbiAgICB0aGlzLm9uKFwic2VsZWN0aW9uVXBkYXRlXCIsIHRoaXMub3B0aW9ucy5vblNlbGVjdGlvblVwZGF0ZSk7XG4gICAgdGhpcy5vbihcInRyYW5zYWN0aW9uXCIsIHRoaXMub3B0aW9ucy5vblRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLm9uKFwiZm9jdXNcIiwgdGhpcy5vcHRpb25zLm9uRm9jdXMpO1xuICAgIHRoaXMub24oXCJibHVyXCIsIHRoaXMub3B0aW9ucy5vbkJsdXIpO1xuICAgIHRoaXMub24oXCJkZXN0cm95XCIsIHRoaXMub3B0aW9ucy5vbkRlc3Ryb3kpO1xuICAgIHRoaXMub24oXCJkcm9wXCIsICh7IGV2ZW50LCBzbGljZSwgbW92ZWQgfSkgPT4gdGhpcy5vcHRpb25zLm9uRHJvcChldmVudCwgc2xpY2UsIG1vdmVkKSk7XG4gICAgdGhpcy5vbihcInBhc3RlXCIsICh7IGV2ZW50LCBzbGljZSB9KSA9PiB0aGlzLm9wdGlvbnMub25QYXN0ZShldmVudCwgc2xpY2UpKTtcbiAgICB0aGlzLm9uKFwiZGVsZXRlXCIsIHRoaXMub3B0aW9ucy5vbkRlbGV0ZSk7XG4gICAgY29uc3QgaW5pdGlhbERvYyA9IHRoaXMuY3JlYXRlRG9jKCk7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gcmVzb2x2ZUZvY3VzUG9zaXRpb24oaW5pdGlhbERvYywgdGhpcy5vcHRpb25zLmF1dG9mb2N1cyk7XG4gICAgdGhpcy5lZGl0b3JTdGF0ZSA9IEVkaXRvclN0YXRlLmNyZWF0ZSh7XG4gICAgICBkb2M6IGluaXRpYWxEb2MsXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgc2VsZWN0aW9uOiBzZWxlY3Rpb24gfHwgdm9pZCAwXG4gICAgfSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lbGVtZW50KSB7XG4gICAgICB0aGlzLm1vdW50KHRoaXMub3B0aW9ucy5lbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEF0dGFjaCB0aGUgZWRpdG9yIHRvIHRoZSBET00sIGNyZWF0aW5nIGEgbmV3IGVkaXRvciB2aWV3LlxuICAgKi9cbiAgbW91bnQoZWwpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBbdGlwdGFwIGVycm9yXTogVGhlIGVkaXRvciBjYW5ub3QgYmUgbW91bnRlZCBiZWNhdXNlIHRoZXJlIGlzIG5vICdkb2N1bWVudCcgZGVmaW5lZCBpbiB0aGlzIGVudmlyb25tZW50LmBcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuY3JlYXRlVmlldyhlbCk7XG4gICAgdGhpcy5lbWl0KFwibW91bnRcIiwgeyBlZGl0b3I6IHRoaXMgfSk7XG4gICAgaWYgKHRoaXMuY3NzICYmICFkb2N1bWVudC5oZWFkLmNvbnRhaW5zKHRoaXMuY3NzKSkge1xuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh0aGlzLmNzcyk7XG4gICAgfVxuICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29tbWFuZHMuZm9jdXModGhpcy5vcHRpb25zLmF1dG9mb2N1cyk7XG4gICAgICB0aGlzLmVtaXQoXCJjcmVhdGVcIiwgeyBlZGl0b3I6IHRoaXMgfSk7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH0sIDApO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGVkaXRvciBmcm9tIHRoZSBET00sIGJ1dCBzdGlsbCBhbGxvdyByZW1vdW50aW5nIGF0IGEgZGlmZmVyZW50IHBvaW50IGluIHRpbWVcbiAgICovXG4gIHVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuZWRpdG9yVmlldykge1xuICAgICAgY29uc3QgZG9tID0gdGhpcy5lZGl0b3JWaWV3LmRvbTtcbiAgICAgIGlmIChkb20gPT0gbnVsbCA/IHZvaWQgMCA6IGRvbS5lZGl0b3IpIHtcbiAgICAgICAgZGVsZXRlIGRvbS5lZGl0b3I7XG4gICAgICB9XG4gICAgICB0aGlzLmVkaXRvclZpZXcuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmVkaXRvclZpZXcgPSBudWxsO1xuICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmNzcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNzcy5yZW1vdmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRoaXMuY3NzLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY3NzLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICB0aGlzLmNzcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY3NzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIHJlbW92ZSBDU1MgZWxlbWVudDpcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNzcyA9IG51bGw7XG4gICAgdGhpcy5lbWl0KFwidW5tb3VudFwiLCB7IGVkaXRvcjogdGhpcyB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWRpdG9yIHN0b3JhZ2UuXG4gICAqL1xuICBnZXQgc3RvcmFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbnNpb25TdG9yYWdlO1xuICB9XG4gIC8qKlxuICAgKiBBbiBvYmplY3Qgb2YgYWxsIHJlZ2lzdGVyZWQgY29tbWFuZHMuXG4gICAqL1xuICBnZXQgY29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tbWFuZE1hbmFnZXIuY29tbWFuZHM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNvbW1hbmQgY2hhaW4gdG8gY2FsbCBtdWx0aXBsZSBjb21tYW5kcyBhdCBvbmNlLlxuICAgKi9cbiAgY2hhaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tbWFuZE1hbmFnZXIuY2hhaW4oKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBjb21tYW5kIG9yIGEgY29tbWFuZCBjaGFpbiBjYW4gYmUgZXhlY3V0ZWQuIFdpdGhvdXQgZXhlY3V0aW5nIGl0LlxuICAgKi9cbiAgY2FuKCkge1xuICAgIHJldHVybiB0aGlzLmNvbW1hbmRNYW5hZ2VyLmNhbigpO1xuICB9XG4gIC8qKlxuICAgKiBJbmplY3QgQ1NTIHN0eWxlcy5cbiAgICovXG4gIGluamVjdENTUygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmluamVjdENTUyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRoaXMuY3NzID0gY3JlYXRlU3R5bGVUYWcoc3R5bGUsIHRoaXMub3B0aW9ucy5pbmplY3ROb25jZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgZWRpdG9yIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIEEgbGlzdCBvZiBvcHRpb25zXG4gICAqL1xuICBzZXRPcHRpb25zKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIGlmICghdGhpcy5lZGl0b3JWaWV3IHx8ICF0aGlzLnN0YXRlIHx8IHRoaXMuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lZGl0b3JQcm9wcykge1xuICAgICAgdGhpcy52aWV3LnNldFByb3BzKHRoaXMub3B0aW9ucy5lZGl0b3JQcm9wcyk7XG4gICAgfVxuICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZSh0aGlzLnN0YXRlKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIGVkaXRhYmxlIHN0YXRlIG9mIHRoZSBlZGl0b3IuXG4gICAqL1xuICBzZXRFZGl0YWJsZShlZGl0YWJsZSwgZW1pdFVwZGF0ZSA9IHRydWUpIHtcbiAgICB0aGlzLnNldE9wdGlvbnMoeyBlZGl0YWJsZSB9KTtcbiAgICBpZiAoZW1pdFVwZGF0ZSkge1xuICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHsgZWRpdG9yOiB0aGlzLCB0cmFuc2FjdGlvbjogdGhpcy5zdGF0ZS50ciwgYXBwZW5kZWRUcmFuc2FjdGlvbnM6IFtdIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlZGl0b3IgaXMgZWRpdGFibGUuXG4gICAqL1xuICBnZXQgaXNFZGl0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmVkaXRhYmxlICYmIHRoaXMudmlldyAmJiB0aGlzLnZpZXcuZWRpdGFibGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVkaXRvciBzdGF0ZS5cbiAgICovXG4gIGdldCB2aWV3KCkge1xuICAgIGlmICh0aGlzLmVkaXRvclZpZXcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVkaXRvclZpZXc7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJveHkoXG4gICAgICB7XG4gICAgICAgIHN0YXRlOiB0aGlzLmVkaXRvclN0YXRlLFxuICAgICAgICB1cGRhdGVTdGF0ZTogKHN0YXRlKSA9PiB7XG4gICAgICAgICAgdGhpcy5lZGl0b3JTdGF0ZSA9IHN0YXRlO1xuICAgICAgICB9LFxuICAgICAgICBkaXNwYXRjaDogKHRyKSA9PiB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaFRyYW5zYWN0aW9uKHRyKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gU3R1YiBzb21lIGNvbW1vbmx5IGFjY2Vzc2VkIHByb3BlcnRpZXMgdG8gcHJldmVudCBlcnJvcnNcbiAgICAgICAgY29tcG9zaW5nOiBmYWxzZSxcbiAgICAgICAgZHJhZ2dpbmc6IG51bGwsXG4gICAgICAgIGVkaXRhYmxlOiB0cnVlLFxuICAgICAgICBpc0Rlc3Ryb3llZDogZmFsc2VcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGdldDogKG9iaiwga2V5KSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZWRpdG9yVmlldykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yVmlld1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoa2V5ID09PSBcInN0YXRlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRvclN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KG9iaiwga2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFt0aXB0YXAgZXJyb3JdOiBUaGUgZWRpdG9yIHZpZXcgaXMgbm90IGF2YWlsYWJsZS4gQ2Fubm90IGFjY2VzcyB2aWV3Wycke2tleX0nXS4gVGhlIGVkaXRvciBtYXkgbm90IGJlIG1vdW50ZWQgeWV0LmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWRpdG9yIHN0YXRlLlxuICAgKi9cbiAgZ2V0IHN0YXRlKCkge1xuICAgIGlmICh0aGlzLmVkaXRvclZpZXcpIHtcbiAgICAgIHRoaXMuZWRpdG9yU3RhdGUgPSB0aGlzLnZpZXcuc3RhdGU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVkaXRvclN0YXRlO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIFByb3NlTWlycm9yIHBsdWdpbi5cbiAgICpcbiAgICogQHBhcmFtIHBsdWdpbiBBIFByb3NlTWlycm9yIHBsdWdpblxuICAgKiBAcGFyYW0gaGFuZGxlUGx1Z2lucyBDb250cm9sIGhvdyB0byBtZXJnZSB0aGUgcGx1Z2luIGludG8gdGhlIGV4aXN0aW5nIHBsdWdpbnMuXG4gICAqIEByZXR1cm5zIFRoZSBuZXcgZWRpdG9yIHN0YXRlXG4gICAqL1xuICByZWdpc3RlclBsdWdpbihwbHVnaW4sIGhhbmRsZVBsdWdpbnMpIHtcbiAgICBjb25zdCBwbHVnaW5zID0gaXNGdW5jdGlvbihoYW5kbGVQbHVnaW5zKSA/IGhhbmRsZVBsdWdpbnMocGx1Z2luLCBbLi4udGhpcy5zdGF0ZS5wbHVnaW5zXSkgOiBbLi4udGhpcy5zdGF0ZS5wbHVnaW5zLCBwbHVnaW5dO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5yZWNvbmZpZ3VyZSh7IHBsdWdpbnMgfSk7XG4gICAgdGhpcy52aWV3LnVwZGF0ZVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgLyoqXG4gICAqIFVucmVnaXN0ZXIgYSBQcm9zZU1pcnJvciBwbHVnaW4uXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lT3JQbHVnaW5LZXlUb1JlbW92ZSBUaGUgcGx1Z2lucyBuYW1lXG4gICAqIEByZXR1cm5zIFRoZSBuZXcgZWRpdG9yIHN0YXRlIG9yIHVuZGVmaW5lZCBpZiB0aGUgZWRpdG9yIGlzIGRlc3Ryb3llZFxuICAgKi9cbiAgdW5yZWdpc3RlclBsdWdpbihuYW1lT3JQbHVnaW5LZXlUb1JlbW92ZSkge1xuICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCBwcmV2UGx1Z2lucyA9IHRoaXMuc3RhdGUucGx1Z2lucztcbiAgICBsZXQgcGx1Z2lucyA9IHByZXZQbHVnaW5zO1xuICAgIFtdLmNvbmNhdChuYW1lT3JQbHVnaW5LZXlUb1JlbW92ZSkuZm9yRWFjaCgobmFtZU9yUGx1Z2luS2V5KSA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gdHlwZW9mIG5hbWVPclBsdWdpbktleSA9PT0gXCJzdHJpbmdcIiA/IGAke25hbWVPclBsdWdpbktleX0kYCA6IG5hbWVPclBsdWdpbktleS5rZXk7XG4gICAgICBwbHVnaW5zID0gcGx1Z2lucy5maWx0ZXIoKHBsdWdpbikgPT4gIXBsdWdpbi5rZXkuc3RhcnRzV2l0aChuYW1lKSk7XG4gICAgfSk7XG4gICAgaWYgKHByZXZQbHVnaW5zLmxlbmd0aCA9PT0gcGx1Z2lucy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5yZWNvbmZpZ3VyZSh7XG4gICAgICBwbHVnaW5zXG4gICAgfSk7XG4gICAgdGhpcy52aWV3LnVwZGF0ZVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gZXh0ZW5zaW9uIG1hbmFnZXIuXG4gICAqL1xuICBjcmVhdGVFeHRlbnNpb25NYW5hZ2VyKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgY29yZUV4dGVuc2lvbnMgPSB0aGlzLm9wdGlvbnMuZW5hYmxlQ29yZUV4dGVuc2lvbnMgPyBbXG4gICAgICBFZGl0YWJsZSxcbiAgICAgIENsaXBib2FyZFRleHRTZXJpYWxpemVyLmNvbmZpZ3VyZSh7XG4gICAgICAgIGJsb2NrU2VwYXJhdG9yOiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY29yZUV4dGVuc2lvbk9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jbGlwYm9hcmRUZXh0U2VyaWFsaXplcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmJsb2NrU2VwYXJhdG9yXG4gICAgICB9KSxcbiAgICAgIENvbW1hbmRzLFxuICAgICAgRm9jdXNFdmVudHMsXG4gICAgICBLZXltYXAsXG4gICAgICBUYWJpbmRleCxcbiAgICAgIERyb3AsXG4gICAgICBQYXN0ZSxcbiAgICAgIERlbGV0ZVxuICAgIF0uZmlsdGVyKChleHQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmVuYWJsZUNvcmVFeHRlbnNpb25zID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZW5hYmxlQ29yZUV4dGVuc2lvbnNbZXh0Lm5hbWVdICE9PSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pIDogW107XG4gICAgY29uc3QgYWxsRXh0ZW5zaW9ucyA9IFsuLi5jb3JlRXh0ZW5zaW9ucywgLi4udGhpcy5vcHRpb25zLmV4dGVuc2lvbnNdLmZpbHRlcigoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICByZXR1cm4gW1wiZXh0ZW5zaW9uXCIsIFwibm9kZVwiLCBcIm1hcmtcIl0uaW5jbHVkZXMoZXh0ZW5zaW9uID09IG51bGwgPyB2b2lkIDAgOiBleHRlbnNpb24udHlwZSk7XG4gICAgfSk7XG4gICAgdGhpcy5leHRlbnNpb25NYW5hZ2VyID0gbmV3IEV4dGVuc2lvbk1hbmFnZXIoYWxsRXh0ZW5zaW9ucywgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gY29tbWFuZCBtYW5hZ2VyLlxuICAgKi9cbiAgY3JlYXRlQ29tbWFuZE1hbmFnZXIoKSB7XG4gICAgdGhpcy5jb21tYW5kTWFuYWdlciA9IG5ldyBDb21tYW5kTWFuYWdlcih7XG4gICAgICBlZGl0b3I6IHRoaXNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIFByb3NlTWlycm9yIHNjaGVtYS5cbiAgICovXG4gIGNyZWF0ZVNjaGVtYSgpIHtcbiAgICB0aGlzLnNjaGVtYSA9IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5zY2hlbWE7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIGluaXRpYWwgZG9jdW1lbnQuXG4gICAqL1xuICBjcmVhdGVEb2MoKSB7XG4gICAgbGV0IGRvYztcbiAgICB0cnkge1xuICAgICAgZG9jID0gY3JlYXRlRG9jdW1lbnQodGhpcy5vcHRpb25zLmNvbnRlbnQsIHRoaXMuc2NoZW1hLCB0aGlzLm9wdGlvbnMucGFyc2VPcHRpb25zLCB7XG4gICAgICAgIGVycm9yT25JbnZhbGlkQ29udGVudDogdGhpcy5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVja1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIEVycm9yKSB8fCAhW1wiW3RpcHRhcCBlcnJvcl06IEludmFsaWQgSlNPTiBjb250ZW50XCIsIFwiW3RpcHRhcCBlcnJvcl06IEludmFsaWQgSFRNTCBjb250ZW50XCJdLmluY2x1ZGVzKGUubWVzc2FnZSkpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChcImNvbnRlbnRFcnJvclwiLCB7XG4gICAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgIGRpc2FibGVDb2xsYWJvcmF0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgaWYgKFwiY29sbGFib3JhdGlvblwiIGluIHRoaXMuc3RvcmFnZSAmJiB0eXBlb2YgdGhpcy5zdG9yYWdlLmNvbGxhYm9yYXRpb24gPT09IFwib2JqZWN0XCIgJiYgdGhpcy5zdG9yYWdlLmNvbGxhYm9yYXRpb24pIHtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5jb2xsYWJvcmF0aW9uLmlzRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyA9IHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmZpbHRlcigoZXh0ZW5zaW9uKSA9PiBleHRlbnNpb24ubmFtZSAhPT0gXCJjb2xsYWJvcmF0aW9uXCIpO1xuICAgICAgICAgIHRoaXMuY3JlYXRlRXh0ZW5zaW9uTWFuYWdlcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGRvYyA9IGNyZWF0ZURvY3VtZW50KHRoaXMub3B0aW9ucy5jb250ZW50LCB0aGlzLnNjaGVtYSwgdGhpcy5vcHRpb25zLnBhcnNlT3B0aW9ucywge1xuICAgICAgICBlcnJvck9uSW52YWxpZENvbnRlbnQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRvYztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIFByb3NlTWlycm9yIHZpZXcuXG4gICAqL1xuICBjcmVhdGVWaWV3KGVsZW1lbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5lZGl0b3JWaWV3ID0gbmV3IEVkaXRvclZpZXcoZWxlbWVudCwge1xuICAgICAgLi4udGhpcy5vcHRpb25zLmVkaXRvclByb3BzLFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAvLyBhZGQgYHJvbGU9XCJ0ZXh0Ym94XCJgIHRvIHRoZSBlZGl0b3IgZWxlbWVudFxuICAgICAgICByb2xlOiBcInRleHRib3hcIixcbiAgICAgICAgLi4uKF9hID0gdGhpcy5vcHRpb25zLmVkaXRvclByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYXR0cmlidXRlc1xuICAgICAgfSxcbiAgICAgIGRpc3BhdGNoVHJhbnNhY3Rpb246IHRoaXMuZGlzcGF0Y2hUcmFuc2FjdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgc3RhdGU6IHRoaXMuZWRpdG9yU3RhdGUsXG4gICAgICBtYXJrVmlld3M6IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5tYXJrVmlld3MsXG4gICAgICBub2RlVmlld3M6IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5ub2RlVmlld3NcbiAgICB9KTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRoaXMuc3RhdGUucmVjb25maWd1cmUoe1xuICAgICAgcGx1Z2luczogdGhpcy5leHRlbnNpb25NYW5hZ2VyLnBsdWdpbnNcbiAgICB9KTtcbiAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUobmV3U3RhdGUpO1xuICAgIHRoaXMucHJlcGVuZENsYXNzKCk7XG4gICAgdGhpcy5pbmplY3RDU1MoKTtcbiAgICBjb25zdCBkb20gPSB0aGlzLnZpZXcuZG9tO1xuICAgIGRvbS5lZGl0b3IgPSB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFsbCBub2RlIGFuZCBtYXJrIHZpZXdzLlxuICAgKi9cbiAgY3JlYXRlTm9kZVZpZXdzKCkge1xuICAgIGlmICh0aGlzLnZpZXcuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy52aWV3LnNldFByb3BzKHtcbiAgICAgIG1hcmtWaWV3czogdGhpcy5leHRlbnNpb25NYW5hZ2VyLm1hcmtWaWV3cyxcbiAgICAgIG5vZGVWaWV3czogdGhpcy5leHRlbnNpb25NYW5hZ2VyLm5vZGVWaWV3c1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQcmVwZW5kIGNsYXNzIG5hbWUgdG8gZWxlbWVudC5cbiAgICovXG4gIHByZXBlbmRDbGFzcygpIHtcbiAgICB0aGlzLnZpZXcuZG9tLmNsYXNzTmFtZSA9IGB0aXB0YXAgJHt0aGlzLnZpZXcuZG9tLmNsYXNzTmFtZX1gO1xuICB9XG4gIGNhcHR1cmVUcmFuc2FjdGlvbihmbikge1xuICAgIHRoaXMuaXNDYXB0dXJpbmdUcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgZm4oKTtcbiAgICB0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgICBjb25zdCB0ciA9IHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbjtcbiAgICB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24gPSBudWxsO1xuICAgIHJldHVybiB0cjtcbiAgfVxuICAvKipcbiAgICogVGhlIGNhbGxiYWNrIG92ZXIgd2hpY2ggdG8gc2VuZCB0cmFuc2FjdGlvbnMgKHN0YXRlIHVwZGF0ZXMpIHByb2R1Y2VkIGJ5IHRoZSB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gQW4gZWRpdG9yIHN0YXRlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBkaXNwYXRjaFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRoaXMudmlldy5pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0NhcHR1cmluZ1RyYW5zYWN0aW9uKSB7XG4gICAgICBpZiAoIXRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbikge1xuICAgICAgICB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJhbnNhY3Rpb24uc3RlcHMuZm9yRWFjaCgoc3RlcCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYS5zdGVwKHN0ZXApO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgc3RhdGUsIHRyYW5zYWN0aW9ucyB9ID0gdGhpcy5zdGF0ZS5hcHBseVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICBjb25zdCBzZWxlY3Rpb25IYXNDaGFuZ2VkID0gIXRoaXMuc3RhdGUuc2VsZWN0aW9uLmVxKHN0YXRlLnNlbGVjdGlvbik7XG4gICAgY29uc3Qgcm9vdFRyV2FzQXBwbGllZCA9IHRyYW5zYWN0aW9ucy5pbmNsdWRlcyh0cmFuc2FjdGlvbik7XG4gICAgY29uc3QgcHJldlN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB0aGlzLmVtaXQoXCJiZWZvcmVUcmFuc2FjdGlvblwiLCB7XG4gICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICB0cmFuc2FjdGlvbixcbiAgICAgIG5leHRTdGF0ZTogc3RhdGVcbiAgICB9KTtcbiAgICBpZiAoIXJvb3RUcldhc0FwcGxpZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy52aWV3LnVwZGF0ZVN0YXRlKHN0YXRlKTtcbiAgICB0aGlzLmVtaXQoXCJ0cmFuc2FjdGlvblwiLCB7XG4gICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICB0cmFuc2FjdGlvbixcbiAgICAgIGFwcGVuZGVkVHJhbnNhY3Rpb25zOiB0cmFuc2FjdGlvbnMuc2xpY2UoMSlcbiAgICB9KTtcbiAgICBpZiAoc2VsZWN0aW9uSGFzQ2hhbmdlZCkge1xuICAgICAgdGhpcy5lbWl0KFwic2VsZWN0aW9uVXBkYXRlXCIsIHtcbiAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICB0cmFuc2FjdGlvblxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1vc3RSZWNlbnRGb2N1c1RyID0gdHJhbnNhY3Rpb25zLmZpbmRMYXN0KCh0cikgPT4gdHIuZ2V0TWV0YShcImZvY3VzXCIpIHx8IHRyLmdldE1ldGEoXCJibHVyXCIpKTtcbiAgICBjb25zdCBmb2N1czIgPSBtb3N0UmVjZW50Rm9jdXNUciA9PSBudWxsID8gdm9pZCAwIDogbW9zdFJlY2VudEZvY3VzVHIuZ2V0TWV0YShcImZvY3VzXCIpO1xuICAgIGNvbnN0IGJsdXIyID0gbW9zdFJlY2VudEZvY3VzVHIgPT0gbnVsbCA/IHZvaWQgMCA6IG1vc3RSZWNlbnRGb2N1c1RyLmdldE1ldGEoXCJibHVyXCIpO1xuICAgIGlmIChmb2N1czIpIHtcbiAgICAgIHRoaXMuZW1pdChcImZvY3VzXCIsIHtcbiAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICBldmVudDogZm9jdXMyLmV2ZW50LFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICB0cmFuc2FjdGlvbjogbW9zdFJlY2VudEZvY3VzVHJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYmx1cjIpIHtcbiAgICAgIHRoaXMuZW1pdChcImJsdXJcIiwge1xuICAgICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICAgIGV2ZW50OiBibHVyMi5ldmVudCxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgdHJhbnNhY3Rpb246IG1vc3RSZWNlbnRGb2N1c1RyXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRyYW5zYWN0aW9uLmdldE1ldGEoXCJwcmV2ZW50VXBkYXRlXCIpIHx8ICF0cmFuc2FjdGlvbnMuc29tZSgodHIpID0+IHRyLmRvY0NoYW5nZWQpIHx8IHByZXZTdGF0ZS5kb2MuZXEoc3RhdGUuZG9jKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwge1xuICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICBhcHBlbmRlZFRyYW5zYWN0aW9uczogdHJhbnNhY3Rpb25zLnNsaWNlKDEpXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhdHRyaWJ1dGVzIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbm9kZSBvciBtYXJrLlxuICAgKi9cbiAgZ2V0QXR0cmlidXRlcyhuYW1lT3JUeXBlKSB7XG4gICAgcmV0dXJuIGdldEF0dHJpYnV0ZXModGhpcy5zdGF0ZSwgbmFtZU9yVHlwZSk7XG4gIH1cbiAgaXNBY3RpdmUobmFtZU9yQXR0cmlidXRlcywgYXR0cmlidXRlc09yVW5kZWZpbmVkKSB7XG4gICAgY29uc3QgbmFtZSA9IHR5cGVvZiBuYW1lT3JBdHRyaWJ1dGVzID09PSBcInN0cmluZ1wiID8gbmFtZU9yQXR0cmlidXRlcyA6IG51bGw7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHR5cGVvZiBuYW1lT3JBdHRyaWJ1dGVzID09PSBcInN0cmluZ1wiID8gYXR0cmlidXRlc09yVW5kZWZpbmVkIDogbmFtZU9yQXR0cmlidXRlcztcbiAgICByZXR1cm4gaXNBY3RpdmUodGhpcy5zdGF0ZSwgbmFtZSwgYXR0cmlidXRlcyk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgSlNPTi5cbiAgICovXG4gIGdldEpTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZG9jLnRvSlNPTigpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGRvY3VtZW50IGFzIEhUTUwuXG4gICAqL1xuICBnZXRIVE1MKCkge1xuICAgIHJldHVybiBnZXRIVE1MRnJvbUZyYWdtZW50KHRoaXMuc3RhdGUuZG9jLmNvbnRlbnQsIHRoaXMuc2NoZW1hKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBkb2N1bWVudCBhcyB0ZXh0LlxuICAgKi9cbiAgZ2V0VGV4dChvcHRpb25zKSB7XG4gICAgY29uc3QgeyBibG9ja1NlcGFyYXRvciA9IFwiXFxuXFxuXCIsIHRleHRTZXJpYWxpemVycyA9IHt9IH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBnZXRUZXh0KHRoaXMuc3RhdGUuZG9jLCB7XG4gICAgICBibG9ja1NlcGFyYXRvcixcbiAgICAgIHRleHRTZXJpYWxpemVyczoge1xuICAgICAgICAuLi5nZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hKHRoaXMuc2NoZW1hKSxcbiAgICAgICAgLi4udGV4dFNlcmlhbGl6ZXJzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZXJlIGlzIG5vIGNvbnRlbnQuXG4gICAqL1xuICBnZXQgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gaXNOb2RlRW1wdHkodGhpcy5zdGF0ZS5kb2MpO1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBlZGl0b3IuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZW1pdChcImRlc3Ryb3lcIik7XG4gICAgdGhpcy51bm1vdW50KCk7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGVkaXRvciBpcyBhbHJlYWR5IGRlc3Ryb3llZC5cbiAgICovXG4gIGdldCBpc0Rlc3Ryb3llZCgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmVkaXRvclZpZXcpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pc0Rlc3Ryb3llZCkgIT0gbnVsbCA/IF9iIDogdHJ1ZTtcbiAgfVxuICAkbm9kZShzZWxlY3RvciwgYXR0cmlidXRlcykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHRoaXMuJGRvYykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IsIGF0dHJpYnV0ZXMpKSB8fCBudWxsO1xuICB9XG4gICRub2RlcyhzZWxlY3RvciwgYXR0cmlidXRlcykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHRoaXMuJGRvYykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IsIGF0dHJpYnV0ZXMpKSB8fCBudWxsO1xuICB9XG4gICRwb3MocG9zKSB7XG4gICAgY29uc3QgJHBvcyA9IHRoaXMuc3RhdGUuZG9jLnJlc29sdmUocG9zKTtcbiAgICByZXR1cm4gbmV3IE5vZGVQb3MoJHBvcywgdGhpcyk7XG4gIH1cbiAgZ2V0ICRkb2MoKSB7XG4gICAgcmV0dXJuIHRoaXMuJHBvcygwKTtcbiAgfVxufTtcblxuLy8gc3JjL2lucHV0UnVsZXMvbWFya0lucHV0UnVsZS50c1xuZnVuY3Rpb24gbWFya0lucHV0UnVsZShjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdm9pZCAwLCBtYXRjaCk7XG4gICAgICBpZiAoYXR0cmlidXRlcyA9PT0gZmFsc2UgfHwgYXR0cmlidXRlcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdHIgfSA9IHN0YXRlO1xuICAgICAgY29uc3QgY2FwdHVyZUdyb3VwID0gbWF0Y2hbbWF0Y2gubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBmdWxsTWF0Y2ggPSBtYXRjaFswXTtcbiAgICAgIGlmIChjYXB0dXJlR3JvdXApIHtcbiAgICAgICAgY29uc3Qgc3RhcnRTcGFjZXMgPSBmdWxsTWF0Y2guc2VhcmNoKC9cXFMvKTtcbiAgICAgICAgY29uc3QgdGV4dFN0YXJ0ID0gcmFuZ2UuZnJvbSArIGZ1bGxNYXRjaC5pbmRleE9mKGNhcHR1cmVHcm91cCk7XG4gICAgICAgIGNvbnN0IHRleHRFbmQgPSB0ZXh0U3RhcnQgKyBjYXB0dXJlR3JvdXAubGVuZ3RoO1xuICAgICAgICBjb25zdCBleGNsdWRlZE1hcmtzID0gZ2V0TWFya3NCZXR3ZWVuKHJhbmdlLmZyb20sIHJhbmdlLnRvLCBzdGF0ZS5kb2MpLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGV4Y2x1ZGVkID0gaXRlbS5tYXJrLnR5cGUuZXhjbHVkZWQ7XG4gICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVkLmZpbmQoKHR5cGUpID0+IHR5cGUgPT09IGNvbmZpZy50eXBlICYmIHR5cGUgIT09IGl0ZW0ubWFyay50eXBlKTtcbiAgICAgICAgfSkuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnRvID4gdGV4dFN0YXJ0KTtcbiAgICAgICAgaWYgKGV4Y2x1ZGVkTWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHRFbmQgPCByYW5nZS50bykge1xuICAgICAgICAgIHRyLmRlbGV0ZSh0ZXh0RW5kLCByYW5nZS50byk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHRTdGFydCA+IHJhbmdlLmZyb20pIHtcbiAgICAgICAgICB0ci5kZWxldGUocmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzLCB0ZXh0U3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hcmtFbmQgPSByYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMgKyBjYXB0dXJlR3JvdXAubGVuZ3RoO1xuICAgICAgICB0ci5hZGRNYXJrKHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcywgbWFya0VuZCwgY29uZmlnLnR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMgfHwge30pKTtcbiAgICAgICAgdHIucmVtb3ZlU3RvcmVkTWFyayhjb25maWcudHlwZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB1bmRvYWJsZTogY29uZmlnLnVuZG9hYmxlXG4gIH0pO1xufVxuXG4vLyBzcmMvaW5wdXRSdWxlcy9ub2RlSW5wdXRSdWxlLnRzXG5mdW5jdGlvbiBub2RlSW5wdXRSdWxlKGNvbmZpZykge1xuICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB2b2lkIDAsIG1hdGNoKSB8fCB7fTtcbiAgICAgIGNvbnN0IHsgdHIgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qgc3RhcnQgPSByYW5nZS5mcm9tO1xuICAgICAgbGV0IGVuZCA9IHJhbmdlLnRvO1xuICAgICAgY29uc3QgbmV3Tm9kZSA9IGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzKTtcbiAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBtYXRjaFswXS5sYXN0SW5kZXhPZihtYXRjaFsxXSk7XG4gICAgICAgIGxldCBtYXRjaFN0YXJ0ID0gc3RhcnQgKyBvZmZzZXQ7XG4gICAgICAgIGlmIChtYXRjaFN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgbWF0Y2hTdGFydCA9IGVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmQgPSBtYXRjaFN0YXJ0ICsgbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3RDaGFyID0gbWF0Y2hbMF1bbWF0Y2hbMF0ubGVuZ3RoIC0gMV07XG4gICAgICAgIHRyLmluc2VydFRleHQobGFzdENoYXIsIHN0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoIC0gMSk7XG4gICAgICAgIHRyLnJlcGxhY2VXaXRoKG1hdGNoU3RhcnQsIGVuZCwgbmV3Tm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoWzBdKSB7XG4gICAgICAgIGNvbnN0IGluc2VydGlvblN0YXJ0ID0gY29uZmlnLnR5cGUuaXNJbmxpbmUgPyBzdGFydCA6IHN0YXJ0IC0gMTtcbiAgICAgICAgdHIuaW5zZXJ0KGluc2VydGlvblN0YXJ0LCBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcykpLmRlbGV0ZSh0ci5tYXBwaW5nLm1hcChzdGFydCksIHRyLm1hcHBpbmcubWFwKGVuZCkpO1xuICAgICAgfVxuICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICB9LFxuICAgIHVuZG9hYmxlOiBjb25maWcudW5kb2FibGVcbiAgfSk7XG59XG5cbi8vIHNyYy9pbnB1dFJ1bGVzL3RleHRibG9ja1R5cGVJbnB1dFJ1bGUudHNcbmZ1bmN0aW9uIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGNvbnN0ICRzdGFydCA9IHN0YXRlLmRvYy5yZXNvbHZlKHJhbmdlLmZyb20pO1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdm9pZCAwLCBtYXRjaCkgfHwge307XG4gICAgICBpZiAoISRzdGFydC5ub2RlKC0xKS5jYW5SZXBsYWNlV2l0aCgkc3RhcnQuaW5kZXgoLTEpLCAkc3RhcnQuaW5kZXhBZnRlcigtMSksIGNvbmZpZy50eXBlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnRyLmRlbGV0ZShyYW5nZS5mcm9tLCByYW5nZS50bykuc2V0QmxvY2tUeXBlKHJhbmdlLmZyb20sIHJhbmdlLmZyb20sIGNvbmZpZy50eXBlLCBhdHRyaWJ1dGVzKTtcbiAgICB9LFxuICAgIHVuZG9hYmxlOiBjb25maWcudW5kb2FibGVcbiAgfSk7XG59XG5cbi8vIHNyYy9pbnB1dFJ1bGVzL3RleHRJbnB1dFJ1bGUudHNcbmZ1bmN0aW9uIHRleHRJbnB1dFJ1bGUoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGxldCBpbnNlcnQgPSBjb25maWcucmVwbGFjZTtcbiAgICAgIGxldCBzdGFydCA9IHJhbmdlLmZyb207XG4gICAgICBjb25zdCBlbmQgPSByYW5nZS50bztcbiAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBtYXRjaFswXS5sYXN0SW5kZXhPZihtYXRjaFsxXSk7XG4gICAgICAgIGluc2VydCArPSBtYXRjaFswXS5zbGljZShvZmZzZXQgKyBtYXRjaFsxXS5sZW5ndGgpO1xuICAgICAgICBzdGFydCArPSBvZmZzZXQ7XG4gICAgICAgIGNvbnN0IGN1dE9mZiA9IHN0YXJ0IC0gZW5kO1xuICAgICAgICBpZiAoY3V0T2ZmID4gMCkge1xuICAgICAgICAgIGluc2VydCA9IG1hdGNoWzBdLnNsaWNlKG9mZnNldCAtIGN1dE9mZiwgb2Zmc2V0KSArIGluc2VydDtcbiAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGUudHIuaW5zZXJ0VGV4dChpbnNlcnQsIHN0YXJ0LCBlbmQpO1xuICAgIH0sXG4gICAgdW5kb2FibGU6IGNvbmZpZy51bmRvYWJsZVxuICB9KTtcbn1cblxuLy8gc3JjL2lucHV0UnVsZXMvd3JhcHBpbmdJbnB1dFJ1bGUudHNcbmltcG9ydCB7IGNhbkpvaW4gYXMgY2FuSm9pbjIsIGZpbmRXcmFwcGluZyB9IGZyb20gXCJAdGlwdGFwL3BtL3RyYW5zZm9ybVwiO1xuZnVuY3Rpb24gd3JhcHBpbmdJbnB1dFJ1bGUoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoLCBjaGFpbiB9KSA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB2b2lkIDAsIG1hdGNoKSB8fCB7fTtcbiAgICAgIGNvbnN0IHRyID0gc3RhdGUudHIuZGVsZXRlKHJhbmdlLmZyb20sIHJhbmdlLnRvKTtcbiAgICAgIGNvbnN0ICRzdGFydCA9IHRyLmRvYy5yZXNvbHZlKHJhbmdlLmZyb20pO1xuICAgICAgY29uc3QgYmxvY2tSYW5nZSA9ICRzdGFydC5ibG9ja1JhbmdlKCk7XG4gICAgICBjb25zdCB3cmFwcGluZyA9IGJsb2NrUmFuZ2UgJiYgZmluZFdyYXBwaW5nKGJsb2NrUmFuZ2UsIGNvbmZpZy50eXBlLCBhdHRyaWJ1dGVzKTtcbiAgICAgIGlmICghd3JhcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB0ci53cmFwKGJsb2NrUmFuZ2UsIHdyYXBwaW5nKTtcbiAgICAgIGlmIChjb25maWcua2VlcE1hcmtzICYmIGNvbmZpZy5lZGl0b3IpIHtcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24sIHN0b3JlZE1hcmtzIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgeyBzcGxpdHRhYmxlTWFya3MgfSA9IGNvbmZpZy5lZGl0b3IuZXh0ZW5zaW9uTWFuYWdlcjtcbiAgICAgICAgY29uc3QgbWFya3MgPSBzdG9yZWRNYXJrcyB8fCBzZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzZWxlY3Rpb24uJGZyb20ubWFya3MoKTtcbiAgICAgICAgaWYgKG1hcmtzKSB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzLmZpbHRlcigobWFyaykgPT4gc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSk7XG4gICAgICAgICAgdHIuZW5zdXJlTWFya3MoZmlsdGVyZWRNYXJrcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb25maWcua2VlcEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgY29uc3Qgbm9kZVR5cGUgPSBjb25maWcudHlwZS5uYW1lID09PSBcImJ1bGxldExpc3RcIiB8fCBjb25maWcudHlwZS5uYW1lID09PSBcIm9yZGVyZWRMaXN0XCIgPyBcImxpc3RJdGVtXCIgOiBcInRhc2tMaXN0XCI7XG4gICAgICAgIGNoYWluKCkudXBkYXRlQXR0cmlidXRlcyhub2RlVHlwZSwgYXR0cmlidXRlcykucnVuKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBiZWZvcmUgPSB0ci5kb2MucmVzb2x2ZShyYW5nZS5mcm9tIC0gMSkubm9kZUJlZm9yZTtcbiAgICAgIGlmIChiZWZvcmUgJiYgYmVmb3JlLnR5cGUgPT09IGNvbmZpZy50eXBlICYmIGNhbkpvaW4yKHRyLmRvYywgcmFuZ2UuZnJvbSAtIDEpICYmICghY29uZmlnLmpvaW5QcmVkaWNhdGUgfHwgY29uZmlnLmpvaW5QcmVkaWNhdGUobWF0Y2gsIGJlZm9yZSkpKSB7XG4gICAgICAgIHRyLmpvaW4ocmFuZ2UuZnJvbSAtIDEpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdW5kb2FibGU6IGNvbmZpZy51bmRvYWJsZVxuICB9KTtcbn1cblxuLy8gc3JjL2pzeC1ydW50aW1lLnRzXG5mdW5jdGlvbiBGcmFnbWVudDYocHJvcHMpIHtcbiAgcmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufVxudmFyIGggPSAodGFnLCBhdHRyaWJ1dGVzKSA9PiB7XG4gIGlmICh0YWcgPT09IFwic2xvdFwiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHRhZyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIHRhZyhhdHRyaWJ1dGVzKTtcbiAgfVxuICBjb25zdCB7IGNoaWxkcmVuLCAuLi5yZXN0IH0gPSBhdHRyaWJ1dGVzICE9IG51bGwgPyBhdHRyaWJ1dGVzIDoge307XG4gIGlmICh0YWcgPT09IFwic3ZnXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTVkcgZWxlbWVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIEpTWCBzeW50YXgsIHVzZSB0aGUgYXJyYXkgc3ludGF4IGluc3RlYWRcIik7XG4gIH1cbiAgcmV0dXJuIFt0YWcsIHJlc3QsIGNoaWxkcmVuXTtcbn07XG5cbi8vIHNyYy91dGlsaXRpZXMvY2FuSW5zZXJ0Tm9kZS50c1xuaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiBhcyBOb2RlU2VsZWN0aW9uNCB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG5mdW5jdGlvbiBjYW5JbnNlcnROb2RlKHN0YXRlLCBub2RlVHlwZSkge1xuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gIGNvbnN0IHsgJGZyb20gfSA9IHNlbGVjdGlvbjtcbiAgaWYgKHNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb240KSB7XG4gICAgY29uc3QgaW5kZXggPSAkZnJvbS5pbmRleCgpO1xuICAgIGNvbnN0IHBhcmVudCA9ICRmcm9tLnBhcmVudDtcbiAgICByZXR1cm4gcGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCArIDEsIG5vZGVUeXBlKTtcbiAgfVxuICBsZXQgZGVwdGggPSAkZnJvbS5kZXB0aDtcbiAgd2hpbGUgKGRlcHRoID49IDApIHtcbiAgICBjb25zdCBpbmRleCA9ICRmcm9tLmluZGV4KGRlcHRoKTtcbiAgICBjb25zdCBwYXJlbnQgPSAkZnJvbS5ub2RlKGRlcHRoKTtcbiAgICBjb25zdCBtYXRjaCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdChpbmRleCk7XG4gICAgaWYgKG1hdGNoLm1hdGNoVHlwZShub2RlVHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkZXB0aCAtPSAxO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9lc2NhcGVGb3JSZWdFeC50c1xuZnVuY3Rpb24gZXNjYXBlRm9yUmVnRXgoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZywgXCJcXFxcJCZcIik7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvaXNTdHJpbmcudHNcbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvbWFya2Rvd24vaW5kZXgudHNcbnZhciBtYXJrZG93bl9leHBvcnRzID0ge307XG5fX2V4cG9ydChtYXJrZG93bl9leHBvcnRzLCB7XG4gIGNyZWF0ZUF0b21CbG9ja01hcmtkb3duU3BlYzogKCkgPT4gY3JlYXRlQXRvbUJsb2NrTWFya2Rvd25TcGVjLFxuICBjcmVhdGVCbG9ja01hcmtkb3duU3BlYzogKCkgPT4gY3JlYXRlQmxvY2tNYXJrZG93blNwZWMsXG4gIGNyZWF0ZUlubGluZU1hcmtkb3duU3BlYzogKCkgPT4gY3JlYXRlSW5saW5lTWFya2Rvd25TcGVjLFxuICBwYXJzZUF0dHJpYnV0ZXM6ICgpID0+IHBhcnNlQXR0cmlidXRlcyxcbiAgcGFyc2VJbmRlbnRlZEJsb2NrczogKCkgPT4gcGFyc2VJbmRlbnRlZEJsb2NrcyxcbiAgcmVuZGVyTmVzdGVkTWFya2Rvd25Db250ZW50OiAoKSA9PiByZW5kZXJOZXN0ZWRNYXJrZG93bkNvbnRlbnQsXG4gIHNlcmlhbGl6ZUF0dHJpYnV0ZXM6ICgpID0+IHNlcmlhbGl6ZUF0dHJpYnV0ZXNcbn0pO1xuXG4vLyBzcmMvdXRpbGl0aWVzL21hcmtkb3duL2F0dHJpYnV0ZVV0aWxzLnRzXG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZXMoYXR0clN0cmluZykge1xuICBpZiAoIShhdHRyU3RyaW5nID09IG51bGwgPyB2b2lkIDAgOiBhdHRyU3RyaW5nLnRyaW0oKSkpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICBjb25zdCBxdW90ZWRTdHJpbmdzID0gW107XG4gIGNvbnN0IHRlbXBTdHJpbmcgPSBhdHRyU3RyaW5nLnJlcGxhY2UoL1tcIiddKFteXCInXSopW1wiJ10vZywgKG1hdGNoKSA9PiB7XG4gICAgcXVvdGVkU3RyaW5ncy5wdXNoKG1hdGNoKTtcbiAgICByZXR1cm4gYF9fUVVPVEVEXyR7cXVvdGVkU3RyaW5ncy5sZW5ndGggLSAxfV9fYDtcbiAgfSk7XG4gIGNvbnN0IGNsYXNzTWF0Y2hlcyA9IHRlbXBTdHJpbmcubWF0Y2goLyg/Ol58XFxzKVxcLihbYS16QS1aXVtcXHctXSopL2cpO1xuICBpZiAoY2xhc3NNYXRjaGVzKSB7XG4gICAgY29uc3QgY2xhc3NlcyA9IGNsYXNzTWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiBtYXRjaC50cmltKCkuc2xpY2UoMSkpO1xuICAgIGF0dHJpYnV0ZXMuY2xhc3MgPSBjbGFzc2VzLmpvaW4oXCIgXCIpO1xuICB9XG4gIGNvbnN0IGlkTWF0Y2ggPSB0ZW1wU3RyaW5nLm1hdGNoKC8oPzpefFxccykjKFthLXpBLVpdW1xcdy1dKikvKTtcbiAgaWYgKGlkTWF0Y2gpIHtcbiAgICBhdHRyaWJ1dGVzLmlkID0gaWRNYXRjaFsxXTtcbiAgfVxuICBjb25zdCBrdlJlZ2V4ID0gLyhbYS16QS1aXVtcXHctXSopXFxzKj1cXHMqKF9fUVVPVEVEX1xcZCtfXykvZztcbiAgY29uc3Qga3ZNYXRjaGVzID0gQXJyYXkuZnJvbSh0ZW1wU3RyaW5nLm1hdGNoQWxsKGt2UmVnZXgpKTtcbiAga3ZNYXRjaGVzLmZvckVhY2goKFssIGtleSwgcXVvdGVkUmVmXSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBxdW90ZWRJbmRleCA9IHBhcnNlSW50KCgoX2EgPSBxdW90ZWRSZWYubWF0Y2goL19fUVVPVEVEXyhcXGQrKV9fLykpID09IG51bGwgPyB2b2lkIDAgOiBfYVsxXSkgfHwgXCIwXCIsIDEwKTtcbiAgICBjb25zdCBxdW90ZWRWYWx1ZSA9IHF1b3RlZFN0cmluZ3NbcXVvdGVkSW5kZXhdO1xuICAgIGlmIChxdW90ZWRWYWx1ZSkge1xuICAgICAgYXR0cmlidXRlc1trZXldID0gcXVvdGVkVmFsdWUuc2xpY2UoMSwgLTEpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGNsZWFuU3RyaW5nID0gdGVtcFN0cmluZy5yZXBsYWNlKC8oPzpefFxccylcXC4oW2EtekEtWl1bXFx3LV0qKS9nLCBcIlwiKS5yZXBsYWNlKC8oPzpefFxccykjKFthLXpBLVpdW1xcdy1dKikvZywgXCJcIikucmVwbGFjZSgvKFthLXpBLVpdW1xcdy1dKilcXHMqPVxccypfX1FVT1RFRF9cXGQrX18vZywgXCJcIikudHJpbSgpO1xuICBpZiAoY2xlYW5TdHJpbmcpIHtcbiAgICBjb25zdCBib29sZWFuQXR0cnMgPSBjbGVhblN0cmluZy5zcGxpdCgvXFxzKy8pLmZpbHRlcihCb29sZWFuKTtcbiAgICBib29sZWFuQXR0cnMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgaWYgKGF0dHIubWF0Y2goL15bYS16QS1aXVtcXHctXSokLykpIHtcbiAgICAgICAgYXR0cmlidXRlc1thdHRyXSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGF0dHJpYnV0ZXM7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgaWYgKCFhdHRyaWJ1dGVzIHx8IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGNvbnN0IHBhcnRzID0gW107XG4gIGlmIChhdHRyaWJ1dGVzLmNsYXNzKSB7XG4gICAgY29uc3QgY2xhc3NlcyA9IFN0cmluZyhhdHRyaWJ1dGVzLmNsYXNzKS5zcGxpdCgvXFxzKy8pLmZpbHRlcihCb29sZWFuKTtcbiAgICBjbGFzc2VzLmZvckVhY2goKGNscykgPT4gcGFydHMucHVzaChgLiR7Y2xzfWApKTtcbiAgfVxuICBpZiAoYXR0cmlidXRlcy5pZCkge1xuICAgIHBhcnRzLnB1c2goYCMke2F0dHJpYnV0ZXMuaWR9YCk7XG4gIH1cbiAgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKGtleSA9PT0gXCJjbGFzc1wiIHx8IGtleSA9PT0gXCJpZFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgcGFydHMucHVzaChrZXkpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IGZhbHNlICYmIHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHBhcnRzLnB1c2goYCR7a2V5fT1cIiR7U3RyaW5nKHZhbHVlKX1cImApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwYXJ0cy5qb2luKFwiIFwiKTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9tYXJrZG93bi9jcmVhdGVBdG9tQmxvY2tNYXJrZG93blNwZWMudHNcbmZ1bmN0aW9uIGNyZWF0ZUF0b21CbG9ja01hcmtkb3duU3BlYyhvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBub2RlTmFtZSxcbiAgICBuYW1lOiBtYXJrZG93bk5hbWUsXG4gICAgcGFyc2VBdHRyaWJ1dGVzOiBwYXJzZUF0dHJpYnV0ZXMyID0gcGFyc2VBdHRyaWJ1dGVzLFxuICAgIHNlcmlhbGl6ZUF0dHJpYnV0ZXM6IHNlcmlhbGl6ZUF0dHJpYnV0ZXMyID0gc2VyaWFsaXplQXR0cmlidXRlcyxcbiAgICBkZWZhdWx0QXR0cmlidXRlcyA9IHt9LFxuICAgIHJlcXVpcmVkQXR0cmlidXRlcyA9IFtdLFxuICAgIGFsbG93ZWRBdHRyaWJ1dGVzXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBibG9ja05hbWUgPSBtYXJrZG93bk5hbWUgfHwgbm9kZU5hbWU7XG4gIGNvbnN0IGZpbHRlckF0dHJpYnV0ZXMgPSAoYXR0cnMpID0+IHtcbiAgICBpZiAoIWFsbG93ZWRBdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm4gYXR0cnM7XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlcmVkID0ge307XG4gICAgYWxsb3dlZEF0dHJpYnV0ZXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoa2V5IGluIGF0dHJzKSB7XG4gICAgICAgIGZpbHRlcmVkW2tleV0gPSBhdHRyc1trZXldO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmaWx0ZXJlZDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBwYXJzZU1hcmtkb3duOiAodG9rZW4sIGgyKSA9PiB7XG4gICAgICBjb25zdCBhdHRycyA9IHsgLi4uZGVmYXVsdEF0dHJpYnV0ZXMsIC4uLnRva2VuLmF0dHJpYnV0ZXMgfTtcbiAgICAgIHJldHVybiBoMi5jcmVhdGVOb2RlKG5vZGVOYW1lLCBhdHRycywgW10pO1xuICAgIH0sXG4gICAgbWFya2Rvd25Ub2tlbml6ZXI6IHtcbiAgICAgIG5hbWU6IG5vZGVOYW1lLFxuICAgICAgbGV2ZWw6IFwiYmxvY2tcIixcbiAgICAgIHN0YXJ0KHNyYykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXjo6OiR7YmxvY2tOYW1lfSg/OlxcXFxzfCQpYCwgXCJtXCIpO1xuICAgICAgICBjb25zdCBpbmRleCA9IChfYSA9IHNyYy5tYXRjaChyZWdleCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pbmRleDtcbiAgICAgICAgcmV0dXJuIGluZGV4ICE9PSB2b2lkIDAgPyBpbmRleCA6IC0xO1xuICAgICAgfSxcbiAgICAgIHRva2VuaXplKHNyYywgX3Rva2VucywgX2xleGVyKSB7XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXjo6OiR7YmxvY2tOYW1lfSg/OlxcXFxzK1xcXFx7KFtefV0qKVxcXFx9KT9cXFxccyo6OjooPzpcXFxcbnwkKWApO1xuICAgICAgICBjb25zdCBtYXRjaCA9IHNyYy5tYXRjaChyZWdleCk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dHJTdHJpbmcgPSBtYXRjaFsxXSB8fCBcIlwiO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVzMihhdHRyU3RyaW5nKTtcbiAgICAgICAgY29uc3QgbWlzc2luZ1JlcXVpcmVkID0gcmVxdWlyZWRBdHRyaWJ1dGVzLmZpbmQoKHJlcXVpcmVkKSA9PiAhKHJlcXVpcmVkIGluIGF0dHJpYnV0ZXMpKTtcbiAgICAgICAgaWYgKG1pc3NpbmdSZXF1aXJlZCkge1xuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBub2RlTmFtZSxcbiAgICAgICAgICByYXc6IG1hdGNoWzBdLFxuICAgICAgICAgIGF0dHJpYnV0ZXNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlck1hcmtkb3duOiAobm9kZSkgPT4ge1xuICAgICAgY29uc3QgZmlsdGVyZWRBdHRycyA9IGZpbHRlckF0dHJpYnV0ZXMobm9kZS5hdHRycyB8fCB7fSk7XG4gICAgICBjb25zdCBhdHRycyA9IHNlcmlhbGl6ZUF0dHJpYnV0ZXMyKGZpbHRlcmVkQXR0cnMpO1xuICAgICAgY29uc3QgYXR0clN0cmluZyA9IGF0dHJzID8gYCB7JHthdHRyc319YCA6IFwiXCI7XG4gICAgICByZXR1cm4gYDo6OiR7YmxvY2tOYW1lfSR7YXR0clN0cmluZ30gOjo6YDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvbWFya2Rvd24vY3JlYXRlQmxvY2tNYXJrZG93blNwZWMudHNcbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrTWFya2Rvd25TcGVjKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIG5vZGVOYW1lLFxuICAgIG5hbWU6IG1hcmtkb3duTmFtZSxcbiAgICBnZXRDb250ZW50LFxuICAgIHBhcnNlQXR0cmlidXRlczogcGFyc2VBdHRyaWJ1dGVzMiA9IHBhcnNlQXR0cmlidXRlcyxcbiAgICBzZXJpYWxpemVBdHRyaWJ1dGVzOiBzZXJpYWxpemVBdHRyaWJ1dGVzMiA9IHNlcmlhbGl6ZUF0dHJpYnV0ZXMsXG4gICAgZGVmYXVsdEF0dHJpYnV0ZXMgPSB7fSxcbiAgICBjb250ZW50ID0gXCJibG9ja1wiLFxuICAgIGFsbG93ZWRBdHRyaWJ1dGVzXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBibG9ja05hbWUgPSBtYXJrZG93bk5hbWUgfHwgbm9kZU5hbWU7XG4gIGNvbnN0IGZpbHRlckF0dHJpYnV0ZXMgPSAoYXR0cnMpID0+IHtcbiAgICBpZiAoIWFsbG93ZWRBdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm4gYXR0cnM7XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlcmVkID0ge307XG4gICAgYWxsb3dlZEF0dHJpYnV0ZXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoa2V5IGluIGF0dHJzKSB7XG4gICAgICAgIGZpbHRlcmVkW2tleV0gPSBhdHRyc1trZXldO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmaWx0ZXJlZDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBwYXJzZU1hcmtkb3duOiAodG9rZW4sIGgyKSA9PiB7XG4gICAgICBsZXQgbm9kZUNvbnRlbnQ7XG4gICAgICBpZiAoZ2V0Q29udGVudCkge1xuICAgICAgICBjb25zdCBjb250ZW50UmVzdWx0ID0gZ2V0Q29udGVudCh0b2tlbik7XG4gICAgICAgIG5vZGVDb250ZW50ID0gdHlwZW9mIGNvbnRlbnRSZXN1bHQgPT09IFwic3RyaW5nXCIgPyBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogY29udGVudFJlc3VsdCB9XSA6IGNvbnRlbnRSZXN1bHQ7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRlbnQgPT09IFwiYmxvY2tcIikge1xuICAgICAgICBub2RlQ29udGVudCA9IGgyLnBhcnNlQ2hpbGRyZW4odG9rZW4udG9rZW5zIHx8IFtdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVDb250ZW50ID0gaDIucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zIHx8IFtdKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGF0dHJzID0geyAuLi5kZWZhdWx0QXR0cmlidXRlcywgLi4udG9rZW4uYXR0cmlidXRlcyB9O1xuICAgICAgcmV0dXJuIGgyLmNyZWF0ZU5vZGUobm9kZU5hbWUsIGF0dHJzLCBub2RlQ29udGVudCk7XG4gICAgfSxcbiAgICBtYXJrZG93blRva2VuaXplcjoge1xuICAgICAgbmFtZTogbm9kZU5hbWUsXG4gICAgICBsZXZlbDogXCJibG9ja1wiLFxuICAgICAgc3RhcnQoc3JjKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGBeOjo6JHtibG9ja05hbWV9YCwgXCJtXCIpO1xuICAgICAgICBjb25zdCBpbmRleCA9IChfYSA9IHNyYy5tYXRjaChyZWdleCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pbmRleDtcbiAgICAgICAgcmV0dXJuIGluZGV4ICE9PSB2b2lkIDAgPyBpbmRleCA6IC0xO1xuICAgICAgfSxcbiAgICAgIHRva2VuaXplKHNyYywgX3Rva2VucywgbGV4ZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBvcGVuaW5nUmVnZXggPSBuZXcgUmVnRXhwKGBeOjo6JHtibG9ja05hbWV9KD86XFxcXHMrXFxcXHsoW159XSopXFxcXH0pP1xcXFxzKlxcXFxuYCk7XG4gICAgICAgIGNvbnN0IG9wZW5pbmdNYXRjaCA9IHNyYy5tYXRjaChvcGVuaW5nUmVnZXgpO1xuICAgICAgICBpZiAoIW9wZW5pbmdNYXRjaCkge1xuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW29wZW5pbmdUYWcsIGF0dHJTdHJpbmcgPSBcIlwiXSA9IG9wZW5pbmdNYXRjaDtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHBhcnNlQXR0cmlidXRlczIoYXR0clN0cmluZyk7XG4gICAgICAgIGxldCBsZXZlbCA9IDE7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gb3BlbmluZ1RhZy5sZW5ndGg7XG4gICAgICAgIGxldCBtYXRjaGVkQ29udGVudCA9IFwiXCI7XG4gICAgICAgIGNvbnN0IGJsb2NrUGF0dGVybiA9IC9eOjo6KFtcXHctXSopKFxccy4qKT8vZ207XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IHNyYy5zbGljZShwb3NpdGlvbik7XG4gICAgICAgIGJsb2NrUGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICAgICAgICBmb3IgKDsgOyApIHtcbiAgICAgICAgICBjb25zdCBtYXRjaCA9IGJsb2NrUGF0dGVybi5leGVjKHJlbWFpbmluZyk7XG4gICAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbWF0Y2hQb3MgPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICBjb25zdCBibG9ja1R5cGUgPSBtYXRjaFsxXTtcbiAgICAgICAgICBpZiAoKF9hID0gbWF0Y2hbMl0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5lbmRzV2l0aChcIjo6OlwiKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChibG9ja1R5cGUpIHtcbiAgICAgICAgICAgIGxldmVsICs9IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldmVsIC09IDE7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgcmF3Q29udGVudCA9IHJlbWFpbmluZy5zbGljZSgwLCBtYXRjaFBvcyk7XG4gICAgICAgICAgICAgIG1hdGNoZWRDb250ZW50ID0gcmF3Q29udGVudC50cmltKCk7XG4gICAgICAgICAgICAgIGNvbnN0IGZ1bGxNYXRjaCA9IHNyYy5zbGljZSgwLCBwb3NpdGlvbiArIG1hdGNoUG9zICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgbGV0IGNvbnRlbnRUb2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoZWRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQgPT09IFwiYmxvY2tcIikge1xuICAgICAgICAgICAgICAgICAgY29udGVudFRva2VucyA9IGxleGVyLmJsb2NrVG9rZW5zKHJhd0NvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgY29udGVudFRva2Vucy5mb3JFYWNoKCh0b2tlbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4udGV4dCAmJiAoIXRva2VuLnRva2VucyB8fCB0b2tlbi50b2tlbnMubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnRva2VucyA9IGxleGVyLmlubGluZVRva2Vucyh0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoY29udGVudFRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RUb2tlbiA9IGNvbnRlbnRUb2tlbnNbY29udGVudFRva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbi50eXBlID09PSBcInBhcmFncmFwaFwiICYmICghbGFzdFRva2VuLnRleHQgfHwgbGFzdFRva2VuLnRleHQudHJpbSgpID09PSBcIlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUb2tlbnMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29udGVudFRva2VucyA9IGxleGVyLmlubGluZVRva2VucyhtYXRjaGVkQ29udGVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogbm9kZU5hbWUsXG4gICAgICAgICAgICAgICAgcmF3OiBmdWxsTWF0Y2gsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBtYXRjaGVkQ29udGVudCxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IGNvbnRlbnRUb2tlbnNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlck1hcmtkb3duOiAobm9kZSwgaDIpID0+IHtcbiAgICAgIGNvbnN0IGZpbHRlcmVkQXR0cnMgPSBmaWx0ZXJBdHRyaWJ1dGVzKG5vZGUuYXR0cnMgfHwge30pO1xuICAgICAgY29uc3QgYXR0cnMgPSBzZXJpYWxpemVBdHRyaWJ1dGVzMihmaWx0ZXJlZEF0dHJzKTtcbiAgICAgIGNvbnN0IGF0dHJTdHJpbmcgPSBhdHRycyA/IGAgeyR7YXR0cnN9fWAgOiBcIlwiO1xuICAgICAgY29uc3QgcmVuZGVyZWRDb250ZW50ID0gaDIucmVuZGVyQ2hpbGRyZW4obm9kZS5jb250ZW50IHx8IFtdLCBcIlxcblxcblwiKTtcbiAgICAgIHJldHVybiBgOjo6JHtibG9ja05hbWV9JHthdHRyU3RyaW5nfVxuXG4ke3JlbmRlcmVkQ29udGVudH1cblxuOjo6YDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvbWFya2Rvd24vY3JlYXRlSW5saW5lTWFya2Rvd25TcGVjLnRzXG5mdW5jdGlvbiBwYXJzZVNob3J0Y29kZUF0dHJpYnV0ZXMoYXR0clN0cmluZykge1xuICBpZiAoIWF0dHJTdHJpbmcudHJpbSgpKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgY29uc3QgcmVnZXggPSAvKFxcdyspPSg/OlwiKFteXCJdKilcInwnKFteJ10qKScpL2c7XG4gIGxldCBtYXRjaCA9IHJlZ2V4LmV4ZWMoYXR0clN0cmluZyk7XG4gIHdoaWxlIChtYXRjaCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IFssIGtleSwgZG91YmxlUXVvdGVkLCBzaW5nbGVRdW90ZWRdID0gbWF0Y2g7XG4gICAgYXR0cmlidXRlc1trZXldID0gZG91YmxlUXVvdGVkIHx8IHNpbmdsZVF1b3RlZDtcbiAgICBtYXRjaCA9IHJlZ2V4LmV4ZWMoYXR0clN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIGF0dHJpYnV0ZXM7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVTaG9ydGNvZGVBdHRyaWJ1dGVzKGF0dHJzKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhhdHRycykuZmlsdGVyKChbLCB2YWx1ZV0pID0+IHZhbHVlICE9PSB2b2lkIDAgJiYgdmFsdWUgIT09IG51bGwpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgJHtrZXl9PVwiJHt2YWx1ZX1cImApLmpvaW4oXCIgXCIpO1xufVxuZnVuY3Rpb24gY3JlYXRlSW5saW5lTWFya2Rvd25TcGVjKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIG5vZGVOYW1lLFxuICAgIG5hbWU6IHNob3J0Y29kZU5hbWUsXG4gICAgZ2V0Q29udGVudCxcbiAgICBwYXJzZUF0dHJpYnV0ZXM6IHBhcnNlQXR0cmlidXRlczIgPSBwYXJzZVNob3J0Y29kZUF0dHJpYnV0ZXMsXG4gICAgc2VyaWFsaXplQXR0cmlidXRlczogc2VyaWFsaXplQXR0cmlidXRlczIgPSBzZXJpYWxpemVTaG9ydGNvZGVBdHRyaWJ1dGVzLFxuICAgIGRlZmF1bHRBdHRyaWJ1dGVzID0ge30sXG4gICAgc2VsZkNsb3NpbmcgPSBmYWxzZSxcbiAgICBhbGxvd2VkQXR0cmlidXRlc1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgc2hvcnRjb2RlID0gc2hvcnRjb2RlTmFtZSB8fCBub2RlTmFtZTtcbiAgY29uc3QgZmlsdGVyQXR0cmlidXRlcyA9IChhdHRycykgPT4ge1xuICAgIGlmICghYWxsb3dlZEF0dHJpYnV0ZXMpIHtcbiAgICAgIHJldHVybiBhdHRycztcbiAgICB9XG4gICAgY29uc3QgZmlsdGVyZWQgPSB7fTtcbiAgICBhbGxvd2VkQXR0cmlidXRlcy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmIChrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgZmlsdGVyZWRba2V5XSA9IGF0dHJzW2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbHRlcmVkO1xuICB9O1xuICBjb25zdCBlc2NhcGVkU2hvcnRjb2RlID0gc2hvcnRjb2RlLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcbiAgcmV0dXJuIHtcbiAgICBwYXJzZU1hcmtkb3duOiAodG9rZW4sIGgyKSA9PiB7XG4gICAgICBjb25zdCBhdHRycyA9IHsgLi4uZGVmYXVsdEF0dHJpYnV0ZXMsIC4uLnRva2VuLmF0dHJpYnV0ZXMgfTtcbiAgICAgIGlmIChzZWxmQ2xvc2luZykge1xuICAgICAgICByZXR1cm4gaDIuY3JlYXRlTm9kZShub2RlTmFtZSwgYXR0cnMpO1xuICAgICAgfVxuICAgICAgY29uc3QgY29udGVudCA9IGdldENvbnRlbnQgPyBnZXRDb250ZW50KHRva2VuKSA6IHRva2VuLmNvbnRlbnQgfHwgXCJcIjtcbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBoMi5jcmVhdGVOb2RlKG5vZGVOYW1lLCBhdHRycywgW2gyLmNyZWF0ZVRleHROb2RlKGNvbnRlbnQpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaDIuY3JlYXRlTm9kZShub2RlTmFtZSwgYXR0cnMsIFtdKTtcbiAgICB9LFxuICAgIG1hcmtkb3duVG9rZW5pemVyOiB7XG4gICAgICBuYW1lOiBub2RlTmFtZSxcbiAgICAgIGxldmVsOiBcImlubGluZVwiLFxuICAgICAgc3RhcnQoc3JjKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0UGF0dGVybiA9IHNlbGZDbG9zaW5nID8gbmV3IFJlZ0V4cChgXFxcXFske2VzY2FwZWRTaG9ydGNvZGV9XFxcXHMqW15cXFxcXV0qXFxcXF1gKSA6IG5ldyBSZWdFeHAoYFxcXFxbJHtlc2NhcGVkU2hvcnRjb2RlfVxcXFxzKlteXFxcXF1dKlxcXFxdW1xcXFxzXFxcXFNdKj9cXFxcW1xcXFwvJHtlc2NhcGVkU2hvcnRjb2RlfVxcXFxdYCk7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gc3JjLm1hdGNoKHN0YXJ0UGF0dGVybik7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbWF0Y2ggPT0gbnVsbCA/IHZvaWQgMCA6IG1hdGNoLmluZGV4O1xuICAgICAgICByZXR1cm4gaW5kZXggIT09IHZvaWQgMCA/IGluZGV4IDogLTE7XG4gICAgICB9LFxuICAgICAgdG9rZW5pemUoc3JjLCBfdG9rZW5zLCBfbGV4ZXIpIHtcbiAgICAgICAgY29uc3QgdG9rZW5QYXR0ZXJuID0gc2VsZkNsb3NpbmcgPyBuZXcgUmVnRXhwKGBeXFxcXFske2VzY2FwZWRTaG9ydGNvZGV9XFxcXHMqKFteXFxcXF1dKilcXFxcXWApIDogbmV3IFJlZ0V4cChgXlxcXFxbJHtlc2NhcGVkU2hvcnRjb2RlfVxcXFxzKihbXlxcXFxdXSopXFxcXF0oW1xcXFxzXFxcXFNdKj8pXFxcXFtcXFxcLyR7ZXNjYXBlZFNob3J0Y29kZX1cXFxcXWApO1xuICAgICAgICBjb25zdCBtYXRjaCA9IHNyYy5tYXRjaCh0b2tlblBhdHRlcm4pO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGVudCA9IFwiXCI7XG4gICAgICAgIGxldCBhdHRyU3RyaW5nID0gXCJcIjtcbiAgICAgICAgaWYgKHNlbGZDbG9zaW5nKSB7XG4gICAgICAgICAgY29uc3QgWywgYXR0cnNdID0gbWF0Y2g7XG4gICAgICAgICAgYXR0clN0cmluZyA9IGF0dHJzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IFssIGF0dHJzLCBjb250ZW50TWF0Y2hdID0gbWF0Y2g7XG4gICAgICAgICAgYXR0clN0cmluZyA9IGF0dHJzO1xuICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50TWF0Y2ggfHwgXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVzMihhdHRyU3RyaW5nLnRyaW0oKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogbm9kZU5hbWUsXG4gICAgICAgICAgcmF3OiBtYXRjaFswXSxcbiAgICAgICAgICBjb250ZW50OiBjb250ZW50LnRyaW0oKSxcbiAgICAgICAgICBhdHRyaWJ1dGVzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXJNYXJrZG93bjogKG5vZGUpID0+IHtcbiAgICAgIGxldCBjb250ZW50ID0gXCJcIjtcbiAgICAgIGlmIChnZXRDb250ZW50KSB7XG4gICAgICAgIGNvbnRlbnQgPSBnZXRDb250ZW50KG5vZGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLmNvbnRlbnQgJiYgbm9kZS5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29udGVudCA9IG5vZGUuY29udGVudC5maWx0ZXIoKGNoaWxkKSA9PiBjaGlsZC50eXBlID09PSBcInRleHRcIikubWFwKChjaGlsZCkgPT4gY2hpbGQudGV4dCkuam9pbihcIlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbHRlcmVkQXR0cnMgPSBmaWx0ZXJBdHRyaWJ1dGVzKG5vZGUuYXR0cnMgfHwge30pO1xuICAgICAgY29uc3QgYXR0cnMgPSBzZXJpYWxpemVBdHRyaWJ1dGVzMihmaWx0ZXJlZEF0dHJzKTtcbiAgICAgIGNvbnN0IGF0dHJTdHJpbmcgPSBhdHRycyA/IGAgJHthdHRyc31gIDogXCJcIjtcbiAgICAgIGlmIChzZWxmQ2xvc2luZykge1xuICAgICAgICByZXR1cm4gYFske3Nob3J0Y29kZX0ke2F0dHJTdHJpbmd9XWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYFske3Nob3J0Y29kZX0ke2F0dHJTdHJpbmd9XSR7Y29udGVudH1bLyR7c2hvcnRjb2RlfV1gO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9tYXJrZG93bi9wYXJzZUluZGVudGVkQmxvY2tzLnRzXG5mdW5jdGlvbiBwYXJzZUluZGVudGVkQmxvY2tzKHNyYywgY29uZmlnLCBsZXhlcikge1xuICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gIGNvbnN0IGxpbmVzID0gc3JjLnNwbGl0KFwiXFxuXCIpO1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBsZXQgdG90YWxSYXcgPSBcIlwiO1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IGJhc2VJbmRlbnRTaXplID0gY29uZmlnLmJhc2VJbmRlbnRTaXplIHx8IDI7XG4gIHdoaWxlIChpIDwgbGluZXMubGVuZ3RoKSB7XG4gICAgY29uc3QgY3VycmVudExpbmUgPSBsaW5lc1tpXTtcbiAgICBjb25zdCBpdGVtTWF0Y2ggPSBjdXJyZW50TGluZS5tYXRjaChjb25maWcuaXRlbVBhdHRlcm4pO1xuICAgIGlmICghaXRlbU1hdGNoKSB7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudExpbmUudHJpbSgpID09PSBcIlwiKSB7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpdGVtRGF0YSA9IGNvbmZpZy5leHRyYWN0SXRlbURhdGEoaXRlbU1hdGNoKTtcbiAgICBjb25zdCB7IGluZGVudExldmVsLCBtYWluQ29udGVudCB9ID0gaXRlbURhdGE7XG4gICAgdG90YWxSYXcgPSBgJHt0b3RhbFJhd30ke2N1cnJlbnRMaW5lfVxuYDtcbiAgICBjb25zdCBpdGVtQ29udGVudCA9IFttYWluQ29udGVudF07XG4gICAgaSArPSAxO1xuICAgIHdoaWxlIChpIDwgbGluZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBuZXh0TGluZSA9IGxpbmVzW2ldO1xuICAgICAgaWYgKG5leHRMaW5lLnRyaW0oKSA9PT0gXCJcIikge1xuICAgICAgICBjb25zdCBuZXh0Tm9uRW1wdHlJbmRleCA9IGxpbmVzLnNsaWNlKGkgKyAxKS5maW5kSW5kZXgoKGwpID0+IGwudHJpbSgpICE9PSBcIlwiKTtcbiAgICAgICAgaWYgKG5leHROb25FbXB0eUluZGV4ID09PSAtMSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHROb25FbXB0eSA9IGxpbmVzW2kgKyAxICsgbmV4dE5vbkVtcHR5SW5kZXhdO1xuICAgICAgICBjb25zdCBuZXh0SW5kZW50MiA9ICgoX2IgPSAoX2EgPSBuZXh0Tm9uRW1wdHkubWF0Y2goL14oXFxzKikvKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hWzFdKSA9PSBudWxsID8gdm9pZCAwIDogX2IubGVuZ3RoKSB8fCAwO1xuICAgICAgICBpZiAobmV4dEluZGVudDIgPiBpbmRlbnRMZXZlbCkge1xuICAgICAgICAgIGl0ZW1Db250ZW50LnB1c2gobmV4dExpbmUpO1xuICAgICAgICAgIHRvdGFsUmF3ID0gYCR7dG90YWxSYXd9JHtuZXh0TGluZX1cbmA7XG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0SW5kZW50ID0gKChfZCA9IChfYyA9IG5leHRMaW5lLm1hdGNoKC9eKFxccyopLykpID09IG51bGwgPyB2b2lkIDAgOiBfY1sxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkgfHwgMDtcbiAgICAgIGlmIChuZXh0SW5kZW50ID4gaW5kZW50TGV2ZWwpIHtcbiAgICAgICAgaXRlbUNvbnRlbnQucHVzaChuZXh0TGluZSk7XG4gICAgICAgIHRvdGFsUmF3ID0gYCR7dG90YWxSYXd9JHtuZXh0TGluZX1cbmA7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbmVzdGVkVG9rZW5zO1xuICAgIGNvbnN0IG5lc3RlZENvbnRlbnQgPSBpdGVtQ29udGVudC5zbGljZSgxKTtcbiAgICBpZiAobmVzdGVkQ29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBkZWRlbnRlZE5lc3RlZCA9IG5lc3RlZENvbnRlbnQubWFwKChuZXN0ZWRMaW5lKSA9PiBuZXN0ZWRMaW5lLnNsaWNlKGluZGVudExldmVsICsgYmFzZUluZGVudFNpemUpKS5qb2luKFwiXFxuXCIpO1xuICAgICAgaWYgKGRlZGVudGVkTmVzdGVkLnRyaW0oKSkge1xuICAgICAgICBpZiAoY29uZmlnLmN1c3RvbU5lc3RlZFBhcnNlcikge1xuICAgICAgICAgIG5lc3RlZFRva2VucyA9IGNvbmZpZy5jdXN0b21OZXN0ZWRQYXJzZXIoZGVkZW50ZWROZXN0ZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5lc3RlZFRva2VucyA9IGxleGVyLmJsb2NrVG9rZW5zKGRlZGVudGVkTmVzdGVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0b2tlbiA9IGNvbmZpZy5jcmVhdGVUb2tlbihpdGVtRGF0YSwgbmVzdGVkVG9rZW5zKTtcbiAgICBpdGVtcy5wdXNoKHRva2VuKTtcbiAgfVxuICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGl0ZW1zLFxuICAgIHJhdzogdG90YWxSYXcudHJpbSgpXG4gIH07XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvbWFya2Rvd24vcmVuZGVyTmVzdGVkTWFya2Rvd25Db250ZW50LnRzXG5mdW5jdGlvbiByZW5kZXJOZXN0ZWRNYXJrZG93bkNvbnRlbnQobm9kZSwgaDIsIHByZWZpeE9yR2VuZXJhdG9yLCBjdHgpIHtcbiAgaWYgKCFub2RlIHx8ICFBcnJheS5pc0FycmF5KG5vZGUuY29udGVudCkpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBjb25zdCBwcmVmaXggPSB0eXBlb2YgcHJlZml4T3JHZW5lcmF0b3IgPT09IFwiZnVuY3Rpb25cIiA/IHByZWZpeE9yR2VuZXJhdG9yKGN0eCkgOiBwcmVmaXhPckdlbmVyYXRvcjtcbiAgY29uc3QgW2NvbnRlbnQsIC4uLmNoaWxkcmVuXSA9IG5vZGUuY29udGVudDtcbiAgY29uc3QgbWFpbkNvbnRlbnQgPSBoMi5yZW5kZXJDaGlsZHJlbihbY29udGVudF0pO1xuICBjb25zdCBvdXRwdXQgPSBbYCR7cHJlZml4fSR7bWFpbkNvbnRlbnR9YF07XG4gIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkQ29udGVudCA9IGgyLnJlbmRlckNoaWxkcmVuKFtjaGlsZF0pO1xuICAgICAgaWYgKGNoaWxkQ29udGVudCkge1xuICAgICAgICBjb25zdCBpbmRlbnRlZENoaWxkID0gY2hpbGRDb250ZW50LnNwbGl0KFwiXFxuXCIpLm1hcCgobGluZSkgPT4gbGluZSA/IGgyLmluZGVudChsaW5lKSA6IFwiXCIpLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIG91dHB1dC5wdXNoKGluZGVudGVkQ2hpbGQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbihcIlxcblwiKTtcbn1cblxuLy8gc3JjL01hcmtWaWV3LnRzXG5mdW5jdGlvbiB1cGRhdGVNYXJrVmlld0F0dHJpYnV0ZXMoY2hlY2tNYXJrLCBlZGl0b3IsIGF0dHJzID0ge30pIHtcbiAgY29uc3QgeyBzdGF0ZSB9ID0gZWRpdG9yO1xuICBjb25zdCB7IGRvYywgdHIgfSA9IHN0YXRlO1xuICBjb25zdCB0aGlzTWFyayA9IGNoZWNrTWFyaztcbiAgZG9jLmRlc2NlbmRhbnRzKChub2RlLCBwb3MpID0+IHtcbiAgICBjb25zdCBmcm9tID0gdHIubWFwcGluZy5tYXAocG9zKTtcbiAgICBjb25zdCB0byA9IHRyLm1hcHBpbmcubWFwKHBvcykgKyBub2RlLm5vZGVTaXplO1xuICAgIGxldCBmb3VuZE1hcmsgPSBudWxsO1xuICAgIG5vZGUubWFya3MuZm9yRWFjaCgobWFyaykgPT4ge1xuICAgICAgaWYgKG1hcmsgIT09IHRoaXNNYXJrKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvdW5kTWFyayA9IG1hcms7XG4gICAgfSk7XG4gICAgaWYgKCFmb3VuZE1hcmspIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IG5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goKGspID0+IHtcbiAgICAgIGlmIChhdHRyc1trXSAhPT0gZm91bmRNYXJrLmF0dHJzW2tdKSB7XG4gICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAobmVlZHNVcGRhdGUpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRNYXJrID0gY2hlY2tNYXJrLnR5cGUuY3JlYXRlKHtcbiAgICAgICAgLi4uY2hlY2tNYXJrLmF0dHJzLFxuICAgICAgICAuLi5hdHRyc1xuICAgICAgfSk7XG4gICAgICB0ci5yZW1vdmVNYXJrKGZyb20sIHRvLCBjaGVja01hcmsudHlwZSk7XG4gICAgICB0ci5hZGRNYXJrKGZyb20sIHRvLCB1cGRhdGVkTWFyayk7XG4gICAgfVxuICB9KTtcbiAgaWYgKHRyLmRvY0NoYW5nZWQpIHtcbiAgICBlZGl0b3Iudmlldy5kaXNwYXRjaCh0cik7XG4gIH1cbn1cbnZhciBNYXJrVmlldyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29tcG9uZW50LCBwcm9wcywgb3B0aW9ucykge1xuICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgIHRoaXMuZWRpdG9yID0gcHJvcHMuZWRpdG9yO1xuICAgIHRoaXMub3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgIHRoaXMubWFyayA9IHByb3BzLm1hcms7XG4gICAgdGhpcy5IVE1MQXR0cmlidXRlcyA9IHByb3BzLkhUTUxBdHRyaWJ1dGVzO1xuICB9XG4gIGdldCBkb20oKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yLnZpZXcuZG9tO1xuICB9XG4gIGdldCBjb250ZW50RE9NKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG1hcmsgaW4gdGhlIGRvY3VtZW50LlxuICAgKiBAcGFyYW0gYXR0cnMgVGhlIGF0dHJpYnV0ZXMgdG8gdXBkYXRlLlxuICAgKi9cbiAgdXBkYXRlQXR0cmlidXRlcyhhdHRycywgY2hlY2tNYXJrKSB7XG4gICAgdXBkYXRlTWFya1ZpZXdBdHRyaWJ1dGVzKGNoZWNrTWFyayB8fCB0aGlzLm1hcmssIHRoaXMuZWRpdG9yLCBhdHRycyk7XG4gIH1cbiAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICBpZiAoIXRoaXMuZG9tIHx8ICF0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5pZ25vcmVNdXRhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmlnbm9yZU11dGF0aW9uKHsgbXV0YXRpb24gfSk7XG4gICAgfVxuICAgIGlmIChtdXRhdGlvbi50eXBlID09PSBcInNlbGVjdGlvblwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLmRvbS5jb250YWlucyhtdXRhdGlvbi50YXJnZXQpICYmIG11dGF0aW9uLnR5cGUgPT09IFwiY2hpbGRMaXN0XCIgJiYgKGlzaU9TKCkgfHwgaXNBbmRyb2lkKCkpICYmIHRoaXMuZWRpdG9yLmlzRm9jdXNlZCkge1xuICAgICAgY29uc3QgY2hhbmdlZE5vZGVzID0gWy4uLkFycmF5LmZyb20obXV0YXRpb24uYWRkZWROb2RlcyksIC4uLkFycmF5LmZyb20obXV0YXRpb24ucmVtb3ZlZE5vZGVzKV07XG4gICAgICBpZiAoY2hhbmdlZE5vZGVzLmV2ZXJ5KChub2RlKSA9PiBub2RlLmlzQ29udGVudEVkaXRhYmxlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbnRlbnRET00gPT09IG11dGF0aW9uLnRhcmdldCAmJiBtdXRhdGlvbi50eXBlID09PSBcImF0dHJpYnV0ZXNcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbnRlbnRET00uY29udGFpbnMobXV0YXRpb24udGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL05vZGUudHNcbnZhciBOb2RlMyA9IGNsYXNzIF9Ob2RlIGV4dGVuZHMgRXh0ZW5kYWJsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gXCJub2RlXCI7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBOb2RlIGluc3RhbmNlXG4gICAqIEBwYXJhbSBjb25maWcgLSBOb2RlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICovXG4gIHN0YXRpYyBjcmVhdGUoY29uZmlnID0ge30pIHtcbiAgICBjb25zdCByZXNvbHZlZENvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09IFwiZnVuY3Rpb25cIiA/IGNvbmZpZygpIDogY29uZmlnO1xuICAgIHJldHVybiBuZXcgX05vZGUocmVzb2x2ZWRDb25maWcpO1xuICB9XG4gIGNvbmZpZ3VyZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNvbmZpZ3VyZShvcHRpb25zKTtcbiAgfVxuICBleHRlbmQoZXh0ZW5kZWRDb25maWcpIHtcbiAgICBjb25zdCByZXNvbHZlZENvbmZpZyA9IHR5cGVvZiBleHRlbmRlZENvbmZpZyA9PT0gXCJmdW5jdGlvblwiID8gZXh0ZW5kZWRDb25maWcoKSA6IGV4dGVuZGVkQ29uZmlnO1xuICAgIHJldHVybiBzdXBlci5leHRlbmQocmVzb2x2ZWRDb25maWcpO1xuICB9XG59O1xuXG4vLyBzcmMvTm9kZVZpZXcudHNcbmltcG9ydCB7IE5vZGVTZWxlY3Rpb24gYXMgTm9kZVNlbGVjdGlvbjUgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xudmFyIE5vZGVWaWV3ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb21wb25lbnQsIHByb3BzLCBvcHRpb25zKSB7XG4gICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgdGhpcy5lZGl0b3IgPSBwcm9wcy5lZGl0b3I7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgc3RvcEV2ZW50OiBudWxsLFxuICAgICAgaWdub3JlTXV0YXRpb246IG51bGwsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgICB0aGlzLmV4dGVuc2lvbiA9IHByb3BzLmV4dGVuc2lvbjtcbiAgICB0aGlzLm5vZGUgPSBwcm9wcy5ub2RlO1xuICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBwcm9wcy5kZWNvcmF0aW9ucztcbiAgICB0aGlzLmlubmVyRGVjb3JhdGlvbnMgPSBwcm9wcy5pbm5lckRlY29yYXRpb25zO1xuICAgIHRoaXMudmlldyA9IHByb3BzLnZpZXc7XG4gICAgdGhpcy5IVE1MQXR0cmlidXRlcyA9IHByb3BzLkhUTUxBdHRyaWJ1dGVzO1xuICAgIHRoaXMuZ2V0UG9zID0gcHJvcHMuZ2V0UG9zO1xuICAgIHRoaXMubW91bnQoKTtcbiAgfVxuICBtb3VudCgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZ2V0IGRvbSgpIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0b3Iudmlldy5kb207XG4gIH1cbiAgZ2V0IGNvbnRlbnRET00oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgb25EcmFnU3RhcnQoZXZlbnQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgY29uc3QgeyB2aWV3IH0gPSB0aGlzLmVkaXRvcjtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgY29uc3QgZHJhZ0hhbmRsZSA9IHRhcmdldC5ub2RlVHlwZSA9PT0gMyA/IChfYSA9IHRhcmdldC5wYXJlbnRFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2xvc2VzdChcIltkYXRhLWRyYWctaGFuZGxlXVwiKSA6IHRhcmdldC5jbG9zZXN0KFwiW2RhdGEtZHJhZy1oYW5kbGVdXCIpO1xuICAgIGlmICghdGhpcy5kb20gfHwgKChfYiA9IHRoaXMuY29udGVudERPTSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNvbnRhaW5zKHRhcmdldCkpIHx8ICFkcmFnSGFuZGxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgeSA9IDA7XG4gICAgaWYgKHRoaXMuZG9tICE9PSBkcmFnSGFuZGxlKSB7XG4gICAgICBjb25zdCBkb21Cb3ggPSB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGhhbmRsZUJveCA9IGRyYWdIYW5kbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBvZmZzZXRYID0gKF9kID0gZXZlbnQub2Zmc2V0WCkgIT0gbnVsbCA/IF9kIDogKF9jID0gZXZlbnQubmF0aXZlRXZlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5vZmZzZXRYO1xuICAgICAgY29uc3Qgb2Zmc2V0WSA9IChfZiA9IGV2ZW50Lm9mZnNldFkpICE9IG51bGwgPyBfZiA6IChfZSA9IGV2ZW50Lm5hdGl2ZUV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Uub2Zmc2V0WTtcbiAgICAgIHggPSBoYW5kbGVCb3gueCAtIGRvbUJveC54ICsgb2Zmc2V0WDtcbiAgICAgIHkgPSBoYW5kbGVCb3gueSAtIGRvbUJveC55ICsgb2Zmc2V0WTtcbiAgICB9XG4gICAgY29uc3QgY2xvbmVkTm9kZSA9IHRoaXMuZG9tLmNsb25lTm9kZSh0cnVlKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZG9tQm94ID0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjbG9uZWROb2RlLnN0eWxlLndpZHRoID0gYCR7TWF0aC5yb3VuZChkb21Cb3gud2lkdGgpfXB4YDtcbiAgICAgIGNsb25lZE5vZGUuc3R5bGUuaGVpZ2h0ID0gYCR7TWF0aC5yb3VuZChkb21Cb3guaGVpZ2h0KX1weGA7XG4gICAgICBjbG9uZWROb2RlLnN0eWxlLmJveFNpemluZyA9IFwiYm9yZGVyLWJveFwiO1xuICAgICAgY2xvbmVkTm9kZS5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIGxldCBkcmFnSW1hZ2VXcmFwcGVyID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgZHJhZ0ltYWdlV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBkcmFnSW1hZ2VXcmFwcGVyLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgZHJhZ0ltYWdlV3JhcHBlci5zdHlsZS50b3AgPSBcIi05OTk5cHhcIjtcbiAgICAgIGRyYWdJbWFnZVdyYXBwZXIuc3R5bGUubGVmdCA9IFwiLTk5OTlweFwiO1xuICAgICAgZHJhZ0ltYWdlV3JhcHBlci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgICBkcmFnSW1hZ2VXcmFwcGVyLmFwcGVuZENoaWxkKGNsb25lZE5vZGUpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkcmFnSW1hZ2VXcmFwcGVyKTtcbiAgICAgIChfZyA9IGV2ZW50LmRhdGFUcmFuc2ZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLnNldERyYWdJbWFnZShjbG9uZWROb2RlLCB4LCB5KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGRyYWdJbWFnZVdyYXBwZXIpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRyYWdJbWFnZVdyYXBwZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGRyYWdJbWFnZVdyYXBwZXIucmVtb3ZlKCk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXRQb3MoKTtcbiAgICBpZiAodHlwZW9mIHBvcyAhPT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBOb2RlU2VsZWN0aW9uNS5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIHBvcyk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIHZpZXcuZGlzcGF0Y2godHJhbnNhY3Rpb24pO1xuICB9XG4gIHN0b3BFdmVudChldmVudCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXRoaXMuZG9tKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnN0b3BFdmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnN0b3BFdmVudCh7IGV2ZW50IH0pO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgY29uc3QgaXNJbkVsZW1lbnQgPSB0aGlzLmRvbS5jb250YWlucyh0YXJnZXQpICYmICEoKF9hID0gdGhpcy5jb250ZW50RE9NKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY29udGFpbnModGFyZ2V0KSk7XG4gICAgaWYgKCFpc0luRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpc0RyYWdFdmVudCA9IGV2ZW50LnR5cGUuc3RhcnRzV2l0aChcImRyYWdcIik7XG4gICAgY29uc3QgaXNEcm9wRXZlbnQgPSBldmVudC50eXBlID09PSBcImRyb3BcIjtcbiAgICBjb25zdCBpc0lucHV0ID0gW1wiSU5QVVRcIiwgXCJCVVRUT05cIiwgXCJTRUxFQ1RcIiwgXCJURVhUQVJFQVwiXS5pbmNsdWRlcyh0YXJnZXQudGFnTmFtZSkgfHwgdGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlO1xuICAgIGlmIChpc0lucHV0ICYmICFpc0Ryb3BFdmVudCAmJiAhaXNEcmFnRXZlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB7IGlzRWRpdGFibGUgfSA9IHRoaXMuZWRpdG9yO1xuICAgIGNvbnN0IHsgaXNEcmFnZ2luZyB9ID0gdGhpcztcbiAgICBjb25zdCBpc0RyYWdnYWJsZSA9ICEhdGhpcy5ub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGU7XG4gICAgY29uc3QgaXNTZWxlY3RhYmxlID0gTm9kZVNlbGVjdGlvbjUuaXNTZWxlY3RhYmxlKHRoaXMubm9kZSk7XG4gICAgY29uc3QgaXNDb3B5RXZlbnQgPSBldmVudC50eXBlID09PSBcImNvcHlcIjtcbiAgICBjb25zdCBpc1Bhc3RlRXZlbnQgPSBldmVudC50eXBlID09PSBcInBhc3RlXCI7XG4gICAgY29uc3QgaXNDdXRFdmVudCA9IGV2ZW50LnR5cGUgPT09IFwiY3V0XCI7XG4gICAgY29uc3QgaXNDbGlja0V2ZW50ID0gZXZlbnQudHlwZSA9PT0gXCJtb3VzZWRvd25cIjtcbiAgICBpZiAoIWlzRHJhZ2dhYmxlICYmIGlzU2VsZWN0YWJsZSAmJiBpc0RyYWdFdmVudCAmJiBldmVudC50YXJnZXQgPT09IHRoaXMuZG9tKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBpZiAoaXNEcmFnZ2FibGUgJiYgaXNEcmFnRXZlbnQgJiYgIWlzRHJhZ2dpbmcgJiYgZXZlbnQudGFyZ2V0ID09PSB0aGlzLmRvbSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlzRHJhZ2dhYmxlICYmIGlzRWRpdGFibGUgJiYgIWlzRHJhZ2dpbmcgJiYgaXNDbGlja0V2ZW50KSB7XG4gICAgICBjb25zdCBkcmFnSGFuZGxlID0gdGFyZ2V0LmNsb3Nlc3QoXCJbZGF0YS1kcmFnLWhhbmRsZV1cIik7XG4gICAgICBjb25zdCBpc1ZhbGlkRHJhZ0hhbmRsZSA9IGRyYWdIYW5kbGUgJiYgKHRoaXMuZG9tID09PSBkcmFnSGFuZGxlIHx8IHRoaXMuZG9tLmNvbnRhaW5zKGRyYWdIYW5kbGUpKTtcbiAgICAgIGlmIChpc1ZhbGlkRHJhZ0hhbmRsZSkge1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgIFwiZHJhZ2VuZFwiLFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeyBvbmNlOiB0cnVlIH1cbiAgICAgICAgKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICBcImRyb3BcIixcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgb25jZTogdHJ1ZSB9XG4gICAgICAgICk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgXCJtb3VzZXVwXCIsXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IG9uY2U6IHRydWUgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEcmFnZ2luZyB8fCBpc0Ryb3BFdmVudCB8fCBpc0NvcHlFdmVudCB8fCBpc1Bhc3RlRXZlbnQgfHwgaXNDdXRFdmVudCB8fCBpc0NsaWNrRXZlbnQgJiYgaXNTZWxlY3RhYmxlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIERPTSBbbXV0YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NdXRhdGlvbk9ic2VydmVyKSBvciBhIHNlbGVjdGlvbiBjaGFuZ2UgaGFwcGVucyB3aXRoaW4gdGhlIHZpZXcuXG4gICAqIEByZXR1cm4gYGZhbHNlYCBpZiB0aGUgZWRpdG9yIHNob3VsZCByZS1yZWFkIHRoZSBzZWxlY3Rpb24gb3IgcmUtcGFyc2UgdGhlIHJhbmdlIGFyb3VuZCB0aGUgbXV0YXRpb25cbiAgICogQHJldHVybiBgdHJ1ZWAgaWYgaXQgY2FuIHNhZmVseSBiZSBpZ25vcmVkLlxuICAgKi9cbiAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICBpZiAoIXRoaXMuZG9tIHx8ICF0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5pZ25vcmVNdXRhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmlnbm9yZU11dGF0aW9uKHsgbXV0YXRpb24gfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm5vZGUuaXNMZWFmIHx8IHRoaXMubm9kZS5pc0F0b20pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gXCJzZWxlY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5kb20uY29udGFpbnMobXV0YXRpb24udGFyZ2V0KSAmJiBtdXRhdGlvbi50eXBlID09PSBcImNoaWxkTGlzdFwiICYmIChpc2lPUygpIHx8IGlzQW5kcm9pZCgpKSAmJiB0aGlzLmVkaXRvci5pc0ZvY3VzZWQpIHtcbiAgICAgIGNvbnN0IGNoYW5nZWROb2RlcyA9IFsuLi5BcnJheS5mcm9tKG11dGF0aW9uLmFkZGVkTm9kZXMpLCAuLi5BcnJheS5mcm9tKG11dGF0aW9uLnJlbW92ZWROb2RlcyldO1xuICAgICAgaWYgKGNoYW5nZWROb2Rlcy5ldmVyeSgobm9kZSkgPT4gbm9kZS5pc0NvbnRlbnRFZGl0YWJsZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5jb250ZW50RE9NID09PSBtdXRhdGlvbi50YXJnZXQgJiYgbXV0YXRpb24udHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb250ZW50RE9NLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgYXR0cmlidXRlcyBvZiB0aGUgcHJvc2VtaXJyb3Igbm9kZS5cbiAgICovXG4gIHVwZGF0ZUF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLmNvbW1hbmQoKHsgdHIgfSkgPT4ge1xuICAgICAgY29uc3QgcG9zID0gdGhpcy5nZXRQb3MoKTtcbiAgICAgIGlmICh0eXBlb2YgcG9zICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCB2b2lkIDAsIHtcbiAgICAgICAgLi4udGhpcy5ub2RlLmF0dHJzLFxuICAgICAgICAuLi5hdHRyaWJ1dGVzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgdGhlIG5vZGUuXG4gICAqL1xuICBkZWxldGVOb2RlKCkge1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLmdldFBvcygpO1xuICAgIGlmICh0eXBlb2YgZnJvbSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0byA9IGZyb20gKyB0aGlzLm5vZGUubm9kZVNpemU7XG4gICAgdGhpcy5lZGl0b3IuY29tbWFuZHMuZGVsZXRlUmFuZ2UoeyBmcm9tLCB0byB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3Bhc3RlUnVsZXMvbWFya1Bhc3RlUnVsZS50c1xuZnVuY3Rpb24gbWFya1Bhc3RlUnVsZShjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQYXN0ZVJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2gsIHBhc3RlRXZlbnQgfSkgPT4ge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdm9pZCAwLCBtYXRjaCwgcGFzdGVFdmVudCk7XG4gICAgICBpZiAoYXR0cmlidXRlcyA9PT0gZmFsc2UgfHwgYXR0cmlidXRlcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdHIgfSA9IHN0YXRlO1xuICAgICAgY29uc3QgY2FwdHVyZUdyb3VwID0gbWF0Y2hbbWF0Y2gubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBmdWxsTWF0Y2ggPSBtYXRjaFswXTtcbiAgICAgIGxldCBtYXJrRW5kID0gcmFuZ2UudG87XG4gICAgICBpZiAoY2FwdHVyZUdyb3VwKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0U3BhY2VzID0gZnVsbE1hdGNoLnNlYXJjaCgvXFxTLyk7XG4gICAgICAgIGNvbnN0IHRleHRTdGFydCA9IHJhbmdlLmZyb20gKyBmdWxsTWF0Y2guaW5kZXhPZihjYXB0dXJlR3JvdXApO1xuICAgICAgICBjb25zdCB0ZXh0RW5kID0gdGV4dFN0YXJ0ICsgY2FwdHVyZUdyb3VwLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZXhjbHVkZWRNYXJrcyA9IGdldE1hcmtzQmV0d2VlbihyYW5nZS5mcm9tLCByYW5nZS50bywgc3RhdGUuZG9jKS5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgICAgICBjb25zdCBleGNsdWRlZCA9IGl0ZW0ubWFyay50eXBlLmV4Y2x1ZGVkO1xuICAgICAgICAgIHJldHVybiBleGNsdWRlZC5maW5kKCh0eXBlKSA9PiB0eXBlID09PSBjb25maWcudHlwZSAmJiB0eXBlICE9PSBpdGVtLm1hcmsudHlwZSk7XG4gICAgICAgIH0pLmZpbHRlcigoaXRlbSkgPT4gaXRlbS50byA+IHRleHRTdGFydCk7XG4gICAgICAgIGlmIChleGNsdWRlZE1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0RW5kIDwgcmFuZ2UudG8pIHtcbiAgICAgICAgICB0ci5kZWxldGUodGV4dEVuZCwgcmFuZ2UudG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0U3RhcnQgPiByYW5nZS5mcm9tKSB7XG4gICAgICAgICAgdHIuZGVsZXRlKHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcywgdGV4dFN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBtYXJrRW5kID0gcmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzICsgY2FwdHVyZUdyb3VwLmxlbmd0aDtcbiAgICAgICAgdHIuYWRkTWFyayhyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIG1hcmtFbmQsIGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzIHx8IHt9KSk7XG4gICAgICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsoY29uZmlnLnR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9wYXN0ZVJ1bGVzL25vZGVQYXN0ZVJ1bGUudHNcbmZ1bmN0aW9uIG5vZGVQYXN0ZVJ1bGUoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUGFzdGVSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyKHsgbWF0Y2gsIGNoYWluLCByYW5nZSwgcGFzdGVFdmVudCB9KSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB2b2lkIDAsIG1hdGNoLCBwYXN0ZUV2ZW50KTtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldENvbnRlbnQsIHZvaWQgMCwgYXR0cmlidXRlcyk7XG4gICAgICBpZiAoYXR0cmlidXRlcyA9PT0gZmFsc2UgfHwgYXR0cmlidXRlcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vZGUgPSB7IHR5cGU6IGNvbmZpZy50eXBlLm5hbWUsIGF0dHJzOiBhdHRyaWJ1dGVzIH07XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICBub2RlLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoLmlucHV0KSB7XG4gICAgICAgIGNoYWluKCkuZGVsZXRlUmFuZ2UocmFuZ2UpLmluc2VydENvbnRlbnRBdChyYW5nZS5mcm9tLCBub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvcGFzdGVSdWxlcy90ZXh0UGFzdGVSdWxlLnRzXG5mdW5jdGlvbiB0ZXh0UGFzdGVSdWxlKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFBhc3RlUnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICBsZXQgaW5zZXJ0ID0gY29uZmlnLnJlcGxhY2U7XG4gICAgICBsZXQgc3RhcnQgPSByYW5nZS5mcm9tO1xuICAgICAgY29uc3QgZW5kID0gcmFuZ2UudG87XG4gICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gbWF0Y2hbMF0ubGFzdEluZGV4T2YobWF0Y2hbMV0pO1xuICAgICAgICBpbnNlcnQgKz0gbWF0Y2hbMF0uc2xpY2Uob2Zmc2V0ICsgbWF0Y2hbMV0ubGVuZ3RoKTtcbiAgICAgICAgc3RhcnQgKz0gb2Zmc2V0O1xuICAgICAgICBjb25zdCBjdXRPZmYgPSBzdGFydCAtIGVuZDtcbiAgICAgICAgaWYgKGN1dE9mZiA+IDApIHtcbiAgICAgICAgICBpbnNlcnQgPSBtYXRjaFswXS5zbGljZShvZmZzZXQgLSBjdXRPZmYsIG9mZnNldCkgKyBpbnNlcnQ7XG4gICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXRlLnRyLmluc2VydFRleHQoaW5zZXJ0LCBzdGFydCwgZW5kKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvVHJhY2tlci50c1xudmFyIFRyYWNrZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHRyYW5zYWN0aW9uKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICAgIHRoaXMuY3VycmVudFN0ZXAgPSB0aGlzLnRyYW5zYWN0aW9uLnN0ZXBzLmxlbmd0aDtcbiAgfVxuICBtYXAocG9zaXRpb24pIHtcbiAgICBsZXQgZGVsZXRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IG1hcHBlZFBvc2l0aW9uID0gdGhpcy50cmFuc2FjdGlvbi5zdGVwcy5zbGljZSh0aGlzLmN1cnJlbnRTdGVwKS5yZWR1Y2UoKG5ld1Bvc2l0aW9uLCBzdGVwKSA9PiB7XG4gICAgICBjb25zdCBtYXBSZXN1bHQgPSBzdGVwLmdldE1hcCgpLm1hcFJlc3VsdChuZXdQb3NpdGlvbik7XG4gICAgICBpZiAobWFwUmVzdWx0LmRlbGV0ZWQpIHtcbiAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwUmVzdWx0LnBvcztcbiAgICB9LCBwb3NpdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc2l0aW9uOiBtYXBwZWRQb3NpdGlvbixcbiAgICAgIGRlbGV0ZWRcbiAgICB9O1xuICB9XG59O1xuZXhwb3J0IHtcbiAgQ29tbWFuZE1hbmFnZXIsXG4gIEVkaXRvcixcbiAgRXh0ZW5kYWJsZSxcbiAgRXh0ZW5zaW9uLFxuICBGcmFnbWVudDYgYXMgRnJhZ21lbnQsXG4gIElucHV0UnVsZSxcbiAgTWFyayxcbiAgTWFya1ZpZXcsXG4gIE5vZGUzIGFzIE5vZGUsXG4gIE5vZGVQb3MsXG4gIE5vZGVWaWV3LFxuICBQYXN0ZVJ1bGUsXG4gIFRyYWNrZXIsXG4gIGNhbGxPclJldHVybixcbiAgY2FuSW5zZXJ0Tm9kZSxcbiAgY29tYmluZVRyYW5zYWN0aW9uU3RlcHMsXG4gIGNvbW1hbmRzX2V4cG9ydHMgYXMgY29tbWFuZHMsXG4gIGNyZWF0ZUF0b21CbG9ja01hcmtkb3duU3BlYyxcbiAgY3JlYXRlQmxvY2tNYXJrZG93blNwZWMsXG4gIGNyZWF0ZUNoYWluYWJsZVN0YXRlLFxuICBjcmVhdGVEb2N1bWVudCxcbiAgaCBhcyBjcmVhdGVFbGVtZW50LFxuICBjcmVhdGVJbmxpbmVNYXJrZG93blNwZWMsXG4gIGNyZWF0ZU5vZGVGcm9tQ29udGVudCxcbiAgY3JlYXRlU3R5bGVUYWcsXG4gIGRlZmF1bHRCbG9ja0F0LFxuICBkZWxldGVQcm9wcyxcbiAgZWxlbWVudEZyb21TdHJpbmcsXG4gIGVzY2FwZUZvclJlZ0V4LFxuICBleHRlbnNpb25zX2V4cG9ydHMgYXMgZXh0ZW5zaW9ucyxcbiAgZmluZENoaWxkcmVuLFxuICBmaW5kQ2hpbGRyZW5JblJhbmdlLFxuICBmaW5kRHVwbGljYXRlcyxcbiAgZmluZFBhcmVudE5vZGUsXG4gIGZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zLFxuICBmbGF0dGVuRXh0ZW5zaW9ucyxcbiAgZnJvbVN0cmluZyxcbiAgZ2VuZXJhdGVIVE1MLFxuICBnZW5lcmF0ZUpTT04sXG4gIGdlbmVyYXRlVGV4dCxcbiAgZ2V0QXR0cmlidXRlcyxcbiAgZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zLFxuICBnZXRDaGFuZ2VkUmFuZ2VzLFxuICBnZXREZWJ1Z0pTT04sXG4gIGdldEV4dGVuc2lvbkZpZWxkLFxuICBnZXRIVE1MRnJvbUZyYWdtZW50LFxuICBnZXRNYXJrQXR0cmlidXRlcyxcbiAgZ2V0TWFya1JhbmdlLFxuICBnZXRNYXJrVHlwZSxcbiAgZ2V0TWFya3NCZXR3ZWVuLFxuICBnZXROb2RlQXRQb3NpdGlvbixcbiAgZ2V0Tm9kZUF0dHJpYnV0ZXMsXG4gIGdldE5vZGVUeXBlLFxuICBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMsXG4gIGdldFNjaGVtYSxcbiAgZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMsXG4gIGdldFNjaGVtYVR5cGVCeU5hbWUsXG4gIGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lLFxuICBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMsXG4gIGdldFRleHQsXG4gIGdldFRleHRCZXR3ZWVuLFxuICBnZXRUZXh0Q29udGVudEZyb21Ob2RlcyxcbiAgZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYSxcbiAgaCxcbiAgaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlLFxuICBpbnB1dFJ1bGVzUGx1Z2luLFxuICBpc0FjdGl2ZSxcbiAgaXNBbmRyb2lkLFxuICBpc0F0RW5kT2ZOb2RlLFxuICBpc0F0U3RhcnRPZk5vZGUsXG4gIGlzRW1wdHlPYmplY3QsXG4gIGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkLFxuICBpc0Z1bmN0aW9uLFxuICBpc0xpc3QsXG4gIGlzTWFjT1MsXG4gIGlzTWFya0FjdGl2ZSxcbiAgaXNOb2RlQWN0aXZlLFxuICBpc05vZGVFbXB0eSxcbiAgaXNOb2RlU2VsZWN0aW9uLFxuICBpc051bWJlcixcbiAgaXNQbGFpbk9iamVjdCxcbiAgaXNSZWdFeHAsXG4gIGlzU3RyaW5nLFxuICBpc1RleHRTZWxlY3Rpb24sXG4gIGlzaU9TLFxuICBtYXJrSW5wdXRSdWxlLFxuICBtYXJrUGFzdGVSdWxlLFxuICBtYXJrZG93bl9leHBvcnRzIGFzIG1hcmtkb3duLFxuICBtZXJnZUF0dHJpYnV0ZXMsXG4gIG1lcmdlRGVlcCxcbiAgbWluTWF4LFxuICBub2RlSW5wdXRSdWxlLFxuICBub2RlUGFzdGVSdWxlLFxuICBvYmplY3RJbmNsdWRlcyxcbiAgcGFyc2VBdHRyaWJ1dGVzLFxuICBwYXJzZUluZGVudGVkQmxvY2tzLFxuICBwYXN0ZVJ1bGVzUGx1Z2luLFxuICBwb3NUb0RPTVJlY3QsXG4gIHJlbW92ZUR1cGxpY2F0ZXMsXG4gIHJlbmRlck5lc3RlZE1hcmtkb3duQ29udGVudCxcbiAgcmVzb2x2ZUV4dGVuc2lvbnMsXG4gIHJlc29sdmVGb2N1c1Bvc2l0aW9uLFxuICByZXdyaXRlVW5rbm93bkNvbnRlbnQsXG4gIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kLFxuICBzZXJpYWxpemVBdHRyaWJ1dGVzLFxuICBzb3J0RXh0ZW5zaW9ucyxcbiAgc3BsaXRFeHRlbnNpb25zLFxuICB0ZXh0SW5wdXRSdWxlLFxuICB0ZXh0UGFzdGVSdWxlLFxuICB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlLFxuICB1cGRhdGVNYXJrVmlld0F0dHJpYnV0ZXMsXG4gIHdyYXBwaW5nSW5wdXRSdWxlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/core/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   createElement: () => (/* binding */ h),\n/* harmony export */   h: () => (/* binding */ h),\n/* harmony export */   jsx: () => (/* binding */ h),\n/* harmony export */   jsxDEV: () => (/* binding */ h),\n/* harmony export */   jsxs: () => (/* binding */ h)\n/* harmony export */ });\n// src/jsx-runtime.ts\nfunction Fragment(props) {\n  return props.children;\n}\nvar h = (tag, attributes) => {\n  if (tag === \"slot\") {\n    return 0;\n  }\n  if (tag instanceof Function) {\n    return tag(attributes);\n  }\n  const { children, ...rest } = attributes != null ? attributes : {};\n  if (tag === \"svg\") {\n    throw new Error(\"SVG elements are not supported in the JSX syntax, use the array syntax instead\");\n  }\n  return [tag, rest, children];\n};\n\n//# sourceMappingURL=jsx-runtime.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL2Rpc3QvanN4LXJ1bnRpbWUvanN4LXJ1bnRpbWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvbW9ydG9ubWFidW1iby9Eb3dubG9hZHMvdGVzdGltaW5vbnktd2ViMV8xMC1tYWluL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvZGlzdC9qc3gtcnVudGltZS9qc3gtcnVudGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvanN4LXJ1bnRpbWUudHNcbmZ1bmN0aW9uIEZyYWdtZW50KHByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbn1cbnZhciBoID0gKHRhZywgYXR0cmlidXRlcykgPT4ge1xuICBpZiAodGFnID09PSBcInNsb3RcIikge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmICh0YWcgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgIHJldHVybiB0YWcoYXR0cmlidXRlcyk7XG4gIH1cbiAgY29uc3QgeyBjaGlsZHJlbiwgLi4ucmVzdCB9ID0gYXR0cmlidXRlcyAhPSBudWxsID8gYXR0cmlidXRlcyA6IHt9O1xuICBpZiAodGFnID09PSBcInN2Z1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU1ZHIGVsZW1lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluIHRoZSBKU1ggc3ludGF4LCB1c2UgdGhlIGFycmF5IHN5bnRheCBpbnN0ZWFkXCIpO1xuICB9XG4gIHJldHVybiBbdGFnLCByZXN0LCBjaGlsZHJlbl07XG59O1xuZXhwb3J0IHtcbiAgRnJhZ21lbnQsXG4gIGggYXMgY3JlYXRlRWxlbWVudCxcbiAgaCxcbiAgaCBhcyBqc3gsXG4gIGggYXMganN4REVWLFxuICBoIGFzIGpzeHNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc3gtcnVudGltZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-blockquote/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-blockquote/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blockquote: () => (/* binding */ Blockquote),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_core_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core/jsx-runtime */ \"(ssr)/./node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.js\");\n// src/blockquote.tsx\n\n\nvar inputRegex = /^\\s*>\\s$/;\nvar Blockquote = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"blockquote\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  content: \"block+\",\n  group: \"block\",\n  defining: true,\n  parseHTML() {\n    return [{ tag: \"blockquote\" }];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return /* @__PURE__ */ (0,_tiptap_core_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"blockquote\", { ...(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), children: /* @__PURE__ */ (0,_tiptap_core_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"slot\", {}) });\n  },\n  parseMarkdown: (token, helpers) => {\n    return helpers.createNode(\"blockquote\", void 0, helpers.parseChildren(token.tokens || []));\n  },\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return \"\";\n    }\n    const lines = [];\n    node.content.forEach((child) => {\n      const lineContent = h.renderChildren(child);\n      const withPrefix = lineContent.split(\"\\n\").map((line) => `> ${line}`).join(\"\\n\");\n      lines.push(withPrefix);\n    });\n    const linesWithSeparators = lines.flatMap((line) => [line, \"> \"]);\n    return linesWithSeparators.slice(0, -1).join(\"\\n\");\n  },\n  addCommands() {\n    return {\n      setBlockquote: () => ({ commands }) => {\n        return commands.wrapIn(this.name);\n      },\n      toggleBlockquote: () => ({ commands }) => {\n        return commands.toggleWrap(this.name);\n      },\n      unsetBlockquote: () => ({ commands }) => {\n        return commands.lift(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-b\": () => this.editor.commands.toggleBlockquote()\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n        find: inputRegex,\n        type: this.type\n      })\n    ];\n  }\n});\n\n// src/index.ts\nvar index_default = Blockquote;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYmxvY2txdW90ZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDd0U7QUFDekI7QUFDL0M7QUFDQSxpQkFBaUIsOENBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDLEdBQUc7QUFDSCxlQUFlLGdCQUFnQjtBQUMvQiwyQkFBMkIsNkRBQUcsaUJBQWlCLEdBQUcsNkRBQWUseUVBQXlFLDZEQUFHLFdBQVcsR0FBRztBQUMzSixHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxLQUFLO0FBQ3pFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0EsT0FBTztBQUNQLGlDQUFpQyxVQUFVO0FBQzNDO0FBQ0EsT0FBTztBQUNQLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTSwrREFBaUI7QUFDdkI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBS0U7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL21vcnRvbm1hYnVtYm8vRG93bmxvYWRzL3Rlc3RpbWlub255LXdlYjFfMTAtbWFpbi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYmxvY2txdW90ZS9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9ibG9ja3F1b3RlLnRzeFxuaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlLCB3cmFwcGluZ0lucHV0UnVsZSB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJAdGlwdGFwL2NvcmUvanN4LXJ1bnRpbWVcIjtcbnZhciBpbnB1dFJlZ2V4ID0gL15cXHMqPlxccyQvO1xudmFyIEJsb2NrcXVvdGUgPSBOb2RlLmNyZWF0ZSh7XG4gIG5hbWU6IFwiYmxvY2txdW90ZVwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge31cbiAgICB9O1xuICB9LFxuICBjb250ZW50OiBcImJsb2NrK1wiLFxuICBncm91cDogXCJibG9ja1wiLFxuICBkZWZpbmluZzogdHJ1ZSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbeyB0YWc6IFwiYmxvY2txdW90ZVwiIH1dO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFwiYmxvY2txdW90ZVwiLCB7IC4uLm1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzbG90XCIsIHt9KSB9KTtcbiAgfSxcbiAgcGFyc2VNYXJrZG93bjogKHRva2VuLCBoZWxwZXJzKSA9PiB7XG4gICAgcmV0dXJuIGhlbHBlcnMuY3JlYXRlTm9kZShcImJsb2NrcXVvdGVcIiwgdm9pZCAwLCBoZWxwZXJzLnBhcnNlQ2hpbGRyZW4odG9rZW4udG9rZW5zIHx8IFtdKSk7XG4gIH0sXG4gIHJlbmRlck1hcmtkb3duOiAobm9kZSwgaCkgPT4ge1xuICAgIGlmICghbm9kZS5jb250ZW50KSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgY29uc3QgbGluZXMgPSBbXTtcbiAgICBub2RlLmNvbnRlbnQuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgIGNvbnN0IGxpbmVDb250ZW50ID0gaC5yZW5kZXJDaGlsZHJlbihjaGlsZCk7XG4gICAgICBjb25zdCB3aXRoUHJlZml4ID0gbGluZUNvbnRlbnQuc3BsaXQoXCJcXG5cIikubWFwKChsaW5lKSA9PiBgPiAke2xpbmV9YCkuam9pbihcIlxcblwiKTtcbiAgICAgIGxpbmVzLnB1c2god2l0aFByZWZpeCk7XG4gICAgfSk7XG4gICAgY29uc3QgbGluZXNXaXRoU2VwYXJhdG9ycyA9IGxpbmVzLmZsYXRNYXAoKGxpbmUpID0+IFtsaW5lLCBcIj4gXCJdKTtcbiAgICByZXR1cm4gbGluZXNXaXRoU2VwYXJhdG9ycy5zbGljZSgwLCAtMSkuam9pbihcIlxcblwiKTtcbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEJsb2NrcXVvdGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLndyYXBJbih0aGlzLm5hbWUpO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZUJsb2NrcXVvdGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZVdyYXAodGhpcy5uYW1lKTtcbiAgICAgIH0sXG4gICAgICB1bnNldEJsb2NrcXVvdGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmxpZnQodGhpcy5uYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJNb2QtU2hpZnQtYlwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCbG9ja3F1b3RlKClcbiAgICB9O1xuICB9LFxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICB3cmFwcGluZ0lucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IEJsb2NrcXVvdGU7XG5leHBvcnQge1xuICBCbG9ja3F1b3RlLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHQsXG4gIGlucHV0UmVnZXhcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-blockquote/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-bold/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-bold/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bold: () => (/* binding */ Bold),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   starInputRegex: () => (/* binding */ starInputRegex),\n/* harmony export */   starPasteRegex: () => (/* binding */ starPasteRegex),\n/* harmony export */   underscoreInputRegex: () => (/* binding */ underscoreInputRegex),\n/* harmony export */   underscorePasteRegex: () => (/* binding */ underscorePasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_core_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core/jsx-runtime */ \"(ssr)/./node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.js\");\n// src/bold.tsx\n\n\nvar starInputRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))$/;\nvar starPasteRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))/g;\nvar underscoreInputRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))$/;\nvar underscorePasteRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))/g;\nvar Bold = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n  name: \"bold\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"strong\"\n      },\n      {\n        tag: \"b\",\n        getAttrs: (node) => node.style.fontWeight !== \"normal\" && null\n      },\n      {\n        style: \"font-weight=400\",\n        clearMark: (mark) => mark.type.name === this.name\n      },\n      {\n        style: \"font-weight\",\n        getAttrs: (value) => /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return /* @__PURE__ */ (0,_tiptap_core_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"strong\", { ...(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), children: /* @__PURE__ */ (0,_tiptap_core_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"slot\", {}) });\n  },\n  markdownTokenName: \"strong\",\n  parseMarkdown: (token, helpers) => {\n    return helpers.applyMark(\"bold\", helpers.parseInline(token.tokens || []));\n  },\n  renderMarkdown: (node, h) => {\n    return `**${h.renderChildren(node)}**`;\n  },\n  addCommands() {\n    return {\n      setBold: () => ({ commands }) => {\n        return commands.setMark(this.name);\n      },\n      toggleBold: () => ({ commands }) => {\n        return commands.toggleMark(this.name);\n      },\n      unsetBold: () => ({ commands }) => {\n        return commands.unsetMark(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-b\": () => this.editor.commands.toggleBold(),\n      \"Mod-B\": () => this.editor.commands.toggleBold()\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n        find: starInputRegex,\n        type: this.type\n      }),\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n        find: underscoreInputRegex,\n        type: this.type\n      })\n    ];\n  },\n  addPasteRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n        find: starPasteRegex,\n        type: this.type\n      }),\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n        find: underscorePasteRegex,\n        type: this.type\n      })\n    ];\n  }\n});\n\n// src/index.ts\nvar index_default = Bold;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYm9sZC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDbUY7QUFDcEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhDQUFJO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxrREFBa0QsR0FBRztBQUNyRDtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWUsZ0JBQWdCO0FBQy9CLDJCQUEyQiw2REFBRyxhQUFhLEdBQUcsNkRBQWUseUVBQXlFLDZEQUFHLFdBQVcsR0FBRztBQUN2SixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QyxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0EsT0FBTztBQUNQLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0EsT0FBTztBQUNQLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLDJEQUFhO0FBQ25CO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTSwyREFBYTtBQUNuQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLDJEQUFhO0FBQ25CO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTSwyREFBYTtBQUNuQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFRRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvbW9ydG9ubWFidW1iby9Eb3dubG9hZHMvdGVzdGltaW5vbnktd2ViMV8xMC1tYWluL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1ib2xkL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2JvbGQudHN4XG5pbXBvcnQgeyBNYXJrLCBtYXJrSW5wdXRSdWxlLCBtYXJrUGFzdGVSdWxlLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwiQHRpcHRhcC9jb3JlL2pzeC1ydW50aW1lXCI7XG52YXIgc3RhcklucHV0UmVnZXggPSAvKD86XnxcXHMpKFxcKlxcKig/IVxccytcXCpcXCopKCg/OlteKl0rKSlcXCpcXCooPyFcXHMrXFwqXFwqKSkkLztcbnZhciBzdGFyUGFzdGVSZWdleCA9IC8oPzpefFxccykoXFwqXFwqKD8hXFxzK1xcKlxcKikoKD86W14qXSspKVxcKlxcKig/IVxccytcXCpcXCopKS9nO1xudmFyIHVuZGVyc2NvcmVJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKShfXyg/IVxccytfXykoKD86W15fXSspKV9fKD8hXFxzK19fKSkkLztcbnZhciB1bmRlcnNjb3JlUGFzdGVSZWdleCA9IC8oPzpefFxccykoX18oPyFcXHMrX18pKCg/OlteX10rKSlfXyg/IVxccytfXykpL2c7XG52YXIgQm9sZCA9IE1hcmsuY3JlYXRlKHtcbiAgbmFtZTogXCJib2xkXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fVxuICAgIH07XG4gIH0sXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6IFwic3Ryb25nXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJiXCIsXG4gICAgICAgIGdldEF0dHJzOiAobm9kZSkgPT4gbm9kZS5zdHlsZS5mb250V2VpZ2h0ICE9PSBcIm5vcm1hbFwiICYmIG51bGxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiBcImZvbnQtd2VpZ2h0PTQwMFwiLFxuICAgICAgICBjbGVhck1hcms6IChtYXJrKSA9PiBtYXJrLnR5cGUubmFtZSA9PT0gdGhpcy5uYW1lXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdHlsZTogXCJmb250LXdlaWdodFwiLFxuICAgICAgICBnZXRBdHRyczogKHZhbHVlKSA9PiAvXihib2xkKGVyKT98WzUtOV1cXGR7Mix9KSQvLnRlc3QodmFsdWUpICYmIG51bGxcbiAgICAgIH1cbiAgICBdO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFwic3Ryb25nXCIsIHsgLi4ubWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcInNsb3RcIiwge30pIH0pO1xuICB9LFxuICBtYXJrZG93blRva2VuTmFtZTogXCJzdHJvbmdcIixcbiAgcGFyc2VNYXJrZG93bjogKHRva2VuLCBoZWxwZXJzKSA9PiB7XG4gICAgcmV0dXJuIGhlbHBlcnMuYXBwbHlNYXJrKFwiYm9sZFwiLCBoZWxwZXJzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucyB8fCBbXSkpO1xuICB9LFxuICByZW5kZXJNYXJrZG93bjogKG5vZGUsIGgpID0+IHtcbiAgICByZXR1cm4gYCoqJHtoLnJlbmRlckNoaWxkcmVuKG5vZGUpfSoqYDtcbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEJvbGQ6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGVCb2xkOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9LFxuICAgICAgdW5zZXRCb2xkOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJNb2QtYlwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCb2xkKCksXG4gICAgICBcIk1vZC1CXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUJvbGQoKVxuICAgIH07XG4gIH0sXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBzdGFySW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KSxcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiB1bmRlcnNjb3JlSW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KVxuICAgIF07XG4gIH0sXG4gIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiBzdGFyUGFzdGVSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KSxcbiAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiB1bmRlcnNjb3JlUGFzdGVSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gQm9sZDtcbmV4cG9ydCB7XG4gIEJvbGQsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdCxcbiAgc3RhcklucHV0UmVnZXgsXG4gIHN0YXJQYXN0ZVJlZ2V4LFxuICB1bmRlcnNjb3JlSW5wdXRSZWdleCxcbiAgdW5kZXJzY29yZVBhc3RlUmVnZXhcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-bold/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-code-block/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-code-block/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CodeBlock: () => (/* binding */ CodeBlock),\n/* harmony export */   backtickInputRegex: () => (/* binding */ backtickInputRegex),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   tildeInputRegex: () => (/* binding */ tildeInputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\");\n// src/code-block.ts\n\n\nvar DEFAULT_TAB_SIZE = 4;\nvar backtickInputRegex = /^```([a-z]+)?[\\s\\n]$/;\nvar tildeInputRegex = /^~~~([a-z]+)?[\\s\\n]$/;\nvar CodeBlock = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Node.create({\n  name: \"codeBlock\",\n  addOptions() {\n    return {\n      languageClassPrefix: \"language-\",\n      exitOnTripleEnter: true,\n      exitOnArrowDown: true,\n      defaultLanguage: null,\n      enableTabIndentation: false,\n      tabSize: DEFAULT_TAB_SIZE,\n      HTMLAttributes: {}\n    };\n  },\n  content: \"text*\",\n  marks: \"\",\n  group: \"block\",\n  code: true,\n  defining: true,\n  addAttributes() {\n    return {\n      language: {\n        default: this.options.defaultLanguage,\n        parseHTML: (element) => {\n          var _a;\n          const { languageClassPrefix } = this.options;\n          if (!languageClassPrefix) {\n            return null;\n          }\n          const classNames = [...((_a = element.firstElementChild) == null ? void 0 : _a.classList) || []];\n          const languages = classNames.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, \"\"));\n          const language = languages[0];\n          if (!language) {\n            return null;\n          }\n          return language;\n        },\n        rendered: false\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"pre\",\n        preserveWhitespace: \"full\"\n      }\n    ];\n  },\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      \"pre\",\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n      [\n        \"code\",\n        {\n          class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null\n        },\n        0\n      ]\n    ];\n  },\n  markdownTokenName: \"code\",\n  parseMarkdown: (token, helpers) => {\n    var _a;\n    if (((_a = token.raw) == null ? void 0 : _a.startsWith(\"```\")) === false && token.codeBlockStyle !== \"indented\") {\n      return [];\n    }\n    return helpers.createNode(\n      \"codeBlock\",\n      { language: token.lang || null },\n      token.text ? [helpers.createTextNode(token.text)] : []\n    );\n  },\n  renderMarkdown: (node, h) => {\n    var _a;\n    let output = \"\";\n    const language = ((_a = node.attrs) == null ? void 0 : _a.language) || \"\";\n    if (!node.content) {\n      output = `\\`\\`\\`${language}\n\n\\`\\`\\``;\n    } else {\n      const lines = [`\\`\\`\\`${language}`, h.renderChildren(node.content), \"```\"];\n      output = lines.join(\"\\n\");\n    }\n    return output;\n  },\n  addCommands() {\n    return {\n      setCodeBlock: (attributes) => ({ commands }) => {\n        return commands.setNode(this.name, attributes);\n      },\n      toggleCodeBlock: (attributes) => ({ commands }) => {\n        return commands.toggleNode(this.name, \"paragraph\", attributes);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Alt-c\": () => this.editor.commands.toggleCodeBlock(),\n      // remove code block when at start of document or code block is empty\n      Backspace: () => {\n        const { empty, $anchor } = this.editor.state.selection;\n        const isAtStart = $anchor.pos === 1;\n        if (!empty || $anchor.parent.type.name !== this.name) {\n          return false;\n        }\n        if (isAtStart || !$anchor.parent.textContent.length) {\n          return this.editor.commands.clearNodes();\n        }\n        return false;\n      },\n      // handle tab indentation\n      Tab: ({ editor }) => {\n        var _a;\n        if (!this.options.enableTabIndentation) {\n          return false;\n        }\n        const tabSize = (_a = this.options.tabSize) != null ? _a : DEFAULT_TAB_SIZE;\n        const { state } = editor;\n        const { selection } = state;\n        const { $from, empty } = selection;\n        if ($from.parent.type !== this.type) {\n          return false;\n        }\n        const indent = \" \".repeat(tabSize);\n        if (empty) {\n          return editor.commands.insertContent(indent);\n        }\n        return editor.commands.command(({ tr }) => {\n          const { from, to } = selection;\n          const text = state.doc.textBetween(from, to, \"\\n\", \"\\n\");\n          const lines = text.split(\"\\n\");\n          const indentedText = lines.map((line) => indent + line).join(\"\\n\");\n          tr.replaceWith(from, to, state.schema.text(indentedText));\n          return true;\n        });\n      },\n      // handle shift+tab reverse indentation\n      \"Shift-Tab\": ({ editor }) => {\n        var _a;\n        if (!this.options.enableTabIndentation) {\n          return false;\n        }\n        const tabSize = (_a = this.options.tabSize) != null ? _a : DEFAULT_TAB_SIZE;\n        const { state } = editor;\n        const { selection } = state;\n        const { $from, empty } = selection;\n        if ($from.parent.type !== this.type) {\n          return false;\n        }\n        if (empty) {\n          return editor.commands.command(({ tr }) => {\n            var _a2;\n            const { pos } = $from;\n            const codeBlockStart = $from.start();\n            const codeBlockEnd = $from.end();\n            const allText = state.doc.textBetween(codeBlockStart, codeBlockEnd, \"\\n\", \"\\n\");\n            const lines = allText.split(\"\\n\");\n            let currentLineIndex = 0;\n            let charCount = 0;\n            const relativeCursorPos = pos - codeBlockStart;\n            for (let i = 0; i < lines.length; i += 1) {\n              if (charCount + lines[i].length >= relativeCursorPos) {\n                currentLineIndex = i;\n                break;\n              }\n              charCount += lines[i].length + 1;\n            }\n            const currentLine = lines[currentLineIndex];\n            const leadingSpaces = ((_a2 = currentLine.match(/^ */)) == null ? void 0 : _a2[0]) || \"\";\n            const spacesToRemove = Math.min(leadingSpaces.length, tabSize);\n            if (spacesToRemove === 0) {\n              return true;\n            }\n            let lineStartPos = codeBlockStart;\n            for (let i = 0; i < currentLineIndex; i += 1) {\n              lineStartPos += lines[i].length + 1;\n            }\n            tr.delete(lineStartPos, lineStartPos + spacesToRemove);\n            const cursorPosInLine = pos - lineStartPos;\n            if (cursorPosInLine <= spacesToRemove) {\n              tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, lineStartPos));\n            }\n            return true;\n          });\n        }\n        return editor.commands.command(({ tr }) => {\n          const { from, to } = selection;\n          const text = state.doc.textBetween(from, to, \"\\n\", \"\\n\");\n          const lines = text.split(\"\\n\");\n          const reverseIndentText = lines.map((line) => {\n            var _a2;\n            const leadingSpaces = ((_a2 = line.match(/^ */)) == null ? void 0 : _a2[0]) || \"\";\n            const spacesToRemove = Math.min(leadingSpaces.length, tabSize);\n            return line.slice(spacesToRemove);\n          }).join(\"\\n\");\n          tr.replaceWith(from, to, state.schema.text(reverseIndentText));\n          return true;\n        });\n      },\n      // exit node on triple enter\n      Enter: ({ editor }) => {\n        if (!this.options.exitOnTripleEnter) {\n          return false;\n        }\n        const { state } = editor;\n        const { selection } = state;\n        const { $from, empty } = selection;\n        if (!empty || $from.parent.type !== this.type) {\n          return false;\n        }\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n        const endsWithDoubleNewline = $from.parent.textContent.endsWith(\"\\n\\n\");\n        if (!isAtEnd || !endsWithDoubleNewline) {\n          return false;\n        }\n        return editor.chain().command(({ tr }) => {\n          tr.delete($from.pos - 2, $from.pos);\n          return true;\n        }).exitCode().run();\n      },\n      // exit node on arrow down\n      ArrowDown: ({ editor }) => {\n        if (!this.options.exitOnArrowDown) {\n          return false;\n        }\n        const { state } = editor;\n        const { selection, doc } = state;\n        const { $from, empty } = selection;\n        if (!empty || $from.parent.type !== this.type) {\n          return false;\n        }\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n        if (!isAtEnd) {\n          return false;\n        }\n        const after = $from.after();\n        if (after === void 0) {\n          return false;\n        }\n        const nodeAfter = doc.nodeAt(after);\n        if (nodeAfter) {\n          return editor.commands.command(({ tr }) => {\n            tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(doc.resolve(after)));\n            return true;\n          });\n        }\n        return editor.commands.exitCode();\n      }\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.textblockTypeInputRule)({\n        find: backtickInputRegex,\n        type: this.type,\n        getAttributes: (match) => ({\n          language: match[1]\n        })\n      }),\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.textblockTypeInputRule)({\n        find: tildeInputRegex,\n        type: this.type,\n        getAttributes: (match) => ({\n          language: match[1]\n        })\n      })\n    ];\n  },\n  addProseMirrorPlugins() {\n    return [\n      // this plugin creates a code block for pasted content from VS Code\n      // we can also detect the copied code language\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"codeBlockVSCodeHandler\"),\n        props: {\n          handlePaste: (view, event) => {\n            if (!event.clipboardData) {\n              return false;\n            }\n            if (this.editor.isActive(this.type.name)) {\n              return false;\n            }\n            const text = event.clipboardData.getData(\"text/plain\");\n            const vscode = event.clipboardData.getData(\"vscode-editor-data\");\n            const vscodeData = vscode ? JSON.parse(vscode) : void 0;\n            const language = vscodeData == null ? void 0 : vscodeData.mode;\n            if (!text || !language) {\n              return false;\n            }\n            const { tr, schema } = view.state;\n            const textNode = schema.text(text.replace(/\\r\\n?/g, \"\\n\"));\n            tr.replaceSelectionWith(this.type.create({ language }, textNode));\n            if (tr.selection.$from.parent.type !== this.type) {\n              tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));\n            }\n            tr.setMeta(\"paste\", true);\n            view.dispatch(tr);\n            return true;\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/index.ts\nvar index_default = CodeBlock;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29kZS1ibG9jay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQzZFO0FBQ0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhDQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQSxNQUFNLDZEQUFlO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4QkFBOEI7QUFDdEM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBLE1BQU07QUFDTiw4QkFBOEIsU0FBUztBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHVDQUF1QyxVQUFVO0FBQ2pEO0FBQ0EsT0FBTztBQUNQLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsWUFBWTtBQUM1QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxJQUFJO0FBQzlDLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixZQUFZO0FBQzVCLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLElBQUk7QUFDaEQ7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkRBQWE7QUFDM0M7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLDBDQUEwQyxJQUFJO0FBQzlDLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFlBQVk7QUFDNUIsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxJQUFJO0FBQzdDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLGlCQUFpQjtBQUNqQyxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxJQUFJO0FBQ2hELDRCQUE0Qix1REFBUztBQUNyQztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTSxvRUFBc0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLE1BQU0sb0VBQXNCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0RBQU07QUFDaEIsaUJBQWlCLHVEQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0EsdURBQXVELFVBQVU7QUFDakU7QUFDQSw4QkFBOEIsMkRBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFNRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvbW9ydG9ubWFidW1iby9Eb3dubG9hZHMvdGVzdGltaW5vbnktd2ViMV8xMC1tYWluL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1jb2RlLWJsb2NrL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2NvZGUtYmxvY2sudHNcbmltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSwgdGV4dGJsb2NrVHlwZUlucHV0UnVsZSB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5LCBTZWxlY3Rpb24sIFRleHRTZWxlY3Rpb24gfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xudmFyIERFRkFVTFRfVEFCX1NJWkUgPSA0O1xudmFyIGJhY2t0aWNrSW5wdXRSZWdleCA9IC9eYGBgKFthLXpdKyk/W1xcc1xcbl0kLztcbnZhciB0aWxkZUlucHV0UmVnZXggPSAvXn5+fihbYS16XSspP1tcXHNcXG5dJC87XG52YXIgQ29kZUJsb2NrID0gTm9kZS5jcmVhdGUoe1xuICBuYW1lOiBcImNvZGVCbG9ja1wiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsYW5ndWFnZUNsYXNzUHJlZml4OiBcImxhbmd1YWdlLVwiLFxuICAgICAgZXhpdE9uVHJpcGxlRW50ZXI6IHRydWUsXG4gICAgICBleGl0T25BcnJvd0Rvd246IHRydWUsXG4gICAgICBkZWZhdWx0TGFuZ3VhZ2U6IG51bGwsXG4gICAgICBlbmFibGVUYWJJbmRlbnRhdGlvbjogZmFsc2UsXG4gICAgICB0YWJTaXplOiBERUZBVUxUX1RBQl9TSVpFLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9XG4gICAgfTtcbiAgfSxcbiAgY29udGVudDogXCJ0ZXh0KlwiLFxuICBtYXJrczogXCJcIixcbiAgZ3JvdXA6IFwiYmxvY2tcIixcbiAgY29kZTogdHJ1ZSxcbiAgZGVmaW5pbmc6IHRydWUsXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhbmd1YWdlOiB7XG4gICAgICAgIGRlZmF1bHQ6IHRoaXMub3B0aW9ucy5kZWZhdWx0TGFuZ3VhZ2UsXG4gICAgICAgIHBhcnNlSFRNTDogKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgY29uc3QgeyBsYW5ndWFnZUNsYXNzUHJlZml4IH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgaWYgKCFsYW5ndWFnZUNsYXNzUHJlZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IFsuLi4oKF9hID0gZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNsYXNzTGlzdCkgfHwgW11dO1xuICAgICAgICAgIGNvbnN0IGxhbmd1YWdlcyA9IGNsYXNzTmFtZXMuZmlsdGVyKChjbGFzc05hbWUpID0+IGNsYXNzTmFtZS5zdGFydHNXaXRoKGxhbmd1YWdlQ2xhc3NQcmVmaXgpKS5tYXAoKGNsYXNzTmFtZSkgPT4gY2xhc3NOYW1lLnJlcGxhY2UobGFuZ3VhZ2VDbGFzc1ByZWZpeCwgXCJcIikpO1xuICAgICAgICAgIGNvbnN0IGxhbmd1YWdlID0gbGFuZ3VhZ2VzWzBdO1xuICAgICAgICAgIGlmICghbGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbGFuZ3VhZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbmRlcmVkOiBmYWxzZVxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6IFwicHJlXCIsXG4gICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZTogXCJmdWxsXCJcbiAgICAgIH1cbiAgICBdO1xuICB9LFxuICByZW5kZXJIVE1MKHsgbm9kZSwgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbXG4gICAgICBcInByZVwiLFxuICAgICAgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLFxuICAgICAgW1xuICAgICAgICBcImNvZGVcIixcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzOiBub2RlLmF0dHJzLmxhbmd1YWdlID8gdGhpcy5vcHRpb25zLmxhbmd1YWdlQ2xhc3NQcmVmaXggKyBub2RlLmF0dHJzLmxhbmd1YWdlIDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICAwXG4gICAgICBdXG4gICAgXTtcbiAgfSxcbiAgbWFya2Rvd25Ub2tlbk5hbWU6IFwiY29kZVwiLFxuICBwYXJzZU1hcmtkb3duOiAodG9rZW4sIGhlbHBlcnMpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCgoX2EgPSB0b2tlbi5yYXcpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zdGFydHNXaXRoKFwiYGBgXCIpKSA9PT0gZmFsc2UgJiYgdG9rZW4uY29kZUJsb2NrU3R5bGUgIT09IFwiaW5kZW50ZWRcIikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gaGVscGVycy5jcmVhdGVOb2RlKFxuICAgICAgXCJjb2RlQmxvY2tcIixcbiAgICAgIHsgbGFuZ3VhZ2U6IHRva2VuLmxhbmcgfHwgbnVsbCB9LFxuICAgICAgdG9rZW4udGV4dCA/IFtoZWxwZXJzLmNyZWF0ZVRleHROb2RlKHRva2VuLnRleHQpXSA6IFtdXG4gICAgKTtcbiAgfSxcbiAgcmVuZGVyTWFya2Rvd246IChub2RlLCBoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBvdXRwdXQgPSBcIlwiO1xuICAgIGNvbnN0IGxhbmd1YWdlID0gKChfYSA9IG5vZGUuYXR0cnMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5sYW5ndWFnZSkgfHwgXCJcIjtcbiAgICBpZiAoIW5vZGUuY29udGVudCkge1xuICAgICAgb3V0cHV0ID0gYFxcYFxcYFxcYCR7bGFuZ3VhZ2V9XG5cblxcYFxcYFxcYGA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxpbmVzID0gW2BcXGBcXGBcXGAke2xhbmd1YWdlfWAsIGgucmVuZGVyQ2hpbGRyZW4obm9kZS5jb250ZW50KSwgXCJgYGBcIl07XG4gICAgICBvdXRwdXQgPSBsaW5lcy5qb2luKFwiXFxuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0Q29kZUJsb2NrOiAoYXR0cmlidXRlcykgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0aGlzLm5hbWUsIGF0dHJpYnV0ZXMpO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZUNvZGVCbG9jazogKGF0dHJpYnV0ZXMpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU5vZGUodGhpcy5uYW1lLCBcInBhcmFncmFwaFwiLCBhdHRyaWJ1dGVzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJNb2QtQWx0LWNcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQ29kZUJsb2NrKCksXG4gICAgICAvLyByZW1vdmUgY29kZSBibG9jayB3aGVuIGF0IHN0YXJ0IG9mIGRvY3VtZW50IG9yIGNvZGUgYmxvY2sgaXMgZW1wdHlcbiAgICAgIEJhY2tzcGFjZTogKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGVtcHR5LCAkYW5jaG9yIH0gPSB0aGlzLmVkaXRvci5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGNvbnN0IGlzQXRTdGFydCA9ICRhbmNob3IucG9zID09PSAxO1xuICAgICAgICBpZiAoIWVtcHR5IHx8ICRhbmNob3IucGFyZW50LnR5cGUubmFtZSAhPT0gdGhpcy5uYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0F0U3RhcnQgfHwgISRhbmNob3IucGFyZW50LnRleHRDb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRvci5jb21tYW5kcy5jbGVhck5vZGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIC8vIGhhbmRsZSB0YWIgaW5kZW50YXRpb25cbiAgICAgIFRhYjogKHsgZWRpdG9yIH0pID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbmFibGVUYWJJbmRlbnRhdGlvbikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YWJTaXplID0gKF9hID0gdGhpcy5vcHRpb25zLnRhYlNpemUpICE9IG51bGwgPyBfYSA6IERFRkFVTFRfVEFCX1NJWkU7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IGVkaXRvcjtcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlO1xuICAgICAgICBjb25zdCB7ICRmcm9tLCBlbXB0eSB9ID0gc2VsZWN0aW9uO1xuICAgICAgICBpZiAoJGZyb20ucGFyZW50LnR5cGUgIT09IHRoaXMudHlwZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRlbnQgPSBcIiBcIi5yZXBlYXQodGFiU2l6ZSk7XG4gICAgICAgIGlmIChlbXB0eSkge1xuICAgICAgICAgIHJldHVybiBlZGl0b3IuY29tbWFuZHMuaW5zZXJ0Q29udGVudChpbmRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlZGl0b3IuY29tbWFuZHMuY29tbWFuZCgoeyB0ciB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBmcm9tLCB0byB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgIGNvbnN0IHRleHQgPSBzdGF0ZS5kb2MudGV4dEJldHdlZW4oZnJvbSwgdG8sIFwiXFxuXCIsIFwiXFxuXCIpO1xuICAgICAgICAgIGNvbnN0IGxpbmVzID0gdGV4dC5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICBjb25zdCBpbmRlbnRlZFRleHQgPSBsaW5lcy5tYXAoKGxpbmUpID0+IGluZGVudCArIGxpbmUpLmpvaW4oXCJcXG5cIik7XG4gICAgICAgICAgdHIucmVwbGFjZVdpdGgoZnJvbSwgdG8sIHN0YXRlLnNjaGVtYS50ZXh0KGluZGVudGVkVGV4dCkpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICAvLyBoYW5kbGUgc2hpZnQrdGFiIHJldmVyc2UgaW5kZW50YXRpb25cbiAgICAgIFwiU2hpZnQtVGFiXCI6ICh7IGVkaXRvciB9KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZW5hYmxlVGFiSW5kZW50YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFiU2l6ZSA9IChfYSA9IHRoaXMub3B0aW9ucy50YWJTaXplKSAhPSBudWxsID8gX2EgOiBERUZBVUxUX1RBQl9TSVpFO1xuICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSBlZGl0b3I7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgeyAkZnJvbSwgZW1wdHkgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgaWYgKCRmcm9tLnBhcmVudC50eXBlICE9PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVtcHR5KSB7XG4gICAgICAgICAgcmV0dXJuIGVkaXRvci5jb21tYW5kcy5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgICAgICAgIHZhciBfYTI7XG4gICAgICAgICAgICBjb25zdCB7IHBvcyB9ID0gJGZyb207XG4gICAgICAgICAgICBjb25zdCBjb2RlQmxvY2tTdGFydCA9ICRmcm9tLnN0YXJ0KCk7XG4gICAgICAgICAgICBjb25zdCBjb2RlQmxvY2tFbmQgPSAkZnJvbS5lbmQoKTtcbiAgICAgICAgICAgIGNvbnN0IGFsbFRleHQgPSBzdGF0ZS5kb2MudGV4dEJldHdlZW4oY29kZUJsb2NrU3RhcnQsIGNvZGVCbG9ja0VuZCwgXCJcXG5cIiwgXCJcXG5cIik7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IGFsbFRleHQuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICBsZXQgY3VycmVudExpbmVJbmRleCA9IDA7XG4gICAgICAgICAgICBsZXQgY2hhckNvdW50ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlQ3Vyc29yUG9zID0gcG9zIC0gY29kZUJsb2NrU3RhcnQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgIGlmIChjaGFyQ291bnQgKyBsaW5lc1tpXS5sZW5ndGggPj0gcmVsYXRpdmVDdXJzb3JQb3MpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGluZUluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjaGFyQ291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMaW5lID0gbGluZXNbY3VycmVudExpbmVJbmRleF07XG4gICAgICAgICAgICBjb25zdCBsZWFkaW5nU3BhY2VzID0gKChfYTIgPSBjdXJyZW50TGluZS5tYXRjaCgvXiAqLykpID09IG51bGwgPyB2b2lkIDAgOiBfYTJbMF0pIHx8IFwiXCI7XG4gICAgICAgICAgICBjb25zdCBzcGFjZXNUb1JlbW92ZSA9IE1hdGgubWluKGxlYWRpbmdTcGFjZXMubGVuZ3RoLCB0YWJTaXplKTtcbiAgICAgICAgICAgIGlmIChzcGFjZXNUb1JlbW92ZSA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsaW5lU3RhcnRQb3MgPSBjb2RlQmxvY2tTdGFydDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudExpbmVJbmRleDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgIGxpbmVTdGFydFBvcyArPSBsaW5lc1tpXS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHIuZGVsZXRlKGxpbmVTdGFydFBvcywgbGluZVN0YXJ0UG9zICsgc3BhY2VzVG9SZW1vdmUpO1xuICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9zSW5MaW5lID0gcG9zIC0gbGluZVN0YXJ0UG9zO1xuICAgICAgICAgICAgaWYgKGN1cnNvclBvc0luTGluZSA8PSBzcGFjZXNUb1JlbW92ZSkge1xuICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBsaW5lU3RhcnRQb3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlZGl0b3IuY29tbWFuZHMuY29tbWFuZCgoeyB0ciB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBmcm9tLCB0byB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgIGNvbnN0IHRleHQgPSBzdGF0ZS5kb2MudGV4dEJldHdlZW4oZnJvbSwgdG8sIFwiXFxuXCIsIFwiXFxuXCIpO1xuICAgICAgICAgIGNvbnN0IGxpbmVzID0gdGV4dC5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICBjb25zdCByZXZlcnNlSW5kZW50VGV4dCA9IGxpbmVzLm1hcCgobGluZSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICAgIGNvbnN0IGxlYWRpbmdTcGFjZXMgPSAoKF9hMiA9IGxpbmUubWF0Y2goL14gKi8pKSA9PSBudWxsID8gdm9pZCAwIDogX2EyWzBdKSB8fCBcIlwiO1xuICAgICAgICAgICAgY29uc3Qgc3BhY2VzVG9SZW1vdmUgPSBNYXRoLm1pbihsZWFkaW5nU3BhY2VzLmxlbmd0aCwgdGFiU2l6ZSk7XG4gICAgICAgICAgICByZXR1cm4gbGluZS5zbGljZShzcGFjZXNUb1JlbW92ZSk7XG4gICAgICAgICAgfSkuam9pbihcIlxcblwiKTtcbiAgICAgICAgICB0ci5yZXBsYWNlV2l0aChmcm9tLCB0bywgc3RhdGUuc2NoZW1hLnRleHQocmV2ZXJzZUluZGVudFRleHQpKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgLy8gZXhpdCBub2RlIG9uIHRyaXBsZSBlbnRlclxuICAgICAgRW50ZXI6ICh7IGVkaXRvciB9KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmV4aXRPblRyaXBsZUVudGVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IGVkaXRvcjtcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlO1xuICAgICAgICBjb25zdCB7ICRmcm9tLCBlbXB0eSB9ID0gc2VsZWN0aW9uO1xuICAgICAgICBpZiAoIWVtcHR5IHx8ICRmcm9tLnBhcmVudC50eXBlICE9PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNBdEVuZCA9ICRmcm9tLnBhcmVudE9mZnNldCA9PT0gJGZyb20ucGFyZW50Lm5vZGVTaXplIC0gMjtcbiAgICAgICAgY29uc3QgZW5kc1dpdGhEb3VibGVOZXdsaW5lID0gJGZyb20ucGFyZW50LnRleHRDb250ZW50LmVuZHNXaXRoKFwiXFxuXFxuXCIpO1xuICAgICAgICBpZiAoIWlzQXRFbmQgfHwgIWVuZHNXaXRoRG91YmxlTmV3bGluZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWRpdG9yLmNoYWluKCkuY29tbWFuZCgoeyB0ciB9KSA9PiB7XG4gICAgICAgICAgdHIuZGVsZXRlKCRmcm9tLnBvcyAtIDIsICRmcm9tLnBvcyk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pLmV4aXRDb2RlKCkucnVuKCk7XG4gICAgICB9LFxuICAgICAgLy8gZXhpdCBub2RlIG9uIGFycm93IGRvd25cbiAgICAgIEFycm93RG93bjogKHsgZWRpdG9yIH0pID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZXhpdE9uQXJyb3dEb3duKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IGVkaXRvcjtcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24sIGRvYyB9ID0gc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgJGZyb20sIGVtcHR5IH0gPSBzZWxlY3Rpb247XG4gICAgICAgIGlmICghZW1wdHkgfHwgJGZyb20ucGFyZW50LnR5cGUgIT09IHRoaXMudHlwZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0F0RW5kID0gJGZyb20ucGFyZW50T2Zmc2V0ID09PSAkZnJvbS5wYXJlbnQubm9kZVNpemUgLSAyO1xuICAgICAgICBpZiAoIWlzQXRFbmQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWZ0ZXIgPSAkZnJvbS5hZnRlcigpO1xuICAgICAgICBpZiAoYWZ0ZXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlQWZ0ZXIgPSBkb2Mubm9kZUF0KGFmdGVyKTtcbiAgICAgICAgaWYgKG5vZGVBZnRlcikge1xuICAgICAgICAgIHJldHVybiBlZGl0b3IuY29tbWFuZHMuY29tbWFuZCgoeyB0ciB9KSA9PiB7XG4gICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIoZG9jLnJlc29sdmUoYWZ0ZXIpKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWRpdG9yLmNvbW1hbmRzLmV4aXRDb2RlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgdGV4dGJsb2NrVHlwZUlucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IGJhY2t0aWNrSW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBnZXRBdHRyaWJ1dGVzOiAobWF0Y2gpID0+ICh7XG4gICAgICAgICAgbGFuZ3VhZ2U6IG1hdGNoWzFdXG4gICAgICAgIH0pXG4gICAgICB9KSxcbiAgICAgIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiB0aWxkZUlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgZ2V0QXR0cmlidXRlczogKG1hdGNoKSA9PiAoe1xuICAgICAgICAgIGxhbmd1YWdlOiBtYXRjaFsxXVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICBdO1xuICB9LFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC8vIHRoaXMgcGx1Z2luIGNyZWF0ZXMgYSBjb2RlIGJsb2NrIGZvciBwYXN0ZWQgY29udGVudCBmcm9tIFZTIENvZGVcbiAgICAgIC8vIHdlIGNhbiBhbHNvIGRldGVjdCB0aGUgY29waWVkIGNvZGUgbGFuZ3VhZ2VcbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoXCJjb2RlQmxvY2tWU0NvZGVIYW5kbGVyXCIpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGhhbmRsZVBhc3RlOiAodmlldywgZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICghZXZlbnQuY2xpcGJvYXJkRGF0YSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5lZGl0b3IuaXNBY3RpdmUodGhpcy50eXBlLm5hbWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBldmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpO1xuICAgICAgICAgICAgY29uc3QgdnNjb2RlID0gZXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwidnNjb2RlLWVkaXRvci1kYXRhXCIpO1xuICAgICAgICAgICAgY29uc3QgdnNjb2RlRGF0YSA9IHZzY29kZSA/IEpTT04ucGFyc2UodnNjb2RlKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIGNvbnN0IGxhbmd1YWdlID0gdnNjb2RlRGF0YSA9PSBudWxsID8gdm9pZCAwIDogdnNjb2RlRGF0YS5tb2RlO1xuICAgICAgICAgICAgaWYgKCF0ZXh0IHx8ICFsYW5ndWFnZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHRyLCBzY2hlbWEgfSA9IHZpZXcuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9IHNjaGVtYS50ZXh0KHRleHQucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSk7XG4gICAgICAgICAgICB0ci5yZXBsYWNlU2VsZWN0aW9uV2l0aCh0aGlzLnR5cGUuY3JlYXRlKHsgbGFuZ3VhZ2UgfSwgdGV4dE5vZGUpKTtcbiAgICAgICAgICAgIGlmICh0ci5zZWxlY3Rpb24uJGZyb20ucGFyZW50LnR5cGUgIT09IHRoaXMudHlwZSkge1xuICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKE1hdGgubWF4KDAsIHRyLnNlbGVjdGlvbi5mcm9tIC0gMikpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ci5zZXRNZXRhKFwicGFzdGVcIiwgdHJ1ZSk7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IENvZGVCbG9jaztcbmV4cG9ydCB7XG4gIENvZGVCbG9jayxcbiAgYmFja3RpY2tJbnB1dFJlZ2V4LFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHQsXG4gIHRpbGRlSW5wdXRSZWdleFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-code-block/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-code/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-code/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Code: () => (/* binding */ Code),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/code.ts\n\nvar inputRegex = /(^|[^`])`([^`]+)`(?!`)$/;\nvar pasteRegex = /(^|[^`])`([^`]+)`(?!`)/g;\nvar Code = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n  name: \"code\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  excludes: \"_\",\n  code: true,\n  exitable: true,\n  parseHTML() {\n    return [{ tag: \"code\" }];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"code\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  markdownTokenName: \"codespan\",\n  parseMarkdown: (token, helpers) => {\n    return helpers.applyMark(\"code\", [{ type: \"text\", text: token.text || \"\" }]);\n  },\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return \"\";\n    }\n    return `\\`${h.renderChildren(node.content)}\\``;\n  },\n  addCommands() {\n    return {\n      setCode: () => ({ commands }) => {\n        return commands.setMark(this.name);\n      },\n      toggleCode: () => ({ commands }) => {\n        return commands.toggleMark(this.name);\n      },\n      unsetCode: () => ({ commands }) => {\n        return commands.unsetMark(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-e\": () => this.editor.commands.toggleCode()\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n        find: inputRegex,\n        type: this.type\n      })\n    ];\n  },\n  addPasteRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n        find: pasteRegex,\n        type: this.type\n      })\n    ];\n  }\n});\n\n// src/index.ts\nvar index_default = Code;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29kZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDbUY7QUFDbkY7QUFDQTtBQUNBLFdBQVcsOENBQUk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCLEdBQUc7QUFDSCxlQUFlLGdCQUFnQjtBQUMvQixvQkFBb0IsNkRBQWU7QUFDbkMsR0FBRztBQUNIO0FBQ0E7QUFDQSx3Q0FBd0Msc0NBQXNDO0FBQzlFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsR0FBRztBQUNIO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBLE9BQU87QUFDUCwyQkFBMkIsVUFBVTtBQUNyQztBQUNBLE9BQU87QUFDUCwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU0sMkRBQWE7QUFDbkI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTSwyREFBYTtBQUNuQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFNRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvbW9ydG9ubWFidW1iby9Eb3dubG9hZHMvdGVzdGltaW5vbnktd2ViMV8xMC1tYWluL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1jb2RlL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2NvZGUudHNcbmltcG9ydCB7IE1hcmssIG1hcmtJbnB1dFJ1bGUsIG1hcmtQYXN0ZVJ1bGUsIG1lcmdlQXR0cmlidXRlcyB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBpbnB1dFJlZ2V4ID0gLyhefFteYF0pYChbXmBdKylgKD8hYCkkLztcbnZhciBwYXN0ZVJlZ2V4ID0gLyhefFteYF0pYChbXmBdKylgKD8hYCkvZztcbnZhciBDb2RlID0gTWFyay5jcmVhdGUoe1xuICBuYW1lOiBcImNvZGVcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9XG4gICAgfTtcbiAgfSxcbiAgZXhjbHVkZXM6IFwiX1wiLFxuICBjb2RlOiB0cnVlLFxuICBleGl0YWJsZTogdHJ1ZSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbeyB0YWc6IFwiY29kZVwiIH1dO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbXCJjb2RlXCIsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gIH0sXG4gIG1hcmtkb3duVG9rZW5OYW1lOiBcImNvZGVzcGFuXCIsXG4gIHBhcnNlTWFya2Rvd246ICh0b2tlbiwgaGVscGVycykgPT4ge1xuICAgIHJldHVybiBoZWxwZXJzLmFwcGx5TWFyayhcImNvZGVcIiwgW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IHRva2VuLnRleHQgfHwgXCJcIiB9XSk7XG4gIH0sXG4gIHJlbmRlck1hcmtkb3duOiAobm9kZSwgaCkgPT4ge1xuICAgIGlmICghbm9kZS5jb250ZW50KSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGBcXGAke2gucmVuZGVyQ2hpbGRyZW4obm9kZS5jb250ZW50KX1cXGBgO1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0Q29kZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZUNvZGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKTtcbiAgICAgIH0sXG4gICAgICB1bnNldENvZGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcIk1vZC1lXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUNvZGUoKVxuICAgIH07XG4gIH0sXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICAgIH0pXG4gICAgXTtcbiAgfSxcbiAgYWRkUGFzdGVSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgIGZpbmQ6IHBhc3RlUmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IENvZGU7XG5leHBvcnQge1xuICBDb2RlLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHQsXG4gIGlucHV0UmVnZXgsXG4gIHBhc3RlUmVnZXhcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-code/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-document/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tiptap/extension-document/dist/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Document: () => (/* binding */ Document),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/document.ts\n\nvar Document = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"doc\",\n  topNode: true,\n  content: \"block+\",\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return \"\";\n    }\n    return h.renderChildren(node.content, \"\\n\\n\");\n  }\n});\n\n// src/index.ts\nvar index_default = Document;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZG9jdW1lbnQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNvQztBQUNwQyxlQUFlLDhDQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tb3J0b25tYWJ1bWJvL0Rvd25sb2Fkcy90ZXN0aW1pbm9ueS13ZWIxXzEwLW1haW4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWRvY3VtZW50L2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2RvY3VtZW50LnRzXG5pbXBvcnQgeyBOb2RlIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xudmFyIERvY3VtZW50ID0gTm9kZS5jcmVhdGUoe1xuICBuYW1lOiBcImRvY1wiLFxuICB0b3BOb2RlOiB0cnVlLFxuICBjb250ZW50OiBcImJsb2NrK1wiLFxuICByZW5kZXJNYXJrZG93bjogKG5vZGUsIGgpID0+IHtcbiAgICBpZiAoIW5vZGUuY29udGVudCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBoLnJlbmRlckNoaWxkcmVuKG5vZGUuY29udGVudCwgXCJcXG5cXG5cIik7XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gRG9jdW1lbnQ7XG5leHBvcnQge1xuICBEb2N1bWVudCxcbiAgaW5kZXhfZGVmYXVsdCBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-document/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-hard-break/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-hard-break/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HardBreak: () => (/* binding */ HardBreak),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/hard-break.ts\n\nvar HardBreak = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"hardBreak\",\n  addOptions() {\n    return {\n      keepMarks: true,\n      HTMLAttributes: {}\n    };\n  },\n  inline: true,\n  group: \"inline\",\n  selectable: false,\n  linebreakReplacement: true,\n  parseHTML() {\n    return [{ tag: \"br\" }];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"br\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)];\n  },\n  renderText() {\n    return \"\\n\";\n  },\n  renderMarkdown: (_node, h) => h.indent(`\n`),\n  addCommands() {\n    return {\n      setHardBreak: () => ({ commands, chain, state, editor }) => {\n        return commands.first([\n          () => commands.exitCode(),\n          () => commands.command(() => {\n            const { selection, storedMarks } = state;\n            if (selection.$from.parent.type.spec.isolating) {\n              return false;\n            }\n            const { keepMarks } = this.options;\n            const { splittableMarks } = editor.extensionManager;\n            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n            return chain().insertContent({ type: this.name }).command(({ tr, dispatch }) => {\n              if (dispatch && marks && keepMarks) {\n                const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));\n                tr.ensureMarks(filteredMarks);\n              }\n              return true;\n            }).run();\n          })\n        ]);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Enter\": () => this.editor.commands.setHardBreak(),\n      \"Shift-Enter\": () => this.editor.commands.setHardBreak()\n    };\n  }\n});\n\n// src/index.ts\nvar index_default = HardBreak;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGFyZC1icmVhay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ3FEO0FBQ3JELGdCQUFnQiw4Q0FBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QixHQUFHO0FBQ0gsZUFBZSxnQkFBZ0I7QUFDL0Isa0JBQWtCLDZEQUFlO0FBQ2pDLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdDQUFnQztBQUM3RDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQSwyQ0FBMkMsaUJBQWlCLGFBQWEsY0FBYztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL21vcnRvbm1hYnVtYm8vRG93bmxvYWRzL3Rlc3RpbWlub255LXdlYjFfMTAtbWFpbi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGFyZC1icmVhay9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9oYXJkLWJyZWFrLnRzXG5pbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgSGFyZEJyZWFrID0gTm9kZS5jcmVhdGUoe1xuICBuYW1lOiBcImhhcmRCcmVha1wiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZWVwTWFya3M6IHRydWUsXG4gICAgICBIVE1MQXR0cmlidXRlczoge31cbiAgICB9O1xuICB9LFxuICBpbmxpbmU6IHRydWUsXG4gIGdyb3VwOiBcImlubGluZVwiLFxuICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgbGluZWJyZWFrUmVwbGFjZW1lbnQ6IHRydWUsXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW3sgdGFnOiBcImJyXCIgfV07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcImJyXCIsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKV07XG4gIH0sXG4gIHJlbmRlclRleHQoKSB7XG4gICAgcmV0dXJuIFwiXFxuXCI7XG4gIH0sXG4gIHJlbmRlck1hcmtkb3duOiAoX25vZGUsIGgpID0+IGguaW5kZW50KGBcbmApLFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0SGFyZEJyZWFrOiAoKSA9PiAoeyBjb21tYW5kcywgY2hhaW4sIHN0YXRlLCBlZGl0b3IgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuZmlyc3QoW1xuICAgICAgICAgICgpID0+IGNvbW1hbmRzLmV4aXRDb2RlKCksXG4gICAgICAgICAgKCkgPT4gY29tbWFuZHMuY29tbWFuZCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiwgc3RvcmVkTWFya3MgfSA9IHN0YXRlO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi4kZnJvbS5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZykge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGtlZXBNYXJrcyB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgeyBzcGxpdHRhYmxlTWFya3MgfSA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyO1xuICAgICAgICAgICAgY29uc3QgbWFya3MgPSBzdG9yZWRNYXJrcyB8fCBzZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzZWxlY3Rpb24uJGZyb20ubWFya3MoKTtcbiAgICAgICAgICAgIHJldHVybiBjaGFpbigpLmluc2VydENvbnRlbnQoeyB0eXBlOiB0aGlzLm5hbWUgfSkuY29tbWFuZCgoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoZGlzcGF0Y2ggJiYgbWFya3MgJiYga2VlcE1hcmtzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzLmZpbHRlcigobWFyaykgPT4gc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSk7XG4gICAgICAgICAgICAgICAgdHIuZW5zdXJlTWFya3MoZmlsdGVyZWRNYXJrcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KS5ydW4oKTtcbiAgICAgICAgICB9KVxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJNb2QtRW50ZXJcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0SGFyZEJyZWFrKCksXG4gICAgICBcIlNoaWZ0LUVudGVyXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNldEhhcmRCcmVhaygpXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGluZGV4X2RlZmF1bHQgPSBIYXJkQnJlYWs7XG5leHBvcnQge1xuICBIYXJkQnJlYWssXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-hard-break/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-heading/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@tiptap/extension-heading/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Heading: () => (/* binding */ Heading),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/heading.ts\n\nvar Heading = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"heading\",\n  addOptions() {\n    return {\n      levels: [1, 2, 3, 4, 5, 6],\n      HTMLAttributes: {}\n    };\n  },\n  content: \"inline*\",\n  group: \"block\",\n  defining: true,\n  addAttributes() {\n    return {\n      level: {\n        default: 1,\n        rendered: false\n      }\n    };\n  },\n  parseHTML() {\n    return this.options.levels.map((level) => ({\n      tag: `h${level}`,\n      attrs: { level }\n    }));\n  },\n  renderHTML({ node, HTMLAttributes }) {\n    const hasLevel = this.options.levels.includes(node.attrs.level);\n    const level = hasLevel ? node.attrs.level : this.options.levels[0];\n    return [`h${level}`, (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  parseMarkdown: (token, helpers) => {\n    return helpers.createNode(\"heading\", { level: token.depth || 1 }, helpers.parseInline(token.tokens || []));\n  },\n  renderMarkdown: (node, h) => {\n    var _a;\n    const level = ((_a = node.attrs) == null ? void 0 : _a.level) ? parseInt(node.attrs.level, 10) : 1;\n    const headingChars = \"#\".repeat(level);\n    if (!node.content) {\n      return \"\";\n    }\n    return `${headingChars} ${h.renderChildren(node.content)}`;\n  },\n  addCommands() {\n    return {\n      setHeading: (attributes) => ({ commands }) => {\n        if (!this.options.levels.includes(attributes.level)) {\n          return false;\n        }\n        return commands.setNode(this.name, attributes);\n      },\n      toggleHeading: (attributes) => ({ commands }) => {\n        if (!this.options.levels.includes(attributes.level)) {\n          return false;\n        }\n        return commands.toggleNode(this.name, \"paragraph\", attributes);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return this.options.levels.reduce(\n      (items, level) => ({\n        ...items,\n        ...{\n          [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })\n        }\n      }),\n      {}\n    );\n  },\n  addInputRules() {\n    return this.options.levels.map((level) => {\n      return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.textblockTypeInputRule)({\n        find: new RegExp(`^(#{${Math.min(...this.options.levels)},${level}})\\\\s$`),\n        type: this.type,\n        getAttributes: {\n          level\n        }\n      });\n    });\n  }\n});\n\n// src/index.ts\nvar index_default = Heading;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGVhZGluZy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQzZFO0FBQzdFLGNBQWMsOENBQUk7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZTtBQUNmLEtBQUs7QUFDTCxHQUFHO0FBQ0gsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBLGdCQUFnQixNQUFNLEdBQUcsNkRBQWU7QUFDeEMsR0FBRztBQUNIO0FBQ0EsMkNBQTJDLHlCQUF5QjtBQUNwRSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWMsRUFBRSwrQkFBK0I7QUFDN0QsR0FBRztBQUNIO0FBQ0E7QUFDQSxxQ0FBcUMsVUFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx3Q0FBd0MsVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNLCtDQUErQyxPQUFPO0FBQ2xGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsb0VBQXNCO0FBQ25DLDhCQUE4QixFQUFFLGlDQUFpQyxHQUFHLE9BQU87QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL21vcnRvbm1hYnVtYm8vRG93bmxvYWRzL3Rlc3RpbWlub255LXdlYjFfMTAtbWFpbi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGVhZGluZy9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9oZWFkaW5nLnRzXG5pbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUsIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgSGVhZGluZyA9IE5vZGUuY3JlYXRlKHtcbiAgbmFtZTogXCJoZWFkaW5nXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxldmVsczogWzEsIDIsIDMsIDQsIDUsIDZdLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9XG4gICAgfTtcbiAgfSxcbiAgY29udGVudDogXCJpbmxpbmUqXCIsXG4gIGdyb3VwOiBcImJsb2NrXCIsXG4gIGRlZmluaW5nOiB0cnVlLFxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZXZlbDoge1xuICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICByZW5kZXJlZDogZmFsc2VcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sZXZlbHMubWFwKChsZXZlbCkgPT4gKHtcbiAgICAgIHRhZzogYGgke2xldmVsfWAsXG4gICAgICBhdHRyczogeyBsZXZlbCB9XG4gICAgfSkpO1xuICB9LFxuICByZW5kZXJIVE1MKHsgbm9kZSwgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIGNvbnN0IGhhc0xldmVsID0gdGhpcy5vcHRpb25zLmxldmVscy5pbmNsdWRlcyhub2RlLmF0dHJzLmxldmVsKTtcbiAgICBjb25zdCBsZXZlbCA9IGhhc0xldmVsID8gbm9kZS5hdHRycy5sZXZlbCA6IHRoaXMub3B0aW9ucy5sZXZlbHNbMF07XG4gICAgcmV0dXJuIFtgaCR7bGV2ZWx9YCwgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgfSxcbiAgcGFyc2VNYXJrZG93bjogKHRva2VuLCBoZWxwZXJzKSA9PiB7XG4gICAgcmV0dXJuIGhlbHBlcnMuY3JlYXRlTm9kZShcImhlYWRpbmdcIiwgeyBsZXZlbDogdG9rZW4uZGVwdGggfHwgMSB9LCBoZWxwZXJzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucyB8fCBbXSkpO1xuICB9LFxuICByZW5kZXJNYXJrZG93bjogKG5vZGUsIGgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbGV2ZWwgPSAoKF9hID0gbm9kZS5hdHRycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmxldmVsKSA/IHBhcnNlSW50KG5vZGUuYXR0cnMubGV2ZWwsIDEwKSA6IDE7XG4gICAgY29uc3QgaGVhZGluZ0NoYXJzID0gXCIjXCIucmVwZWF0KGxldmVsKTtcbiAgICBpZiAoIW5vZGUuY29udGVudCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBgJHtoZWFkaW5nQ2hhcnN9ICR7aC5yZW5kZXJDaGlsZHJlbihub2RlLmNvbnRlbnQpfWA7XG4gIH0sXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRIZWFkaW5nOiAoYXR0cmlidXRlcykgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5sZXZlbHMuaW5jbHVkZXMoYXR0cmlidXRlcy5sZXZlbCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE5vZGUodGhpcy5uYW1lLCBhdHRyaWJ1dGVzKTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGVIZWFkaW5nOiAoYXR0cmlidXRlcykgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5sZXZlbHMuaW5jbHVkZXMoYXR0cmlidXRlcy5sZXZlbCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU5vZGUodGhpcy5uYW1lLCBcInBhcmFncmFwaFwiLCBhdHRyaWJ1dGVzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxldmVscy5yZWR1Y2UoXG4gICAgICAoaXRlbXMsIGxldmVsKSA9PiAoe1xuICAgICAgICAuLi5pdGVtcyxcbiAgICAgICAgLi4ue1xuICAgICAgICAgIFtgTW9kLUFsdC0ke2xldmVsfWBdOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVIZWFkaW5nKHsgbGV2ZWwgfSlcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICB7fVxuICAgICk7XG4gIH0sXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sZXZlbHMubWFwKChsZXZlbCkgPT4ge1xuICAgICAgcmV0dXJuIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBuZXcgUmVnRXhwKGBeKCN7JHtNYXRoLm1pbiguLi50aGlzLm9wdGlvbnMubGV2ZWxzKX0sJHtsZXZlbH19KVxcXFxzJGApLFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICBsZXZlbFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGluZGV4X2RlZmF1bHQgPSBIZWFkaW5nO1xuZXhwb3J0IHtcbiAgSGVhZGluZyxcbiAgaW5kZXhfZGVmYXVsdCBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-heading/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tiptap/extension-horizontal-rule/dist/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HorizontalRule: () => (/* binding */ HorizontalRule),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\");\n// src/horizontal-rule.ts\n\n\nvar HorizontalRule = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Node.create({\n  name: \"horizontalRule\",\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      nextNodeType: \"paragraph\"\n    };\n  },\n  group: \"block\",\n  parseHTML() {\n    return [{ tag: \"hr\" }];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"hr\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)];\n  },\n  markdownTokenName: \"hr\",\n  parseMarkdown: (token, helpers) => {\n    return helpers.createNode(\"horizontalRule\");\n  },\n  renderMarkdown: () => {\n    return \"---\";\n  },\n  addCommands() {\n    return {\n      setHorizontalRule: () => ({ chain, state }) => {\n        if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.canInsertNode)(state, state.schema.nodes[this.name])) {\n          return false;\n        }\n        const { selection } = state;\n        const { $to: $originTo } = selection;\n        const currentChain = chain();\n        if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isNodeSelection)(selection)) {\n          currentChain.insertContentAt($originTo.pos, {\n            type: this.name\n          });\n        } else {\n          currentChain.insertContent({ type: this.name });\n        }\n        return currentChain.command(({ state: chainState, tr, dispatch }) => {\n          if (dispatch) {\n            const { $to } = tr.selection;\n            const posAfter = $to.end();\n            if ($to.nodeAfter) {\n              if ($to.nodeAfter.isTextblock) {\n                tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, $to.pos + 1));\n              } else if ($to.nodeAfter.isBlock) {\n                tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(tr.doc, $to.pos));\n              } else {\n                tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, $to.pos));\n              }\n            } else {\n              const nodeType = chainState.schema.nodes[this.options.nextNodeType] || $to.parent.type.contentMatch.defaultType;\n              const node = nodeType == null ? void 0 : nodeType.create();\n              if (node) {\n                tr.insert(posAfter, node);\n                tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, posAfter + 1));\n              }\n            }\n            tr.scrollIntoView();\n          }\n          return true;\n        }).run();\n      }\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.nodeInputRule)({\n        find: /^(?:---|-|___\\s|\\*\\*\\*\\s)$/,\n        type: this.type\n      })\n    ];\n  }\n});\n\n// src/index.ts\nvar index_default = HorizontalRule;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taG9yaXpvbnRhbC1ydWxlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ29HO0FBQ3BDO0FBQ2hFLHFCQUFxQiw4Q0FBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCLEdBQUc7QUFDSCxlQUFlLGdCQUFnQjtBQUMvQixrQkFBa0IsNkRBQWU7QUFDakMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRCxhQUFhLDJEQUFhO0FBQzFCO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QixnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0EsWUFBWSw2REFBZTtBQUMzQjtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVix1Q0FBdUMsaUJBQWlCO0FBQ3hEO0FBQ0EsdUNBQXVDLGlDQUFpQztBQUN4RTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywyREFBYTtBQUM3QyxnQkFBZ0I7QUFDaEIsZ0NBQWdDLDJEQUFhO0FBQzdDLGdCQUFnQjtBQUNoQixnQ0FBZ0MsMkRBQWE7QUFDN0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkRBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLDJEQUFhO0FBQ25CO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tb3J0b25tYWJ1bWJvL0Rvd25sb2Fkcy90ZXN0aW1pbm9ueS13ZWIxXzEwLW1haW4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWhvcml6b250YWwtcnVsZS9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9ob3Jpem9udGFsLXJ1bGUudHNcbmltcG9ydCB7IGNhbkluc2VydE5vZGUsIGlzTm9kZVNlbGVjdGlvbiwgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlLCBub2RlSW5wdXRSdWxlIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG52YXIgSG9yaXpvbnRhbFJ1bGUgPSBOb2RlLmNyZWF0ZSh7XG4gIG5hbWU6IFwiaG9yaXpvbnRhbFJ1bGVcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgbmV4dE5vZGVUeXBlOiBcInBhcmFncmFwaFwiXG4gICAgfTtcbiAgfSxcbiAgZ3JvdXA6IFwiYmxvY2tcIixcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbeyB0YWc6IFwiaHJcIiB9XTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gW1wiaHJcIiwgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpXTtcbiAgfSxcbiAgbWFya2Rvd25Ub2tlbk5hbWU6IFwiaHJcIixcbiAgcGFyc2VNYXJrZG93bjogKHRva2VuLCBoZWxwZXJzKSA9PiB7XG4gICAgcmV0dXJuIGhlbHBlcnMuY3JlYXRlTm9kZShcImhvcml6b250YWxSdWxlXCIpO1xuICB9LFxuICByZW5kZXJNYXJrZG93bjogKCkgPT4ge1xuICAgIHJldHVybiBcIi0tLVwiO1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0SG9yaXpvbnRhbFJ1bGU6ICgpID0+ICh7IGNoYWluLCBzdGF0ZSB9KSA9PiB7XG4gICAgICAgIGlmICghY2FuSW5zZXJ0Tm9kZShzdGF0ZSwgc3RhdGUuc2NoZW1hLm5vZGVzW3RoaXMubmFtZV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgeyAkdG86ICRvcmlnaW5UbyB9ID0gc2VsZWN0aW9uO1xuICAgICAgICBjb25zdCBjdXJyZW50Q2hhaW4gPSBjaGFpbigpO1xuICAgICAgICBpZiAoaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICBjdXJyZW50Q2hhaW4uaW5zZXJ0Q29udGVudEF0KCRvcmlnaW5Uby5wb3MsIHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMubmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRDaGFpbi5pbnNlcnRDb250ZW50KHsgdHlwZTogdGhpcy5uYW1lIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50Q2hhaW4uY29tbWFuZCgoeyBzdGF0ZTogY2hhaW5TdGF0ZSwgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgJHRvIH0gPSB0ci5zZWxlY3Rpb247XG4gICAgICAgICAgICBjb25zdCBwb3NBZnRlciA9ICR0by5lbmQoKTtcbiAgICAgICAgICAgIGlmICgkdG8ubm9kZUFmdGVyKSB7XG4gICAgICAgICAgICAgIGlmICgkdG8ubm9kZUFmdGVyLmlzVGV4dGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgJHRvLnBvcyArIDEpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgkdG8ubm9kZUFmdGVyLmlzQmxvY2spIHtcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCAkdG8ucG9zKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgJHRvLnBvcykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBub2RlVHlwZSA9IGNoYWluU3RhdGUuc2NoZW1hLm5vZGVzW3RoaXMub3B0aW9ucy5uZXh0Tm9kZVR5cGVdIHx8ICR0by5wYXJlbnQudHlwZS5jb250ZW50TWF0Y2guZGVmYXVsdFR5cGU7XG4gICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2RlVHlwZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZVR5cGUuY3JlYXRlKCk7XG4gICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdHIuaW5zZXJ0KHBvc0FmdGVyLCBub2RlKTtcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBwb3NBZnRlciArIDEpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pLnJ1bigpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5vZGVJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiAvXig/Oi0tLXzigJQtfF9fX1xcc3xcXCpcXCpcXCpcXHMpJC8sXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IEhvcml6b250YWxSdWxlO1xuZXhwb3J0IHtcbiAgSG9yaXpvbnRhbFJ1bGUsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-italic/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@tiptap/extension-italic/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Italic: () => (/* binding */ Italic),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   starInputRegex: () => (/* binding */ starInputRegex),\n/* harmony export */   starPasteRegex: () => (/* binding */ starPasteRegex),\n/* harmony export */   underscoreInputRegex: () => (/* binding */ underscoreInputRegex),\n/* harmony export */   underscorePasteRegex: () => (/* binding */ underscorePasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/italic.ts\n\nvar starInputRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))$/;\nvar starPasteRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))/g;\nvar underscoreInputRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))$/;\nvar underscorePasteRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))/g;\nvar Italic = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n  name: \"italic\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"em\"\n      },\n      {\n        tag: \"i\",\n        getAttrs: (node) => node.style.fontStyle !== \"normal\" && null\n      },\n      {\n        style: \"font-style=normal\",\n        clearMark: (mark) => mark.type.name === this.name\n      },\n      {\n        style: \"font-style=italic\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"em\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      setItalic: () => ({ commands }) => {\n        return commands.setMark(this.name);\n      },\n      toggleItalic: () => ({ commands }) => {\n        return commands.toggleMark(this.name);\n      },\n      unsetItalic: () => ({ commands }) => {\n        return commands.unsetMark(this.name);\n      }\n    };\n  },\n  markdownTokenName: \"em\",\n  parseMarkdown: (token, helpers) => {\n    return helpers.applyMark(\"italic\", helpers.parseInline(token.tokens || []));\n  },\n  renderMarkdown: (node, h) => {\n    return `*${h.renderChildren(node)}*`;\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-i\": () => this.editor.commands.toggleItalic(),\n      \"Mod-I\": () => this.editor.commands.toggleItalic()\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n        find: starInputRegex,\n        type: this.type\n      }),\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n        find: underscoreInputRegex,\n        type: this.type\n      })\n    ];\n  },\n  addPasteRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n        find: starPasteRegex,\n        type: this.type\n      }),\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n        find: underscorePasteRegex,\n        type: this.type\n      })\n    ];\n  }\n});\n\n// src/index.ts\nvar index_default = Italic;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taXRhbGljL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ21GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4Q0FBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZUFBZSxnQkFBZ0I7QUFDL0Isa0JBQWtCLDZEQUFlO0FBQ2pDLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCLFVBQVU7QUFDdkM7QUFDQSxPQUFPO0FBQ1AsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLDJEQUFhO0FBQ25CO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTSwyREFBYTtBQUNuQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLDJEQUFhO0FBQ25CO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTSwyREFBYTtBQUNuQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFRRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvbW9ydG9ubWFidW1iby9Eb3dubG9hZHMvdGVzdGltaW5vbnktd2ViMV8xMC1tYWluL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1pdGFsaWMvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaXRhbGljLnRzXG5pbXBvcnQgeyBNYXJrLCBtYXJrSW5wdXRSdWxlLCBtYXJrUGFzdGVSdWxlLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgc3RhcklucHV0UmVnZXggPSAvKD86XnxcXHMpKFxcKig/IVxccytcXCopKCg/OlteKl0rKSlcXCooPyFcXHMrXFwqKSkkLztcbnZhciBzdGFyUGFzdGVSZWdleCA9IC8oPzpefFxccykoXFwqKD8hXFxzK1xcKikoKD86W14qXSspKVxcKig/IVxccytcXCopKS9nO1xudmFyIHVuZGVyc2NvcmVJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKShfKD8hXFxzK18pKCg/OlteX10rKSlfKD8hXFxzK18pKSQvO1xudmFyIHVuZGVyc2NvcmVQYXN0ZVJlZ2V4ID0gLyg/Ol58XFxzKShfKD8hXFxzK18pKCg/OlteX10rKSlfKD8hXFxzK18pKS9nO1xudmFyIEl0YWxpYyA9IE1hcmsuY3JlYXRlKHtcbiAgbmFtZTogXCJpdGFsaWNcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9XG4gICAgfTtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJlbVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0YWc6IFwiaVwiLFxuICAgICAgICBnZXRBdHRyczogKG5vZGUpID0+IG5vZGUuc3R5bGUuZm9udFN0eWxlICE9PSBcIm5vcm1hbFwiICYmIG51bGxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiBcImZvbnQtc3R5bGU9bm9ybWFsXCIsXG4gICAgICAgIGNsZWFyTWFyazogKG1hcmspID0+IG1hcmsudHlwZS5uYW1lID09PSB0aGlzLm5hbWVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiBcImZvbnQtc3R5bGU9aXRhbGljXCJcbiAgICAgIH1cbiAgICBdO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbXCJlbVwiLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0SXRhbGljOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlSXRhbGljOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9LFxuICAgICAgdW5zZXRJdGFsaWM6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIG1hcmtkb3duVG9rZW5OYW1lOiBcImVtXCIsXG4gIHBhcnNlTWFya2Rvd246ICh0b2tlbiwgaGVscGVycykgPT4ge1xuICAgIHJldHVybiBoZWxwZXJzLmFwcGx5TWFyayhcIml0YWxpY1wiLCBoZWxwZXJzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucyB8fCBbXSkpO1xuICB9LFxuICByZW5kZXJNYXJrZG93bjogKG5vZGUsIGgpID0+IHtcbiAgICByZXR1cm4gYCoke2gucmVuZGVyQ2hpbGRyZW4obm9kZSl9KmA7XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcIk1vZC1pXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUl0YWxpYygpLFxuICAgICAgXCJNb2QtSVwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVJdGFsaWMoKVxuICAgIH07XG4gIH0sXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBzdGFySW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KSxcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiB1bmRlcnNjb3JlSW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KVxuICAgIF07XG4gIH0sXG4gIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiBzdGFyUGFzdGVSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KSxcbiAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiB1bmRlcnNjb3JlUGFzdGVSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gSXRhbGljO1xuZXhwb3J0IHtcbiAgSXRhbGljLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHQsXG4gIHN0YXJJbnB1dFJlZ2V4LFxuICBzdGFyUGFzdGVSZWdleCxcbiAgdW5kZXJzY29yZUlucHV0UmVnZXgsXG4gIHVuZGVyc2NvcmVQYXN0ZVJlZ2V4XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-italic/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-link/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-link/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Link: () => (/* binding */ Link),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   isAllowedUri: () => (/* binding */ isAllowedUri),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var linkifyjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! linkifyjs */ \"(ssr)/./node_modules/linkifyjs/dist/linkify.mjs\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\");\n// src/link.ts\n\n\n\n// src/helpers/autolink.ts\n\n\n\n\n// src/helpers/whitespace.ts\nvar UNICODE_WHITESPACE_PATTERN = \"[\\0- \\xA0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]\";\nvar UNICODE_WHITESPACE_REGEX = new RegExp(UNICODE_WHITESPACE_PATTERN);\nvar UNICODE_WHITESPACE_REGEX_END = new RegExp(`${UNICODE_WHITESPACE_PATTERN}$`);\nvar UNICODE_WHITESPACE_REGEX_GLOBAL = new RegExp(UNICODE_WHITESPACE_PATTERN, \"g\");\n\n// src/helpers/autolink.ts\nfunction isValidLinkStructure(tokens) {\n  if (tokens.length === 1) {\n    return tokens[0].isLink;\n  }\n  if (tokens.length === 3 && tokens[1].isLink) {\n    return [\"()\", \"[]\"].includes(tokens[0].value + tokens[2].value);\n  }\n  return false;\n}\nfunction autolink(options) {\n  return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n    key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey(\"autolink\"),\n    appendTransaction: (transactions, oldState, newState) => {\n      const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);\n      const preventAutolink = transactions.some((transaction) => transaction.getMeta(\"preventAutolink\"));\n      if (!docChanges || preventAutolink) {\n        return;\n      }\n      const { tr } = newState;\n      const transform = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.combineTransactionSteps)(oldState.doc, [...transactions]);\n      const changes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getChangedRanges)(transform);\n      changes.forEach(({ newRange }) => {\n        const nodesInChangedRanges = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findChildrenInRange)(newState.doc, newRange, (node) => node.isTextblock);\n        let textBlock;\n        let textBeforeWhitespace;\n        if (nodesInChangedRanges.length > 1) {\n          textBlock = nodesInChangedRanges[0];\n          textBeforeWhitespace = newState.doc.textBetween(\n            textBlock.pos,\n            textBlock.pos + textBlock.node.nodeSize,\n            void 0,\n            \" \"\n          );\n        } else if (nodesInChangedRanges.length) {\n          const endText = newState.doc.textBetween(newRange.from, newRange.to, \" \", \" \");\n          if (!UNICODE_WHITESPACE_REGEX_END.test(endText)) {\n            return;\n          }\n          textBlock = nodesInChangedRanges[0];\n          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, void 0, \" \");\n        }\n        if (textBlock && textBeforeWhitespace) {\n          const wordsBeforeWhitespace = textBeforeWhitespace.split(UNICODE_WHITESPACE_REGEX).filter(Boolean);\n          if (wordsBeforeWhitespace.length <= 0) {\n            return false;\n          }\n          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];\n          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);\n          if (!lastWordBeforeSpace) {\n            return false;\n          }\n          const linksBeforeSpace = (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.tokenize)(lastWordBeforeSpace).map((t) => t.toObject(options.defaultProtocol));\n          if (!isValidLinkStructure(linksBeforeSpace)) {\n            return false;\n          }\n          linksBeforeSpace.filter((link) => link.isLink).map((link) => ({\n            ...link,\n            from: lastWordAndBlockOffset + link.start + 1,\n            to: lastWordAndBlockOffset + link.end + 1\n          })).filter((link) => {\n            if (!newState.schema.marks.code) {\n              return true;\n            }\n            return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);\n          }).filter((link) => options.validate(link.value)).filter((link) => options.shouldAutoLink(link.value)).forEach((link) => {\n            if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarksBetween)(link.from, link.to, newState.doc).some((item) => item.mark.type === options.type)) {\n              return;\n            }\n            tr.addMark(\n              link.from,\n              link.to,\n              options.type.create({\n                href: link.href\n              })\n            );\n          });\n        }\n      });\n      if (!tr.steps.length) {\n        return;\n      }\n      return tr;\n    }\n  });\n}\n\n// src/helpers/clickHandler.ts\n\n\nfunction clickHandler(options) {\n  return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n    key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey(\"handleClickLink\"),\n    props: {\n      handleClick: (view, pos, event) => {\n        var _a, _b;\n        if (event.button !== 0) {\n          return false;\n        }\n        if (!view.editable) {\n          return false;\n        }\n        let link = null;\n        if (event.target instanceof HTMLAnchorElement) {\n          link = event.target;\n        } else {\n          let a = event.target;\n          const els = [];\n          while (a.nodeName !== \"DIV\") {\n            els.push(a);\n            a = a.parentNode;\n          }\n          link = els.find((value) => value.nodeName === \"A\");\n        }\n        if (!link) {\n          return false;\n        }\n        const attrs = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getAttributes)(view.state, options.type.name);\n        const href = (_a = link == null ? void 0 : link.href) != null ? _a : attrs.href;\n        const target = (_b = link == null ? void 0 : link.target) != null ? _b : attrs.target;\n        if (options.enableClickSelection) {\n          options.editor.commands.extendMarkRange(options.type.name);\n        }\n        if (link && href) {\n          window.open(href, target);\n          return true;\n        }\n        return false;\n      }\n    }\n  });\n}\n\n// src/helpers/pasteHandler.ts\n\n\nfunction pasteHandler(options) {\n  return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n    key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey(\"handlePasteLink\"),\n    props: {\n      handlePaste: (view, _event, slice) => {\n        const { shouldAutoLink } = options;\n        const { state } = view;\n        const { selection } = state;\n        const { empty } = selection;\n        if (empty) {\n          return false;\n        }\n        let textContent = \"\";\n        slice.content.forEach((node) => {\n          textContent += node.textContent;\n        });\n        const link = (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.find)(textContent, { defaultProtocol: options.defaultProtocol }).find(\n          (item) => item.isLink && item.value === textContent\n        );\n        if (!textContent || !link || shouldAutoLink !== void 0 && !shouldAutoLink(link.href)) {\n          return false;\n        }\n        return options.editor.commands.setMark(options.type, {\n          href: link.href\n        });\n      }\n    }\n  });\n}\n\n// src/link.ts\nvar pasteRegex = /https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z]{2,}\\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi;\nfunction isAllowedUri(uri, protocols) {\n  const allowedProtocols = [\"http\", \"https\", \"ftp\", \"ftps\", \"mailto\", \"tel\", \"callto\", \"sms\", \"cid\", \"xmpp\"];\n  if (protocols) {\n    protocols.forEach((protocol) => {\n      const nextProtocol = typeof protocol === \"string\" ? protocol : protocol.scheme;\n      if (nextProtocol) {\n        allowedProtocols.push(nextProtocol);\n      }\n    });\n  }\n  return !uri || uri.replace(UNICODE_WHITESPACE_REGEX_GLOBAL, \"\").match(\n    new RegExp(\n      // eslint-disable-next-line no-useless-escape\n      `^(?:(?:${allowedProtocols.join(\"|\")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,\n      \"i\"\n    )\n  );\n}\nvar Link = _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Mark.create({\n  name: \"link\",\n  priority: 1e3,\n  keepOnSplit: false,\n  exitable: true,\n  onCreate() {\n    if (this.options.validate && !this.options.shouldAutoLink) {\n      this.options.shouldAutoLink = this.options.validate;\n      console.warn(\"The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.\");\n    }\n    this.options.protocols.forEach((protocol) => {\n      if (typeof protocol === \"string\") {\n        (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.registerCustomProtocol)(protocol);\n        return;\n      }\n      (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.registerCustomProtocol)(protocol.scheme, protocol.optionalSlashes);\n    });\n  },\n  onDestroy() {\n    (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.reset)();\n  },\n  inclusive() {\n    return this.options.autolink;\n  },\n  addOptions() {\n    return {\n      openOnClick: true,\n      enableClickSelection: false,\n      linkOnPaste: true,\n      autolink: true,\n      protocols: [],\n      defaultProtocol: \"http\",\n      HTMLAttributes: {\n        target: \"_blank\",\n        rel: \"noopener noreferrer nofollow\",\n        class: null\n      },\n      isAllowedUri: (url, ctx) => !!isAllowedUri(url, ctx.protocols),\n      validate: (url) => !!url,\n      shouldAutoLink: (url) => !!url\n    };\n  },\n  addAttributes() {\n    return {\n      href: {\n        default: null,\n        parseHTML(element) {\n          return element.getAttribute(\"href\");\n        }\n      },\n      target: {\n        default: this.options.HTMLAttributes.target\n      },\n      rel: {\n        default: this.options.HTMLAttributes.rel\n      },\n      class: {\n        default: this.options.HTMLAttributes.class\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"a[href]\",\n        getAttrs: (dom) => {\n          const href = dom.getAttribute(\"href\");\n          if (!href || !this.options.isAllowedUri(href, {\n            defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),\n            protocols: this.options.protocols,\n            defaultProtocol: this.options.defaultProtocol\n          })) {\n            return false;\n          }\n          return null;\n        }\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    if (!this.options.isAllowedUri(HTMLAttributes.href, {\n      defaultValidate: (href) => !!isAllowedUri(href, this.options.protocols),\n      protocols: this.options.protocols,\n      defaultProtocol: this.options.defaultProtocol\n    })) {\n      return [\"a\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeAttributes)(this.options.HTMLAttributes, { ...HTMLAttributes, href: \"\" }), 0];\n    }\n    return [\"a\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  markdownTokenName: \"link\",\n  parseMarkdown: (token, helpers) => {\n    return helpers.applyMark(\"link\", helpers.parseInline(token.tokens || []), {\n      href: token.href,\n      title: token.title || null\n    });\n  },\n  renderMarkdown: (node, h) => {\n    var _a;\n    const href = ((_a = node.attrs) == null ? void 0 : _a.href) || \"\";\n    const text = h.renderChildren(node);\n    return `[${text}](${href})`;\n  },\n  addCommands() {\n    return {\n      setLink: (attributes) => ({ chain }) => {\n        const { href } = attributes;\n        if (!this.options.isAllowedUri(href, {\n          defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),\n          protocols: this.options.protocols,\n          defaultProtocol: this.options.defaultProtocol\n        })) {\n          return false;\n        }\n        return chain().setMark(this.name, attributes).setMeta(\"preventAutolink\", true).run();\n      },\n      toggleLink: (attributes) => ({ chain }) => {\n        const { href } = attributes || {};\n        if (href && !this.options.isAllowedUri(href, {\n          defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),\n          protocols: this.options.protocols,\n          defaultProtocol: this.options.defaultProtocol\n        })) {\n          return false;\n        }\n        return chain().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta(\"preventAutolink\", true).run();\n      },\n      unsetLink: () => ({ chain }) => {\n        return chain().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta(\"preventAutolink\", true).run();\n      }\n    };\n  },\n  addPasteRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.markPasteRule)({\n        find: (text) => {\n          const foundLinks = [];\n          if (text) {\n            const { protocols, defaultProtocol } = this.options;\n            const links = (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.find)(text).filter(\n              (item) => item.isLink && this.options.isAllowedUri(item.value, {\n                defaultValidate: (href) => !!isAllowedUri(href, protocols),\n                protocols,\n                defaultProtocol\n              })\n            );\n            if (links.length) {\n              links.forEach((link) => {\n                if (!this.options.shouldAutoLink(link.value)) {\n                  return;\n                }\n                foundLinks.push({\n                  text: link.value,\n                  data: {\n                    href: link.href\n                  },\n                  index: link.start\n                });\n              });\n            }\n          }\n          return foundLinks;\n        },\n        type: this.type,\n        getAttributes: (match) => {\n          var _a;\n          return {\n            href: (_a = match.data) == null ? void 0 : _a.href\n          };\n        }\n      })\n    ];\n  },\n  addProseMirrorPlugins() {\n    const plugins = [];\n    const { protocols, defaultProtocol } = this.options;\n    if (this.options.autolink) {\n      plugins.push(\n        autolink({\n          type: this.type,\n          defaultProtocol: this.options.defaultProtocol,\n          validate: (url) => this.options.isAllowedUri(url, {\n            defaultValidate: (href) => !!isAllowedUri(href, protocols),\n            protocols,\n            defaultProtocol\n          }),\n          shouldAutoLink: this.options.shouldAutoLink\n        })\n      );\n    }\n    if (this.options.openOnClick === true) {\n      plugins.push(\n        clickHandler({\n          type: this.type,\n          editor: this.editor,\n          enableClickSelection: this.options.enableClickSelection\n        })\n      );\n    }\n    if (this.options.linkOnPaste) {\n      plugins.push(\n        pasteHandler({\n          editor: this.editor,\n          defaultProtocol: this.options.defaultProtocol,\n          type: this.type,\n          shouldAutoLink: this.options.shouldAutoLink\n        })\n      );\n    }\n    return plugins;\n  }\n});\n\n// src/index.ts\nvar index_default = Link;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGluay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNvRTtBQUNLOztBQUV6RTtBQUMrRztBQUMxRDtBQUNoQjs7QUFFckM7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDJCQUEyQjtBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvREFBTTtBQUNuQixhQUFhLHVEQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQix3QkFBd0IscUVBQXVCO0FBQy9DLHNCQUFzQiw4REFBZ0I7QUFDdEMseUJBQXlCLFVBQVU7QUFDbkMscUNBQXFDLGlFQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1EQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGdCQUFnQiw2REFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQzZDO0FBQ2lDO0FBQzlFO0FBQ0EsYUFBYSxvREFBTztBQUNwQixhQUFhLHVEQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQU1FO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tb3J0b25tYWJ1bWJvL0Rvd25sb2Fkcy90ZXN0aW1pbm9ueS13ZWIxXzEwLW1haW4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWxpbmsvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbGluay50c1xuaW1wb3J0IHsgTWFyaywgbWFya1Bhc3RlUnVsZSwgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgZmluZCBhcyBmaW5kMiwgcmVnaXN0ZXJDdXN0b21Qcm90b2NvbCwgcmVzZXQgfSBmcm9tIFwibGlua2lmeWpzXCI7XG5cbi8vIHNyYy9oZWxwZXJzL2F1dG9saW5rLnRzXG5pbXBvcnQgeyBjb21iaW5lVHJhbnNhY3Rpb25TdGVwcywgZmluZENoaWxkcmVuSW5SYW5nZSwgZ2V0Q2hhbmdlZFJhbmdlcywgZ2V0TWFya3NCZXR3ZWVuIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuaW1wb3J0IHsgdG9rZW5pemUgfSBmcm9tIFwibGlua2lmeWpzXCI7XG5cbi8vIHNyYy9oZWxwZXJzL3doaXRlc3BhY2UudHNcbnZhciBVTklDT0RFX1dISVRFU1BBQ0VfUEFUVEVSTiA9IFwiW1xcMC0gXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDAtXFx1MjAyOVxcdTIwNUZcXHUzMDAwXVwiO1xudmFyIFVOSUNPREVfV0hJVEVTUEFDRV9SRUdFWCA9IG5ldyBSZWdFeHAoVU5JQ09ERV9XSElURVNQQUNFX1BBVFRFUk4pO1xudmFyIFVOSUNPREVfV0hJVEVTUEFDRV9SRUdFWF9FTkQgPSBuZXcgUmVnRXhwKGAke1VOSUNPREVfV0hJVEVTUEFDRV9QQVRURVJOfSRgKTtcbnZhciBVTklDT0RFX1dISVRFU1BBQ0VfUkVHRVhfR0xPQkFMID0gbmV3IFJlZ0V4cChVTklDT0RFX1dISVRFU1BBQ0VfUEFUVEVSTiwgXCJnXCIpO1xuXG4vLyBzcmMvaGVscGVycy9hdXRvbGluay50c1xuZnVuY3Rpb24gaXNWYWxpZExpbmtTdHJ1Y3R1cmUodG9rZW5zKSB7XG4gIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHRva2Vuc1swXS5pc0xpbms7XG4gIH1cbiAgaWYgKHRva2Vucy5sZW5ndGggPT09IDMgJiYgdG9rZW5zWzFdLmlzTGluaykge1xuICAgIHJldHVybiBbXCIoKVwiLCBcIltdXCJdLmluY2x1ZGVzKHRva2Vuc1swXS52YWx1ZSArIHRva2Vuc1syXS52YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gYXV0b2xpbmsob3B0aW9ucykge1xuICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAga2V5OiBuZXcgUGx1Z2luS2V5KFwiYXV0b2xpbmtcIiksXG4gICAgYXBwZW5kVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbnMsIG9sZFN0YXRlLCBuZXdTdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgZG9jQ2hhbmdlcyA9IHRyYW5zYWN0aW9ucy5zb21lKCh0cmFuc2FjdGlvbikgPT4gdHJhbnNhY3Rpb24uZG9jQ2hhbmdlZCkgJiYgIW9sZFN0YXRlLmRvYy5lcShuZXdTdGF0ZS5kb2MpO1xuICAgICAgY29uc3QgcHJldmVudEF1dG9saW5rID0gdHJhbnNhY3Rpb25zLnNvbWUoKHRyYW5zYWN0aW9uKSA9PiB0cmFuc2FjdGlvbi5nZXRNZXRhKFwicHJldmVudEF1dG9saW5rXCIpKTtcbiAgICAgIGlmICghZG9jQ2hhbmdlcyB8fCBwcmV2ZW50QXV0b2xpbmspIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB0ciB9ID0gbmV3U3RhdGU7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBjb21iaW5lVHJhbnNhY3Rpb25TdGVwcyhvbGRTdGF0ZS5kb2MsIFsuLi50cmFuc2FjdGlvbnNdKTtcbiAgICAgIGNvbnN0IGNoYW5nZXMgPSBnZXRDaGFuZ2VkUmFuZ2VzKHRyYW5zZm9ybSk7XG4gICAgICBjaGFuZ2VzLmZvckVhY2goKHsgbmV3UmFuZ2UgfSkgPT4ge1xuICAgICAgICBjb25zdCBub2Rlc0luQ2hhbmdlZFJhbmdlcyA9IGZpbmRDaGlsZHJlbkluUmFuZ2UobmV3U3RhdGUuZG9jLCBuZXdSYW5nZSwgKG5vZGUpID0+IG5vZGUuaXNUZXh0YmxvY2spO1xuICAgICAgICBsZXQgdGV4dEJsb2NrO1xuICAgICAgICBsZXQgdGV4dEJlZm9yZVdoaXRlc3BhY2U7XG4gICAgICAgIGlmIChub2Rlc0luQ2hhbmdlZFJhbmdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGV4dEJsb2NrID0gbm9kZXNJbkNoYW5nZWRSYW5nZXNbMF07XG4gICAgICAgICAgdGV4dEJlZm9yZVdoaXRlc3BhY2UgPSBuZXdTdGF0ZS5kb2MudGV4dEJldHdlZW4oXG4gICAgICAgICAgICB0ZXh0QmxvY2sucG9zLFxuICAgICAgICAgICAgdGV4dEJsb2NrLnBvcyArIHRleHRCbG9jay5ub2RlLm5vZGVTaXplLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgXCIgXCJcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGVzSW5DaGFuZ2VkUmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGVuZFRleHQgPSBuZXdTdGF0ZS5kb2MudGV4dEJldHdlZW4obmV3UmFuZ2UuZnJvbSwgbmV3UmFuZ2UudG8sIFwiIFwiLCBcIiBcIik7XG4gICAgICAgICAgaWYgKCFVTklDT0RFX1dISVRFU1BBQ0VfUkVHRVhfRU5ELnRlc3QoZW5kVGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGV4dEJsb2NrID0gbm9kZXNJbkNoYW5nZWRSYW5nZXNbMF07XG4gICAgICAgICAgdGV4dEJlZm9yZVdoaXRlc3BhY2UgPSBuZXdTdGF0ZS5kb2MudGV4dEJldHdlZW4odGV4dEJsb2NrLnBvcywgbmV3UmFuZ2UudG8sIHZvaWQgMCwgXCIgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0QmxvY2sgJiYgdGV4dEJlZm9yZVdoaXRlc3BhY2UpIHtcbiAgICAgICAgICBjb25zdCB3b3Jkc0JlZm9yZVdoaXRlc3BhY2UgPSB0ZXh0QmVmb3JlV2hpdGVzcGFjZS5zcGxpdChVTklDT0RFX1dISVRFU1BBQ0VfUkVHRVgpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgICAgICBpZiAod29yZHNCZWZvcmVXaGl0ZXNwYWNlLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGxhc3RXb3JkQmVmb3JlU3BhY2UgPSB3b3Jkc0JlZm9yZVdoaXRlc3BhY2Vbd29yZHNCZWZvcmVXaGl0ZXNwYWNlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGNvbnN0IGxhc3RXb3JkQW5kQmxvY2tPZmZzZXQgPSB0ZXh0QmxvY2sucG9zICsgdGV4dEJlZm9yZVdoaXRlc3BhY2UubGFzdEluZGV4T2YobGFzdFdvcmRCZWZvcmVTcGFjZSk7XG4gICAgICAgICAgaWYgKCFsYXN0V29yZEJlZm9yZVNwYWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGxpbmtzQmVmb3JlU3BhY2UgPSB0b2tlbml6ZShsYXN0V29yZEJlZm9yZVNwYWNlKS5tYXAoKHQpID0+IHQudG9PYmplY3Qob3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wpKTtcbiAgICAgICAgICBpZiAoIWlzVmFsaWRMaW5rU3RydWN0dXJlKGxpbmtzQmVmb3JlU3BhY2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpbmtzQmVmb3JlU3BhY2UuZmlsdGVyKChsaW5rKSA9PiBsaW5rLmlzTGluaykubWFwKChsaW5rKSA9PiAoe1xuICAgICAgICAgICAgLi4ubGluayxcbiAgICAgICAgICAgIGZyb206IGxhc3RXb3JkQW5kQmxvY2tPZmZzZXQgKyBsaW5rLnN0YXJ0ICsgMSxcbiAgICAgICAgICAgIHRvOiBsYXN0V29yZEFuZEJsb2NrT2Zmc2V0ICsgbGluay5lbmQgKyAxXG4gICAgICAgICAgfSkpLmZpbHRlcigobGluaykgPT4ge1xuICAgICAgICAgICAgaWYgKCFuZXdTdGF0ZS5zY2hlbWEubWFya3MuY29kZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhbmV3U3RhdGUuZG9jLnJhbmdlSGFzTWFyayhsaW5rLmZyb20sIGxpbmsudG8sIG5ld1N0YXRlLnNjaGVtYS5tYXJrcy5jb2RlKTtcbiAgICAgICAgICB9KS5maWx0ZXIoKGxpbmspID0+IG9wdGlvbnMudmFsaWRhdGUobGluay52YWx1ZSkpLmZpbHRlcigobGluaykgPT4gb3B0aW9ucy5zaG91bGRBdXRvTGluayhsaW5rLnZhbHVlKSkuZm9yRWFjaCgobGluaykgPT4ge1xuICAgICAgICAgICAgaWYgKGdldE1hcmtzQmV0d2VlbihsaW5rLmZyb20sIGxpbmsudG8sIG5ld1N0YXRlLmRvYykuc29tZSgoaXRlbSkgPT4gaXRlbS5tYXJrLnR5cGUgPT09IG9wdGlvbnMudHlwZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHIuYWRkTWFyayhcbiAgICAgICAgICAgICAgbGluay5mcm9tLFxuICAgICAgICAgICAgICBsaW5rLnRvLFxuICAgICAgICAgICAgICBvcHRpb25zLnR5cGUuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBocmVmOiBsaW5rLmhyZWZcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCF0ci5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2NsaWNrSGFuZGxlci50c1xuaW1wb3J0IHsgZ2V0QXR0cmlidXRlcyB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmltcG9ydCB7IFBsdWdpbiBhcyBQbHVnaW4yLCBQbHVnaW5LZXkgYXMgUGx1Z2luS2V5MiB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG5mdW5jdGlvbiBjbGlja0hhbmRsZXIob3B0aW9ucykge1xuICByZXR1cm4gbmV3IFBsdWdpbjIoe1xuICAgIGtleTogbmV3IFBsdWdpbktleTIoXCJoYW5kbGVDbGlja0xpbmtcIiksXG4gICAgcHJvcHM6IHtcbiAgICAgIGhhbmRsZUNsaWNrOiAodmlldywgcG9zLCBldmVudCkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmlldy5lZGl0YWJsZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGluayA9IG51bGw7XG4gICAgICAgIGlmIChldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MQW5jaG9yRWxlbWVudCkge1xuICAgICAgICAgIGxpbmsgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGEgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgY29uc3QgZWxzID0gW107XG4gICAgICAgICAgd2hpbGUgKGEubm9kZU5hbWUgIT09IFwiRElWXCIpIHtcbiAgICAgICAgICAgIGVscy5wdXNoKGEpO1xuICAgICAgICAgICAgYSA9IGEucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGluayA9IGVscy5maW5kKCh2YWx1ZSkgPT4gdmFsdWUubm9kZU5hbWUgPT09IFwiQVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxpbmspIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0cnMgPSBnZXRBdHRyaWJ1dGVzKHZpZXcuc3RhdGUsIG9wdGlvbnMudHlwZS5uYW1lKTtcbiAgICAgICAgY29uc3QgaHJlZiA9IChfYSA9IGxpbmsgPT0gbnVsbCA/IHZvaWQgMCA6IGxpbmsuaHJlZikgIT0gbnVsbCA/IF9hIDogYXR0cnMuaHJlZjtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gKF9iID0gbGluayA9PSBudWxsID8gdm9pZCAwIDogbGluay50YXJnZXQpICE9IG51bGwgPyBfYiA6IGF0dHJzLnRhcmdldDtcbiAgICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlQ2xpY2tTZWxlY3Rpb24pIHtcbiAgICAgICAgICBvcHRpb25zLmVkaXRvci5jb21tYW5kcy5leHRlbmRNYXJrUmFuZ2Uob3B0aW9ucy50eXBlLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5rICYmIGhyZWYpIHtcbiAgICAgICAgICB3aW5kb3cub3BlbihocmVmLCB0YXJnZXQpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvaGVscGVycy9wYXN0ZUhhbmRsZXIudHNcbmltcG9ydCB7IFBsdWdpbiBhcyBQbHVnaW4zLCBQbHVnaW5LZXkgYXMgUGx1Z2luS2V5MyB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG5pbXBvcnQgeyBmaW5kIH0gZnJvbSBcImxpbmtpZnlqc1wiO1xuZnVuY3Rpb24gcGFzdGVIYW5kbGVyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBQbHVnaW4zKHtcbiAgICBrZXk6IG5ldyBQbHVnaW5LZXkzKFwiaGFuZGxlUGFzdGVMaW5rXCIpLFxuICAgIHByb3BzOiB7XG4gICAgICBoYW5kbGVQYXN0ZTogKHZpZXcsIF9ldmVudCwgc2xpY2UpID0+IHtcbiAgICAgICAgY29uc3QgeyBzaG91bGRBdXRvTGluayB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gdmlldztcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlO1xuICAgICAgICBjb25zdCB7IGVtcHR5IH0gPSBzZWxlY3Rpb247XG4gICAgICAgIGlmIChlbXB0eSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICBzbGljZS5jb250ZW50LmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICB0ZXh0Q29udGVudCArPSBub2RlLnRleHRDb250ZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbGluayA9IGZpbmQodGV4dENvbnRlbnQsIHsgZGVmYXVsdFByb3RvY29sOiBvcHRpb25zLmRlZmF1bHRQcm90b2NvbCB9KS5maW5kKFxuICAgICAgICAgIChpdGVtKSA9PiBpdGVtLmlzTGluayAmJiBpdGVtLnZhbHVlID09PSB0ZXh0Q29udGVudFxuICAgICAgICApO1xuICAgICAgICBpZiAoIXRleHRDb250ZW50IHx8ICFsaW5rIHx8IHNob3VsZEF1dG9MaW5rICE9PSB2b2lkIDAgJiYgIXNob3VsZEF1dG9MaW5rKGxpbmsuaHJlZikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZWRpdG9yLmNvbW1hbmRzLnNldE1hcmsob3B0aW9ucy50eXBlLCB7XG4gICAgICAgICAgaHJlZjogbGluay5ocmVmXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9saW5rLnRzXG52YXIgcGFzdGVSZWdleCA9IC9odHRwcz86XFwvXFwvKD86d3d3XFwuKT9bLWEtekEtWjAtOUA6JS5fK34jPV17MSwyNTZ9XFwuW2EtekEtWl17Mix9XFxiKD86Wy1hLXpBLVowLTlAOiUuXyt+Iz0/ISYvXSopKD86Wy1hLXpBLVowLTlAOiUuXyt+Iz0/ISYvXSopL2dpO1xuZnVuY3Rpb24gaXNBbGxvd2VkVXJpKHVyaSwgcHJvdG9jb2xzKSB7XG4gIGNvbnN0IGFsbG93ZWRQcm90b2NvbHMgPSBbXCJodHRwXCIsIFwiaHR0cHNcIiwgXCJmdHBcIiwgXCJmdHBzXCIsIFwibWFpbHRvXCIsIFwidGVsXCIsIFwiY2FsbHRvXCIsIFwic21zXCIsIFwiY2lkXCIsIFwieG1wcFwiXTtcbiAgaWYgKHByb3RvY29scykge1xuICAgIHByb3RvY29scy5mb3JFYWNoKChwcm90b2NvbCkgPT4ge1xuICAgICAgY29uc3QgbmV4dFByb3RvY29sID0gdHlwZW9mIHByb3RvY29sID09PSBcInN0cmluZ1wiID8gcHJvdG9jb2wgOiBwcm90b2NvbC5zY2hlbWU7XG4gICAgICBpZiAobmV4dFByb3RvY29sKSB7XG4gICAgICAgIGFsbG93ZWRQcm90b2NvbHMucHVzaChuZXh0UHJvdG9jb2wpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiAhdXJpIHx8IHVyaS5yZXBsYWNlKFVOSUNPREVfV0hJVEVTUEFDRV9SRUdFWF9HTE9CQUwsIFwiXCIpLm1hdGNoKFxuICAgIG5ldyBSZWdFeHAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbiAgICAgIGBeKD86KD86JHthbGxvd2VkUHJvdG9jb2xzLmpvaW4oXCJ8XCIpfSk6fFteYS16XXxbYS16MC05Ky4tXSsoPzpbXmEteisuLTpdfCQpKWAsXG4gICAgICBcImlcIlxuICAgIClcbiAgKTtcbn1cbnZhciBMaW5rID0gTWFyay5jcmVhdGUoe1xuICBuYW1lOiBcImxpbmtcIixcbiAgcHJpb3JpdHk6IDFlMyxcbiAga2VlcE9uU3BsaXQ6IGZhbHNlLFxuICBleGl0YWJsZTogdHJ1ZSxcbiAgb25DcmVhdGUoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy52YWxpZGF0ZSAmJiAhdGhpcy5vcHRpb25zLnNob3VsZEF1dG9MaW5rKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuc2hvdWxkQXV0b0xpbmsgPSB0aGlzLm9wdGlvbnMudmFsaWRhdGU7XG4gICAgICBjb25zb2xlLndhcm4oXCJUaGUgYHZhbGlkYXRlYCBvcHRpb24gaXMgZGVwcmVjYXRlZC4gUmVuYW1lIHRvIHRoZSBgc2hvdWxkQXV0b0xpbmtgIG9wdGlvbiBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zLnByb3RvY29scy5mb3JFYWNoKChwcm90b2NvbCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBwcm90b2NvbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZWdpc3RlckN1c3RvbVByb3RvY29sKHByb3RvY29sKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVnaXN0ZXJDdXN0b21Qcm90b2NvbChwcm90b2NvbC5zY2hlbWUsIHByb3RvY29sLm9wdGlvbmFsU2xhc2hlcyk7XG4gICAgfSk7XG4gIH0sXG4gIG9uRGVzdHJveSgpIHtcbiAgICByZXNldCgpO1xuICB9LFxuICBpbmNsdXNpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hdXRvbGluaztcbiAgfSxcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3Blbk9uQ2xpY2s6IHRydWUsXG4gICAgICBlbmFibGVDbGlja1NlbGVjdGlvbjogZmFsc2UsXG4gICAgICBsaW5rT25QYXN0ZTogdHJ1ZSxcbiAgICAgIGF1dG9saW5rOiB0cnVlLFxuICAgICAgcHJvdG9jb2xzOiBbXSxcbiAgICAgIGRlZmF1bHRQcm90b2NvbDogXCJodHRwXCIsXG4gICAgICBIVE1MQXR0cmlidXRlczoge1xuICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgIHJlbDogXCJub29wZW5lciBub3JlZmVycmVyIG5vZm9sbG93XCIsXG4gICAgICAgIGNsYXNzOiBudWxsXG4gICAgICB9LFxuICAgICAgaXNBbGxvd2VkVXJpOiAodXJsLCBjdHgpID0+ICEhaXNBbGxvd2VkVXJpKHVybCwgY3R4LnByb3RvY29scyksXG4gICAgICB2YWxpZGF0ZTogKHVybCkgPT4gISF1cmwsXG4gICAgICBzaG91bGRBdXRvTGluazogKHVybCkgPT4gISF1cmxcbiAgICB9O1xuICB9LFxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBocmVmOiB7XG4gICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgIHBhcnNlSFRNTChlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRhcmdldDoge1xuICAgICAgICBkZWZhdWx0OiB0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMudGFyZ2V0XG4gICAgICB9LFxuICAgICAgcmVsOiB7XG4gICAgICAgIGRlZmF1bHQ6IHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcy5yZWxcbiAgICAgIH0sXG4gICAgICBjbGFzczoge1xuICAgICAgICBkZWZhdWx0OiB0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMuY2xhc3NcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcImFbaHJlZl1cIixcbiAgICAgICAgZ2V0QXR0cnM6IChkb20pID0+IHtcbiAgICAgICAgICBjb25zdCBocmVmID0gZG9tLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgICAgICAgaWYgKCFocmVmIHx8ICF0aGlzLm9wdGlvbnMuaXNBbGxvd2VkVXJpKGhyZWYsIHtcbiAgICAgICAgICAgIGRlZmF1bHRWYWxpZGF0ZTogKHVybCkgPT4gISFpc0FsbG93ZWRVcmkodXJsLCB0aGlzLm9wdGlvbnMucHJvdG9jb2xzKSxcbiAgICAgICAgICAgIHByb3RvY29sczogdGhpcy5vcHRpb25zLnByb3RvY29scyxcbiAgICAgICAgICAgIGRlZmF1bHRQcm90b2NvbDogdGhpcy5vcHRpb25zLmRlZmF1bHRQcm90b2NvbFxuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5pc0FsbG93ZWRVcmkoSFRNTEF0dHJpYnV0ZXMuaHJlZiwge1xuICAgICAgZGVmYXVsdFZhbGlkYXRlOiAoaHJlZikgPT4gISFpc0FsbG93ZWRVcmkoaHJlZiwgdGhpcy5vcHRpb25zLnByb3RvY29scyksXG4gICAgICBwcm90b2NvbHM6IHRoaXMub3B0aW9ucy5wcm90b2NvbHMsXG4gICAgICBkZWZhdWx0UHJvdG9jb2w6IHRoaXMub3B0aW9ucy5kZWZhdWx0UHJvdG9jb2xcbiAgICB9KSkge1xuICAgICAgcmV0dXJuIFtcImFcIiwgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgeyAuLi5IVE1MQXR0cmlidXRlcywgaHJlZjogXCJcIiB9KSwgMF07XG4gICAgfVxuICAgIHJldHVybiBbXCJhXCIsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gIH0sXG4gIG1hcmtkb3duVG9rZW5OYW1lOiBcImxpbmtcIixcbiAgcGFyc2VNYXJrZG93bjogKHRva2VuLCBoZWxwZXJzKSA9PiB7XG4gICAgcmV0dXJuIGhlbHBlcnMuYXBwbHlNYXJrKFwibGlua1wiLCBoZWxwZXJzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucyB8fCBbXSksIHtcbiAgICAgIGhyZWY6IHRva2VuLmhyZWYsXG4gICAgICB0aXRsZTogdG9rZW4udGl0bGUgfHwgbnVsbFxuICAgIH0pO1xuICB9LFxuICByZW5kZXJNYXJrZG93bjogKG5vZGUsIGgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgaHJlZiA9ICgoX2EgPSBub2RlLmF0dHJzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaHJlZikgfHwgXCJcIjtcbiAgICBjb25zdCB0ZXh0ID0gaC5yZW5kZXJDaGlsZHJlbihub2RlKTtcbiAgICByZXR1cm4gYFske3RleHR9XSgke2hyZWZ9KWA7XG4gIH0sXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRMaW5rOiAoYXR0cmlidXRlcykgPT4gKHsgY2hhaW4gfSkgPT4ge1xuICAgICAgICBjb25zdCB7IGhyZWYgfSA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmlzQWxsb3dlZFVyaShocmVmLCB7XG4gICAgICAgICAgZGVmYXVsdFZhbGlkYXRlOiAodXJsKSA9PiAhIWlzQWxsb3dlZFVyaSh1cmwsIHRoaXMub3B0aW9ucy5wcm90b2NvbHMpLFxuICAgICAgICAgIHByb3RvY29sczogdGhpcy5vcHRpb25zLnByb3RvY29scyxcbiAgICAgICAgICBkZWZhdWx0UHJvdG9jb2w6IHRoaXMub3B0aW9ucy5kZWZhdWx0UHJvdG9jb2xcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYWluKCkuc2V0TWFyayh0aGlzLm5hbWUsIGF0dHJpYnV0ZXMpLnNldE1ldGEoXCJwcmV2ZW50QXV0b2xpbmtcIiwgdHJ1ZSkucnVuKCk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlTGluazogKGF0dHJpYnV0ZXMpID0+ICh7IGNoYWluIH0pID0+IHtcbiAgICAgICAgY29uc3QgeyBocmVmIH0gPSBhdHRyaWJ1dGVzIHx8IHt9O1xuICAgICAgICBpZiAoaHJlZiAmJiAhdGhpcy5vcHRpb25zLmlzQWxsb3dlZFVyaShocmVmLCB7XG4gICAgICAgICAgZGVmYXVsdFZhbGlkYXRlOiAodXJsKSA9PiAhIWlzQWxsb3dlZFVyaSh1cmwsIHRoaXMub3B0aW9ucy5wcm90b2NvbHMpLFxuICAgICAgICAgIHByb3RvY29sczogdGhpcy5vcHRpb25zLnByb3RvY29scyxcbiAgICAgICAgICBkZWZhdWx0UHJvdG9jb2w6IHRoaXMub3B0aW9ucy5kZWZhdWx0UHJvdG9jb2xcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYWluKCkudG9nZ2xlTWFyayh0aGlzLm5hbWUsIGF0dHJpYnV0ZXMsIHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2U6IHRydWUgfSkuc2V0TWV0YShcInByZXZlbnRBdXRvbGlua1wiLCB0cnVlKS5ydW4oKTtcbiAgICAgIH0sXG4gICAgICB1bnNldExpbms6ICgpID0+ICh7IGNoYWluIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNoYWluKCkudW5zZXRNYXJrKHRoaXMubmFtZSwgeyBleHRlbmRFbXB0eU1hcmtSYW5nZTogdHJ1ZSB9KS5zZXRNZXRhKFwicHJldmVudEF1dG9saW5rXCIsIHRydWUpLnJ1bigpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiAodGV4dCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZvdW5kTGlua3MgPSBbXTtcbiAgICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgY29uc3QgeyBwcm90b2NvbHMsIGRlZmF1bHRQcm90b2NvbCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgbGlua3MgPSBmaW5kMih0ZXh0KS5maWx0ZXIoXG4gICAgICAgICAgICAgIChpdGVtKSA9PiBpdGVtLmlzTGluayAmJiB0aGlzLm9wdGlvbnMuaXNBbGxvd2VkVXJpKGl0ZW0udmFsdWUsIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsaWRhdGU6IChocmVmKSA9PiAhIWlzQWxsb3dlZFVyaShocmVmLCBwcm90b2NvbHMpLFxuICAgICAgICAgICAgICAgIHByb3RvY29scyxcbiAgICAgICAgICAgICAgICBkZWZhdWx0UHJvdG9jb2xcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAobGlua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGxpbmtzLmZvckVhY2goKGxpbmspID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG91bGRBdXRvTGluayhsaW5rLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3VuZExpbmtzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgdGV4dDogbGluay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogbGluay5ocmVmXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgaW5kZXg6IGxpbmsuc3RhcnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmb3VuZExpbmtzO1xuICAgICAgICB9LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6IChtYXRjaCkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaHJlZjogKF9hID0gbWF0Y2guZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmhyZWZcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICBjb25zdCBwbHVnaW5zID0gW107XG4gICAgY29uc3QgeyBwcm90b2NvbHMsIGRlZmF1bHRQcm90b2NvbCB9ID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b2xpbmspIHtcbiAgICAgIHBsdWdpbnMucHVzaChcbiAgICAgICAgYXV0b2xpbmsoe1xuICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICBkZWZhdWx0UHJvdG9jb2w6IHRoaXMub3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wsXG4gICAgICAgICAgdmFsaWRhdGU6ICh1cmwpID0+IHRoaXMub3B0aW9ucy5pc0FsbG93ZWRVcmkodXJsLCB7XG4gICAgICAgICAgICBkZWZhdWx0VmFsaWRhdGU6IChocmVmKSA9PiAhIWlzQWxsb3dlZFVyaShocmVmLCBwcm90b2NvbHMpLFxuICAgICAgICAgICAgcHJvdG9jb2xzLFxuICAgICAgICAgICAgZGVmYXVsdFByb3RvY29sXG4gICAgICAgICAgfSksXG4gICAgICAgICAgc2hvdWxkQXV0b0xpbms6IHRoaXMub3B0aW9ucy5zaG91bGRBdXRvTGlua1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vcGVuT25DbGljayA9PT0gdHJ1ZSkge1xuICAgICAgcGx1Z2lucy5wdXNoKFxuICAgICAgICBjbGlja0hhbmRsZXIoe1xuICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgIGVuYWJsZUNsaWNrU2VsZWN0aW9uOiB0aGlzLm9wdGlvbnMuZW5hYmxlQ2xpY2tTZWxlY3Rpb25cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMubGlua09uUGFzdGUpIHtcbiAgICAgIHBsdWdpbnMucHVzaChcbiAgICAgICAgcGFzdGVIYW5kbGVyKHtcbiAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgIGRlZmF1bHRQcm90b2NvbDogdGhpcy5vcHRpb25zLmRlZmF1bHRQcm90b2NvbCxcbiAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgc2hvdWxkQXV0b0xpbms6IHRoaXMub3B0aW9ucy5zaG91bGRBdXRvTGlua1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHBsdWdpbnM7XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gTGluaztcbmV4cG9ydCB7XG4gIExpbmssXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdCxcbiAgaXNBbGxvd2VkVXJpLFxuICBwYXN0ZVJlZ2V4XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-link/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-list/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-list/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BulletList: () => (/* binding */ BulletList),\n/* harmony export */   ListItem: () => (/* binding */ ListItem),\n/* harmony export */   ListKeymap: () => (/* binding */ ListKeymap),\n/* harmony export */   ListKit: () => (/* binding */ ListKit),\n/* harmony export */   OrderedList: () => (/* binding */ OrderedList),\n/* harmony export */   TaskItem: () => (/* binding */ TaskItem),\n/* harmony export */   TaskList: () => (/* binding */ TaskList),\n/* harmony export */   bulletListInputRegex: () => (/* binding */ bulletListInputRegex),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex),\n/* harmony export */   listHelpers: () => (/* binding */ listHelpers_exports),\n/* harmony export */   orderedListInputRegex: () => (/* binding */ orderedListInputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/bullet-list/bullet-list.ts\n\nvar ListItemName = \"listItem\";\nvar TextStyleName = \"textStyle\";\nvar bulletListInputRegex = /^\\s*([-+*])\\s$/;\nvar BulletList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"bulletList\",\n  addOptions() {\n    return {\n      itemTypeName: \"listItem\",\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false\n    };\n  },\n  group: \"block list\",\n  content() {\n    return `${this.options.itemTypeName}+`;\n  },\n  parseHTML() {\n    return [{ tag: \"ul\" }];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"ul\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  markdownTokenName: \"list\",\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== \"list\" || token.ordered) {\n      return [];\n    }\n    return {\n      type: \"bulletList\",\n      content: token.items ? helpers.parseChildren(token.items) : []\n    };\n  },\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return \"\";\n    }\n    return h.renderChildren(node.content, \"\\n\");\n  },\n  markdownOptions: {\n    indentsContent: true\n  },\n  addCommands() {\n    return {\n      toggleBulletList: () => ({ commands, chain }) => {\n        if (this.options.keepAttributes) {\n          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();\n        }\n        return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-8\": () => this.editor.commands.toggleBulletList()\n    };\n  },\n  addInputRules() {\n    let inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n      find: bulletListInputRegex,\n      type: this.type\n    });\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n        find: bulletListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: () => {\n          return this.editor.getAttributes(TextStyleName);\n        },\n        editor: this.editor\n      });\n    }\n    return [inputRule];\n  }\n});\n\n// src/item/list-item.ts\n\nvar ListItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"listItem\",\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      bulletListTypeName: \"bulletList\",\n      orderedListTypeName: \"orderedList\"\n    };\n  },\n  content: \"paragraph block*\",\n  defining: true,\n  parseHTML() {\n    return [\n      {\n        tag: \"li\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"li\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  markdownTokenName: \"list_item\",\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== \"list_item\") {\n      return [];\n    }\n    let content = [];\n    if (token.tokens && token.tokens.length > 0) {\n      const hasParagraphTokens = token.tokens.some((t) => t.type === \"paragraph\");\n      if (hasParagraphTokens) {\n        content = helpers.parseChildren(token.tokens);\n      } else {\n        const firstToken = token.tokens[0];\n        if (firstToken && firstToken.type === \"text\" && firstToken.tokens && firstToken.tokens.length > 0) {\n          const inlineContent = helpers.parseInline(firstToken.tokens);\n          content = [\n            {\n              type: \"paragraph\",\n              content: inlineContent\n            }\n          ];\n          if (token.tokens.length > 1) {\n            const remainingTokens = token.tokens.slice(1);\n            const additionalContent = helpers.parseChildren(remainingTokens);\n            content.push(...additionalContent);\n          }\n        } else {\n          content = helpers.parseChildren(token.tokens);\n        }\n      }\n    }\n    if (content.length === 0) {\n      content = [\n        {\n          type: \"paragraph\",\n          content: []\n        }\n      ];\n    }\n    return {\n      type: \"listItem\",\n      content\n    };\n  },\n  renderMarkdown: (node, h, ctx) => {\n    return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.renderNestedMarkdownContent)(\n      node,\n      h,\n      (context) => {\n        if (context.parentType === \"bulletList\") {\n          return \"- \";\n        }\n        if (context.parentType === \"orderedList\") {\n          return `${context.index + 1}. `;\n        }\n        return \"- \";\n      },\n      ctx\n    );\n  },\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n      \"Shift-Tab\": () => this.editor.commands.liftListItem(this.name)\n    };\n  }\n});\n\n// src/keymap/list-keymap.ts\n\n\n// src/keymap/listHelpers/index.ts\nvar listHelpers_exports = {};\n__export(listHelpers_exports, {\n  findListItemPos: () => findListItemPos,\n  getNextListDepth: () => getNextListDepth,\n  handleBackspace: () => handleBackspace,\n  handleDelete: () => handleDelete,\n  hasListBefore: () => hasListBefore,\n  hasListItemAfter: () => hasListItemAfter,\n  hasListItemBefore: () => hasListItemBefore,\n  listItemHasSubList: () => listItemHasSubList,\n  nextListIsDeeper: () => nextListIsDeeper,\n  nextListIsHigher: () => nextListIsHigher\n});\n\n// src/keymap/listHelpers/findListItemPos.ts\n\nvar findListItemPos = (typeOrName, state) => {\n  const { $from } = state.selection;\n  const nodeType = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getNodeType)(typeOrName, state.schema);\n  let currentNode = null;\n  let currentDepth = $from.depth;\n  let currentPos = $from.pos;\n  let targetDepth = null;\n  while (currentDepth > 0 && targetDepth === null) {\n    currentNode = $from.node(currentDepth);\n    if (currentNode.type === nodeType) {\n      targetDepth = currentDepth;\n    } else {\n      currentDepth -= 1;\n      currentPos -= 1;\n    }\n  }\n  if (targetDepth === null) {\n    return null;\n  }\n  return { $pos: state.doc.resolve(currentPos), depth: targetDepth };\n};\n\n// src/keymap/listHelpers/getNextListDepth.ts\n\nvar getNextListDepth = (typeOrName, state) => {\n  const listItemPos = findListItemPos(typeOrName, state);\n  if (!listItemPos) {\n    return false;\n  }\n  const [, depth] = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getNodeAtPosition)(state, typeOrName, listItemPos.$pos.pos + 4);\n  return depth;\n};\n\n// src/keymap/listHelpers/handleBackspace.ts\n\n\n// src/keymap/listHelpers/hasListBefore.ts\nvar hasListBefore = (editorState, name, parentListTypes) => {\n  const { $anchor } = editorState.selection;\n  const previousNodePos = Math.max(0, $anchor.pos - 2);\n  const previousNode = editorState.doc.resolve(previousNodePos).node();\n  if (!previousNode || !parentListTypes.includes(previousNode.type.name)) {\n    return false;\n  }\n  return true;\n};\n\n// src/keymap/listHelpers/hasListItemBefore.ts\nvar hasListItemBefore = (typeOrName, state) => {\n  var _a;\n  const { $anchor } = state.selection;\n  const $targetPos = state.doc.resolve($anchor.pos - 2);\n  if ($targetPos.index() === 0) {\n    return false;\n  }\n  if (((_a = $targetPos.nodeBefore) == null ? void 0 : _a.type.name) !== typeOrName) {\n    return false;\n  }\n  return true;\n};\n\n// src/keymap/listHelpers/listItemHasSubList.ts\n\nvar listItemHasSubList = (typeOrName, state, node) => {\n  if (!node) {\n    return false;\n  }\n  const nodeType = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getNodeType)(typeOrName, state.schema);\n  let hasSubList = false;\n  node.descendants((child) => {\n    if (child.type === nodeType) {\n      hasSubList = true;\n    }\n  });\n  return hasSubList;\n};\n\n// src/keymap/listHelpers/handleBackspace.ts\nvar handleBackspace = (editor, name, parentListTypes) => {\n  if (editor.commands.undoInputRule()) {\n    return true;\n  }\n  if (editor.state.selection.from !== editor.state.selection.to) {\n    return false;\n  }\n  if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isNodeActive)(editor.state, name) && hasListBefore(editor.state, name, parentListTypes)) {\n    const { $anchor } = editor.state.selection;\n    const $listPos = editor.state.doc.resolve($anchor.before() - 1);\n    const listDescendants = [];\n    $listPos.node().descendants((node, pos) => {\n      if (node.type.name === name) {\n        listDescendants.push({ node, pos });\n      }\n    });\n    const lastItem = listDescendants.at(-1);\n    if (!lastItem) {\n      return false;\n    }\n    const $lastItemPos = editor.state.doc.resolve($listPos.start() + lastItem.pos + 1);\n    return editor.chain().cut({ from: $anchor.start() - 1, to: $anchor.end() + 1 }, $lastItemPos.end()).joinForward().run();\n  }\n  if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isNodeActive)(editor.state, name)) {\n    return false;\n  }\n  if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isAtStartOfNode)(editor.state)) {\n    return false;\n  }\n  const listItemPos = findListItemPos(name, editor.state);\n  if (!listItemPos) {\n    return false;\n  }\n  const $prev = editor.state.doc.resolve(listItemPos.$pos.pos - 2);\n  const prevNode = $prev.node(listItemPos.depth);\n  const previousListItemHasSubList = listItemHasSubList(name, editor.state, prevNode);\n  if (hasListItemBefore(name, editor.state) && !previousListItemHasSubList) {\n    return editor.commands.joinItemBackward();\n  }\n  return editor.chain().liftListItem(name).run();\n};\n\n// src/keymap/listHelpers/handleDelete.ts\n\n\n// src/keymap/listHelpers/nextListIsDeeper.ts\nvar nextListIsDeeper = (typeOrName, state) => {\n  const listDepth = getNextListDepth(typeOrName, state);\n  const listItemPos = findListItemPos(typeOrName, state);\n  if (!listItemPos || !listDepth) {\n    return false;\n  }\n  if (listDepth > listItemPos.depth) {\n    return true;\n  }\n  return false;\n};\n\n// src/keymap/listHelpers/nextListIsHigher.ts\nvar nextListIsHigher = (typeOrName, state) => {\n  const listDepth = getNextListDepth(typeOrName, state);\n  const listItemPos = findListItemPos(typeOrName, state);\n  if (!listItemPos || !listDepth) {\n    return false;\n  }\n  if (listDepth < listItemPos.depth) {\n    return true;\n  }\n  return false;\n};\n\n// src/keymap/listHelpers/handleDelete.ts\nvar handleDelete = (editor, name) => {\n  if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isNodeActive)(editor.state, name)) {\n    return false;\n  }\n  if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isAtEndOfNode)(editor.state, name)) {\n    return false;\n  }\n  const { selection } = editor.state;\n  const { $from, $to } = selection;\n  if (!selection.empty && $from.sameParent($to)) {\n    return false;\n  }\n  if (nextListIsDeeper(name, editor.state)) {\n    return editor.chain().focus(editor.state.selection.from + 4).lift(name).joinBackward().run();\n  }\n  if (nextListIsHigher(name, editor.state)) {\n    return editor.chain().joinForward().joinBackward().run();\n  }\n  return editor.commands.joinItemForward();\n};\n\n// src/keymap/listHelpers/hasListItemAfter.ts\nvar hasListItemAfter = (typeOrName, state) => {\n  var _a;\n  const { $anchor } = state.selection;\n  const $targetPos = state.doc.resolve($anchor.pos - $anchor.parentOffset - 2);\n  if ($targetPos.index() === $targetPos.parent.childCount - 1) {\n    return false;\n  }\n  if (((_a = $targetPos.nodeAfter) == null ? void 0 : _a.type.name) !== typeOrName) {\n    return false;\n  }\n  return true;\n};\n\n// src/keymap/list-keymap.ts\nvar ListKeymap = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Extension.create({\n  name: \"listKeymap\",\n  addOptions() {\n    return {\n      listTypes: [\n        {\n          itemName: \"listItem\",\n          wrapperNames: [\"bulletList\", \"orderedList\"]\n        },\n        {\n          itemName: \"taskItem\",\n          wrapperNames: [\"taskList\"]\n        }\n      ]\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      Delete: ({ editor }) => {\n        let handled = false;\n        this.options.listTypes.forEach(({ itemName }) => {\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleDelete(editor, itemName)) {\n            handled = true;\n          }\n        });\n        return handled;\n      },\n      \"Mod-Delete\": ({ editor }) => {\n        let handled = false;\n        this.options.listTypes.forEach(({ itemName }) => {\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleDelete(editor, itemName)) {\n            handled = true;\n          }\n        });\n        return handled;\n      },\n      Backspace: ({ editor }) => {\n        let handled = false;\n        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true;\n          }\n        });\n        return handled;\n      },\n      \"Mod-Backspace\": ({ editor }) => {\n        let handled = false;\n        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true;\n          }\n        });\n        return handled;\n      }\n    };\n  }\n});\n\n// src/kit/index.ts\n\n\n// src/ordered-list/ordered-list.ts\n\n\n// src/ordered-list/utils.ts\nvar ORDERED_LIST_ITEM_REGEX = /^(\\s*)(\\d+)\\.\\s+(.*)$/;\nvar INDENTED_LINE_REGEX = /^\\s/;\nfunction collectOrderedListItems(lines) {\n  const listItems = [];\n  let currentLineIndex = 0;\n  let consumed = 0;\n  while (currentLineIndex < lines.length) {\n    const line = lines[currentLineIndex];\n    const match = line.match(ORDERED_LIST_ITEM_REGEX);\n    if (!match) {\n      break;\n    }\n    const [, indent, number, content] = match;\n    const indentLevel = indent.length;\n    let itemContent = content;\n    let nextLineIndex = currentLineIndex + 1;\n    const itemLines = [line];\n    while (nextLineIndex < lines.length) {\n      const nextLine = lines[nextLineIndex];\n      const nextMatch = nextLine.match(ORDERED_LIST_ITEM_REGEX);\n      if (nextMatch) {\n        break;\n      }\n      if (nextLine.trim() === \"\") {\n        itemLines.push(nextLine);\n        itemContent += \"\\n\";\n        nextLineIndex += 1;\n      } else if (nextLine.match(INDENTED_LINE_REGEX)) {\n        itemLines.push(nextLine);\n        itemContent += `\n${nextLine.slice(indentLevel + 2)}`;\n        nextLineIndex += 1;\n      } else {\n        break;\n      }\n    }\n    listItems.push({\n      indent: indentLevel,\n      number: parseInt(number, 10),\n      content: itemContent.trim(),\n      raw: itemLines.join(\"\\n\")\n    });\n    consumed = nextLineIndex;\n    currentLineIndex = nextLineIndex;\n  }\n  return [listItems, consumed];\n}\nfunction buildNestedStructure(items, baseIndent, lexer) {\n  var _a;\n  const result = [];\n  let currentIndex = 0;\n  while (currentIndex < items.length) {\n    const item = items[currentIndex];\n    if (item.indent === baseIndent) {\n      const contentLines = item.content.split(\"\\n\");\n      const mainText = ((_a = contentLines[0]) == null ? void 0 : _a.trim()) || \"\";\n      const tokens = [];\n      if (mainText) {\n        tokens.push({\n          type: \"paragraph\",\n          raw: mainText,\n          tokens: lexer.inlineTokens(mainText)\n        });\n      }\n      const additionalContent = contentLines.slice(1).join(\"\\n\").trim();\n      if (additionalContent) {\n        const blockTokens = lexer.blockTokens(additionalContent);\n        tokens.push(...blockTokens);\n      }\n      let lookAheadIndex = currentIndex + 1;\n      const nestedItems = [];\n      while (lookAheadIndex < items.length && items[lookAheadIndex].indent > baseIndent) {\n        nestedItems.push(items[lookAheadIndex]);\n        lookAheadIndex += 1;\n      }\n      if (nestedItems.length > 0) {\n        const nextIndent = Math.min(...nestedItems.map((nestedItem) => nestedItem.indent));\n        const nestedListItems = buildNestedStructure(nestedItems, nextIndent, lexer);\n        tokens.push({\n          type: \"list\",\n          ordered: true,\n          start: nestedItems[0].number,\n          items: nestedListItems,\n          raw: nestedItems.map((nestedItem) => nestedItem.raw).join(\"\\n\")\n        });\n      }\n      result.push({\n        type: \"list_item\",\n        raw: item.raw,\n        tokens\n      });\n      currentIndex = lookAheadIndex;\n    } else {\n      currentIndex += 1;\n    }\n  }\n  return result;\n}\nfunction parseListItems(items, helpers) {\n  return items.map((item) => {\n    if (item.type !== \"list_item\") {\n      return helpers.parseChildren([item])[0];\n    }\n    const content = [];\n    if (item.tokens && item.tokens.length > 0) {\n      item.tokens.forEach((itemToken) => {\n        if (itemToken.type === \"paragraph\" || itemToken.type === \"list\" || itemToken.type === \"blockquote\" || itemToken.type === \"code\") {\n          content.push(...helpers.parseChildren([itemToken]));\n        } else if (itemToken.type === \"text\" && itemToken.tokens) {\n          const inlineContent = helpers.parseChildren([itemToken]);\n          content.push({\n            type: \"paragraph\",\n            content: inlineContent\n          });\n        } else {\n          const parsed = helpers.parseChildren([itemToken]);\n          if (parsed.length > 0) {\n            content.push(...parsed);\n          }\n        }\n      });\n    }\n    return {\n      type: \"listItem\",\n      content\n    };\n  });\n}\n\n// src/ordered-list/ordered-list.ts\nvar ListItemName2 = \"listItem\";\nvar TextStyleName2 = \"textStyle\";\nvar orderedListInputRegex = /^(\\d+)\\.\\s$/;\nvar OrderedList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"orderedList\",\n  addOptions() {\n    return {\n      itemTypeName: \"listItem\",\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false\n    };\n  },\n  group: \"block list\",\n  content() {\n    return `${this.options.itemTypeName}+`;\n  },\n  addAttributes() {\n    return {\n      start: {\n        default: 1,\n        parseHTML: (element) => {\n          return element.hasAttribute(\"start\") ? parseInt(element.getAttribute(\"start\") || \"\", 10) : 1;\n        }\n      },\n      type: {\n        default: null,\n        parseHTML: (element) => element.getAttribute(\"type\")\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"ol\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    const { start, ...attributesWithoutStart } = HTMLAttributes;\n    return start === 1 ? [\"ol\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, attributesWithoutStart), 0] : [\"ol\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  markdownTokenName: \"list\",\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== \"list\" || !token.ordered) {\n      return [];\n    }\n    const startValue = token.start || 1;\n    const content = token.items ? parseListItems(token.items, helpers) : [];\n    if (startValue !== 1) {\n      return {\n        type: \"orderedList\",\n        attrs: { start: startValue },\n        content\n      };\n    }\n    return {\n      type: \"orderedList\",\n      content\n    };\n  },\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return \"\";\n    }\n    return h.renderChildren(node.content, \"\\n\");\n  },\n  markdownTokenizer: {\n    name: \"orderedList\",\n    level: \"block\",\n    start: (src) => {\n      const match = src.match(/^(\\s*)(\\d+)\\.\\s+/);\n      const index = match == null ? void 0 : match.index;\n      return index !== void 0 ? index : -1;\n    },\n    tokenize: (src, _tokens, lexer) => {\n      var _a;\n      const lines = src.split(\"\\n\");\n      const [listItems, consumed] = collectOrderedListItems(lines);\n      if (listItems.length === 0) {\n        return void 0;\n      }\n      const items = buildNestedStructure(listItems, 0, lexer);\n      if (items.length === 0) {\n        return void 0;\n      }\n      const startValue = ((_a = listItems[0]) == null ? void 0 : _a.number) || 1;\n      return {\n        type: \"list\",\n        ordered: true,\n        start: startValue,\n        items,\n        raw: lines.slice(0, consumed).join(\"\\n\")\n      };\n    }\n  },\n  markdownOptions: {\n    indentsContent: true\n  },\n  addCommands() {\n    return {\n      toggleOrderedList: () => ({ commands, chain }) => {\n        if (this.options.keepAttributes) {\n          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName2, this.editor.getAttributes(TextStyleName2)).run();\n        }\n        return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-7\": () => this.editor.commands.toggleOrderedList()\n    };\n  },\n  addInputRules() {\n    let inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n      find: orderedListInputRegex,\n      type: this.type,\n      getAttributes: (match) => ({ start: +match[1] }),\n      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]\n    });\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n        find: orderedListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: (match) => ({ start: +match[1], ...this.editor.getAttributes(TextStyleName2) }),\n        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n        editor: this.editor\n      });\n    }\n    return [inputRule];\n  }\n});\n\n// src/task-item/task-item.ts\n\nvar inputRegex = /^\\s*(\\[([( |x])?\\])\\s$/;\nvar TaskItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"taskItem\",\n  addOptions() {\n    return {\n      nested: false,\n      HTMLAttributes: {},\n      taskListTypeName: \"taskList\",\n      a11y: void 0\n    };\n  },\n  content() {\n    return this.options.nested ? \"paragraph block*\" : \"paragraph+\";\n  },\n  defining: true,\n  addAttributes() {\n    return {\n      checked: {\n        default: false,\n        keepOnSplit: false,\n        parseHTML: (element) => {\n          const dataChecked = element.getAttribute(\"data-checked\");\n          return dataChecked === \"\" || dataChecked === \"true\";\n        },\n        renderHTML: (attributes) => ({\n          \"data-checked\": attributes.checked\n        })\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: `li[data-type=\"${this.name}\"]`,\n        priority: 51\n      }\n    ];\n  },\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      \"li\",\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes, {\n        \"data-type\": this.name\n      }),\n      [\n        \"label\",\n        [\n          \"input\",\n          {\n            type: \"checkbox\",\n            checked: node.attrs.checked ? \"checked\" : null\n          }\n        ],\n        [\"span\"]\n      ],\n      [\"div\", 0]\n    ];\n  },\n  parseMarkdown: (token, h) => {\n    const content = [];\n    if (token.tokens && token.tokens.length > 0) {\n      content.push(h.createNode(\"paragraph\", {}, h.parseInline(token.tokens)));\n    } else if (token.text) {\n      content.push(h.createNode(\"paragraph\", {}, [h.createNode(\"text\", { text: token.text })]));\n    } else {\n      content.push(h.createNode(\"paragraph\", {}, []));\n    }\n    if (token.nestedTokens && token.nestedTokens.length > 0) {\n      const nestedContent = h.parseChildren(token.nestedTokens);\n      content.push(...nestedContent);\n    }\n    return h.createNode(\"taskItem\", { checked: token.checked || false }, content);\n  },\n  renderMarkdown: (node, h) => {\n    var _a;\n    const checkedChar = ((_a = node.attrs) == null ? void 0 : _a.checked) ? \"x\" : \" \";\n    const prefix = `- [${checkedChar}] `;\n    return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.renderNestedMarkdownContent)(node, h, prefix);\n  },\n  addKeyboardShortcuts() {\n    const shortcuts = {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      \"Shift-Tab\": () => this.editor.commands.liftListItem(this.name)\n    };\n    if (!this.options.nested) {\n      return shortcuts;\n    }\n    return {\n      ...shortcuts,\n      Tab: () => this.editor.commands.sinkListItem(this.name)\n    };\n  },\n  addNodeView() {\n    return ({ node, HTMLAttributes, getPos, editor }) => {\n      const listItem = document.createElement(\"li\");\n      const checkboxWrapper = document.createElement(\"label\");\n      const checkboxStyler = document.createElement(\"span\");\n      const checkbox = document.createElement(\"input\");\n      const content = document.createElement(\"div\");\n      const updateA11Y = (currentNode) => {\n        var _a, _b;\n        checkbox.ariaLabel = ((_b = (_a = this.options.a11y) == null ? void 0 : _a.checkboxLabel) == null ? void 0 : _b.call(_a, currentNode, checkbox.checked)) || `Task item checkbox for ${currentNode.textContent || \"empty task item\"}`;\n      };\n      updateA11Y(node);\n      checkboxWrapper.contentEditable = \"false\";\n      checkbox.type = \"checkbox\";\n      checkbox.addEventListener(\"mousedown\", (event) => event.preventDefault());\n      checkbox.addEventListener(\"change\", (event) => {\n        if (!editor.isEditable && !this.options.onReadOnlyChecked) {\n          checkbox.checked = !checkbox.checked;\n          return;\n        }\n        const { checked } = event.target;\n        if (editor.isEditable && typeof getPos === \"function\") {\n          editor.chain().focus(void 0, { scrollIntoView: false }).command(({ tr }) => {\n            const position = getPos();\n            if (typeof position !== \"number\") {\n              return false;\n            }\n            const currentNode = tr.doc.nodeAt(position);\n            tr.setNodeMarkup(position, void 0, {\n              ...currentNode == null ? void 0 : currentNode.attrs,\n              checked\n            });\n            return true;\n          }).run();\n        }\n        if (!editor.isEditable && this.options.onReadOnlyChecked) {\n          if (!this.options.onReadOnlyChecked(node, checked)) {\n            checkbox.checked = !checkbox.checked;\n          }\n        }\n      });\n      Object.entries(this.options.HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value);\n      });\n      listItem.dataset.checked = node.attrs.checked;\n      checkbox.checked = node.attrs.checked;\n      checkboxWrapper.append(checkbox, checkboxStyler);\n      listItem.append(checkboxWrapper, content);\n      Object.entries(HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value);\n      });\n      return {\n        dom: listItem,\n        contentDOM: content,\n        update: (updatedNode) => {\n          if (updatedNode.type !== this.type) {\n            return false;\n          }\n          listItem.dataset.checked = updatedNode.attrs.checked;\n          checkbox.checked = updatedNode.attrs.checked;\n          updateA11Y(updatedNode);\n          return true;\n        }\n      };\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n        find: inputRegex,\n        type: this.type,\n        getAttributes: (match) => ({\n          checked: match[match.length - 1] === \"x\"\n        })\n      })\n    ];\n  }\n});\n\n// src/task-list/task-list.ts\n\nvar TaskList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"taskList\",\n  addOptions() {\n    return {\n      itemTypeName: \"taskItem\",\n      HTMLAttributes: {}\n    };\n  },\n  group: \"block list\",\n  content() {\n    return `${this.options.itemTypeName}+`;\n  },\n  parseHTML() {\n    return [\n      {\n        tag: `ul[data-type=\"${this.name}\"]`,\n        priority: 51\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"ul\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes, { \"data-type\": this.name }), 0];\n  },\n  parseMarkdown: (token, h) => {\n    return h.createNode(\"taskList\", {}, h.parseChildren(token.items || []));\n  },\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return \"\";\n    }\n    return h.renderChildren(node.content, \"\\n\");\n  },\n  markdownTokenizer: {\n    name: \"taskList\",\n    level: \"block\",\n    start(src) {\n      var _a;\n      const index = (_a = src.match(/^\\s*[-+*]\\s+\\[([ xX])\\]\\s+/)) == null ? void 0 : _a.index;\n      return index !== void 0 ? index : -1;\n    },\n    tokenize(src, tokens, lexer) {\n      const parseTaskListContent = (content) => {\n        const nestedResult = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.parseIndentedBlocks)(\n          content,\n          {\n            itemPattern: /^(\\s*)([-+*])\\s+\\[([ xX])\\]\\s+(.*)$/,\n            extractItemData: (match) => ({\n              indentLevel: match[1].length,\n              mainContent: match[4],\n              checked: match[3].toLowerCase() === \"x\"\n            }),\n            createToken: (data, nestedTokens) => ({\n              type: \"taskItem\",\n              raw: \"\",\n              mainContent: data.mainContent,\n              indentLevel: data.indentLevel,\n              checked: data.checked,\n              text: data.mainContent,\n              tokens: lexer.inlineTokens(data.mainContent),\n              nestedTokens\n            }),\n            // Allow recursive nesting\n            customNestedParser: parseTaskListContent\n          },\n          lexer\n        );\n        if (nestedResult) {\n          return [\n            {\n              type: \"taskList\",\n              raw: nestedResult.raw,\n              items: nestedResult.items\n            }\n          ];\n        }\n        return lexer.blockTokens(content);\n      };\n      const result = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.parseIndentedBlocks)(\n        src,\n        {\n          itemPattern: /^(\\s*)([-+*])\\s+\\[([ xX])\\]\\s+(.*)$/,\n          extractItemData: (match) => ({\n            indentLevel: match[1].length,\n            mainContent: match[4],\n            checked: match[3].toLowerCase() === \"x\"\n          }),\n          createToken: (data, nestedTokens) => ({\n            type: \"taskItem\",\n            raw: \"\",\n            mainContent: data.mainContent,\n            indentLevel: data.indentLevel,\n            checked: data.checked,\n            text: data.mainContent,\n            tokens: lexer.inlineTokens(data.mainContent),\n            nestedTokens\n          }),\n          // Use the recursive parser for nested content\n          customNestedParser: parseTaskListContent\n        },\n        lexer\n      );\n      if (!result) {\n        return void 0;\n      }\n      return {\n        type: \"taskList\",\n        raw: result.raw,\n        items: result.items\n      };\n    }\n  },\n  markdownOptions: {\n    indentsContent: true\n  },\n  addCommands() {\n    return {\n      toggleTaskList: () => ({ commands }) => {\n        return commands.toggleList(this.name, this.options.itemTypeName);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-9\": () => this.editor.commands.toggleTaskList()\n    };\n  }\n});\n\n// src/kit/index.ts\nvar ListKit = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Extension.create({\n  name: \"listKit\",\n  addExtensions() {\n    const extensions = [];\n    if (this.options.bulletList !== false) {\n      extensions.push(BulletList.configure(this.options.bulletList));\n    }\n    if (this.options.listItem !== false) {\n      extensions.push(ListItem.configure(this.options.listItem));\n    }\n    if (this.options.listKeymap !== false) {\n      extensions.push(ListKeymap.configure(this.options.listKeymap));\n    }\n    if (this.options.orderedList !== false) {\n      extensions.push(OrderedList.configure(this.options.orderedList));\n    }\n    if (this.options.taskItem !== false) {\n      extensions.push(TaskItem.configure(this.options.taskItem));\n    }\n    if (this.options.taskList !== false) {\n      extensions.push(TaskList.configure(this.options.taskList));\n    }\n    return extensions;\n  }\n});\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGlzdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7O0FBRUE7QUFDd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhDQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsY0FBYywwQkFBMEI7QUFDeEMsR0FBRztBQUNIO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCLEdBQUc7QUFDSCxlQUFlLGdCQUFnQjtBQUMvQixrQkFBa0IsNkRBQWU7QUFDakMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esb0JBQW9CLCtEQUFpQjtBQUNyQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0JBQWtCLCtEQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUMrRztBQUMvRyxlQUFlLDhDQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxlQUFlLGdCQUFnQjtBQUMvQixrQkFBa0IsNkRBQWdCO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlFQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLCtCQUErQixVQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsbURBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFhQztBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvbW9ydG9ubWFidW1iby9Eb3dubG9hZHMvdGVzdGltaW5vbnktd2ViMV8xMC1tYWluL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1saXN0L2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gc3JjL2J1bGxldC1saXN0L2J1bGxldC1saXN0LnRzXG5pbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUsIHdyYXBwaW5nSW5wdXRSdWxlIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xudmFyIExpc3RJdGVtTmFtZSA9IFwibGlzdEl0ZW1cIjtcbnZhciBUZXh0U3R5bGVOYW1lID0gXCJ0ZXh0U3R5bGVcIjtcbnZhciBidWxsZXRMaXN0SW5wdXRSZWdleCA9IC9eXFxzKihbLSsqXSlcXHMkLztcbnZhciBCdWxsZXRMaXN0ID0gTm9kZS5jcmVhdGUoe1xuICBuYW1lOiBcImJ1bGxldExpc3RcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbVR5cGVOYW1lOiBcImxpc3RJdGVtXCIsXG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICBrZWVwTWFya3M6IGZhbHNlLFxuICAgICAga2VlcEF0dHJpYnV0ZXM6IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgZ3JvdXA6IFwiYmxvY2sgbGlzdFwiLFxuICBjb250ZW50KCkge1xuICAgIHJldHVybiBgJHt0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lfStgO1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFt7IHRhZzogXCJ1bFwiIH1dO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbXCJ1bFwiLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICB9LFxuICBtYXJrZG93blRva2VuTmFtZTogXCJsaXN0XCIsXG4gIHBhcnNlTWFya2Rvd246ICh0b2tlbiwgaGVscGVycykgPT4ge1xuICAgIGlmICh0b2tlbi50eXBlICE9PSBcImxpc3RcIiB8fCB0b2tlbi5vcmRlcmVkKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImJ1bGxldExpc3RcIixcbiAgICAgIGNvbnRlbnQ6IHRva2VuLml0ZW1zID8gaGVscGVycy5wYXJzZUNoaWxkcmVuKHRva2VuLml0ZW1zKSA6IFtdXG4gICAgfTtcbiAgfSxcbiAgcmVuZGVyTWFya2Rvd246IChub2RlLCBoKSA9PiB7XG4gICAgaWYgKCFub2RlLmNvbnRlbnQpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gaC5yZW5kZXJDaGlsZHJlbihub2RlLmNvbnRlbnQsIFwiXFxuXCIpO1xuICB9LFxuICBtYXJrZG93bk9wdGlvbnM6IHtcbiAgICBpbmRlbnRzQ29udGVudDogdHJ1ZVxuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9nZ2xlQnVsbGV0TGlzdDogKCkgPT4gKHsgY29tbWFuZHMsIGNoYWluIH0pID0+IHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgICAgIHJldHVybiBjaGFpbigpLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lLCB0aGlzLm9wdGlvbnMua2VlcE1hcmtzKS51cGRhdGVBdHRyaWJ1dGVzKExpc3RJdGVtTmFtZSwgdGhpcy5lZGl0b3IuZ2V0QXR0cmlidXRlcyhUZXh0U3R5bGVOYW1lKSkucnVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lLCB0aGlzLm9wdGlvbnMua2VlcE1hcmtzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJNb2QtU2hpZnQtOFwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCdWxsZXRMaXN0KClcbiAgICB9O1xuICB9LFxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIGxldCBpbnB1dFJ1bGUgPSB3cmFwcGluZ0lucHV0UnVsZSh7XG4gICAgICBmaW5kOiBidWxsZXRMaXN0SW5wdXRSZWdleCxcbiAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgIH0pO1xuICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcE1hcmtzIHx8IHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgaW5wdXRSdWxlID0gd3JhcHBpbmdJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBidWxsZXRMaXN0SW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBrZWVwTWFya3M6IHRoaXMub3B0aW9ucy5rZWVwTWFya3MsXG4gICAgICAgIGtlZXBBdHRyaWJ1dGVzOiB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3IuZ2V0QXR0cmlidXRlcyhUZXh0U3R5bGVOYW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvclxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBbaW5wdXRSdWxlXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9pdGVtL2xpc3QtaXRlbS50c1xuaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzIGFzIG1lcmdlQXR0cmlidXRlczIsIE5vZGUgYXMgTm9kZTIsIHJlbmRlck5lc3RlZE1hcmtkb3duQ29udGVudCB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBMaXN0SXRlbSA9IE5vZGUyLmNyZWF0ZSh7XG4gIG5hbWU6IFwibGlzdEl0ZW1cIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgYnVsbGV0TGlzdFR5cGVOYW1lOiBcImJ1bGxldExpc3RcIixcbiAgICAgIG9yZGVyZWRMaXN0VHlwZU5hbWU6IFwib3JkZXJlZExpc3RcIlxuICAgIH07XG4gIH0sXG4gIGNvbnRlbnQ6IFwicGFyYWdyYXBoIGJsb2NrKlwiLFxuICBkZWZpbmluZzogdHJ1ZSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJsaVwiXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gW1wibGlcIiwgbWVyZ2VBdHRyaWJ1dGVzMih0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gIH0sXG4gIG1hcmtkb3duVG9rZW5OYW1lOiBcImxpc3RfaXRlbVwiLFxuICBwYXJzZU1hcmtkb3duOiAodG9rZW4sIGhlbHBlcnMpID0+IHtcbiAgICBpZiAodG9rZW4udHlwZSAhPT0gXCJsaXN0X2l0ZW1cIikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBsZXQgY29udGVudCA9IFtdO1xuICAgIGlmICh0b2tlbi50b2tlbnMgJiYgdG9rZW4udG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGhhc1BhcmFncmFwaFRva2VucyA9IHRva2VuLnRva2Vucy5zb21lKCh0KSA9PiB0LnR5cGUgPT09IFwicGFyYWdyYXBoXCIpO1xuICAgICAgaWYgKGhhc1BhcmFncmFwaFRva2Vucykge1xuICAgICAgICBjb250ZW50ID0gaGVscGVycy5wYXJzZUNoaWxkcmVuKHRva2VuLnRva2Vucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBmaXJzdFRva2VuID0gdG9rZW4udG9rZW5zWzBdO1xuICAgICAgICBpZiAoZmlyc3RUb2tlbiAmJiBmaXJzdFRva2VuLnR5cGUgPT09IFwidGV4dFwiICYmIGZpcnN0VG9rZW4udG9rZW5zICYmIGZpcnN0VG9rZW4udG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBpbmxpbmVDb250ZW50ID0gaGVscGVycy5wYXJzZUlubGluZShmaXJzdFRva2VuLnRva2Vucyk7XG4gICAgICAgICAgY29udGVudCA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJwYXJhZ3JhcGhcIixcbiAgICAgICAgICAgICAgY29udGVudDogaW5saW5lQ29udGVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgIF07XG4gICAgICAgICAgaWYgKHRva2VuLnRva2Vucy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCByZW1haW5pbmdUb2tlbnMgPSB0b2tlbi50b2tlbnMuc2xpY2UoMSk7XG4gICAgICAgICAgICBjb25zdCBhZGRpdGlvbmFsQ29udGVudCA9IGhlbHBlcnMucGFyc2VDaGlsZHJlbihyZW1haW5pbmdUb2tlbnMpO1xuICAgICAgICAgICAgY29udGVudC5wdXNoKC4uLmFkZGl0aW9uYWxDb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGVudCA9IGhlbHBlcnMucGFyc2VDaGlsZHJlbih0b2tlbi50b2tlbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb250ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29udGVudCA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwicGFyYWdyYXBoXCIsXG4gICAgICAgICAgY29udGVudDogW11cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibGlzdEl0ZW1cIixcbiAgICAgIGNvbnRlbnRcbiAgICB9O1xuICB9LFxuICByZW5kZXJNYXJrZG93bjogKG5vZGUsIGgsIGN0eCkgPT4ge1xuICAgIHJldHVybiByZW5kZXJOZXN0ZWRNYXJrZG93bkNvbnRlbnQoXG4gICAgICBub2RlLFxuICAgICAgaCxcbiAgICAgIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGlmIChjb250ZXh0LnBhcmVudFR5cGUgPT09IFwiYnVsbGV0TGlzdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIFwiLSBcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dC5wYXJlbnRUeXBlID09PSBcIm9yZGVyZWRMaXN0XCIpIHtcbiAgICAgICAgICByZXR1cm4gYCR7Y29udGV4dC5pbmRleCArIDF9LiBgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIi0gXCI7XG4gICAgICB9LFxuICAgICAgY3R4XG4gICAgKTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEVudGVyOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zcGxpdExpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgICBUYWI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNpbmtMaXN0SXRlbSh0aGlzLm5hbWUpLFxuICAgICAgXCJTaGlmdC1UYWJcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMubGlmdExpc3RJdGVtKHRoaXMubmFtZSlcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2tleW1hcC9saXN0LWtleW1hcC50c1xuaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuXG4vLyBzcmMva2V5bWFwL2xpc3RIZWxwZXJzL2luZGV4LnRzXG52YXIgbGlzdEhlbHBlcnNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobGlzdEhlbHBlcnNfZXhwb3J0cywge1xuICBmaW5kTGlzdEl0ZW1Qb3M6ICgpID0+IGZpbmRMaXN0SXRlbVBvcyxcbiAgZ2V0TmV4dExpc3REZXB0aDogKCkgPT4gZ2V0TmV4dExpc3REZXB0aCxcbiAgaGFuZGxlQmFja3NwYWNlOiAoKSA9PiBoYW5kbGVCYWNrc3BhY2UsXG4gIGhhbmRsZURlbGV0ZTogKCkgPT4gaGFuZGxlRGVsZXRlLFxuICBoYXNMaXN0QmVmb3JlOiAoKSA9PiBoYXNMaXN0QmVmb3JlLFxuICBoYXNMaXN0SXRlbUFmdGVyOiAoKSA9PiBoYXNMaXN0SXRlbUFmdGVyLFxuICBoYXNMaXN0SXRlbUJlZm9yZTogKCkgPT4gaGFzTGlzdEl0ZW1CZWZvcmUsXG4gIGxpc3RJdGVtSGFzU3ViTGlzdDogKCkgPT4gbGlzdEl0ZW1IYXNTdWJMaXN0LFxuICBuZXh0TGlzdElzRGVlcGVyOiAoKSA9PiBuZXh0TGlzdElzRGVlcGVyLFxuICBuZXh0TGlzdElzSGlnaGVyOiAoKSA9PiBuZXh0TGlzdElzSGlnaGVyXG59KTtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9maW5kTGlzdEl0ZW1Qb3MudHNcbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xudmFyIGZpbmRMaXN0SXRlbVBvcyA9ICh0eXBlT3JOYW1lLCBzdGF0ZSkgPT4ge1xuICBjb25zdCB7ICRmcm9tIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gIGNvbnN0IG5vZGVUeXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgbGV0IGN1cnJlbnROb2RlID0gbnVsbDtcbiAgbGV0IGN1cnJlbnREZXB0aCA9ICRmcm9tLmRlcHRoO1xuICBsZXQgY3VycmVudFBvcyA9ICRmcm9tLnBvcztcbiAgbGV0IHRhcmdldERlcHRoID0gbnVsbDtcbiAgd2hpbGUgKGN1cnJlbnREZXB0aCA+IDAgJiYgdGFyZ2V0RGVwdGggPT09IG51bGwpIHtcbiAgICBjdXJyZW50Tm9kZSA9ICRmcm9tLm5vZGUoY3VycmVudERlcHRoKTtcbiAgICBpZiAoY3VycmVudE5vZGUudHlwZSA9PT0gbm9kZVR5cGUpIHtcbiAgICAgIHRhcmdldERlcHRoID0gY3VycmVudERlcHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50RGVwdGggLT0gMTtcbiAgICAgIGN1cnJlbnRQb3MgLT0gMTtcbiAgICB9XG4gIH1cbiAgaWYgKHRhcmdldERlcHRoID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHsgJHBvczogc3RhdGUuZG9jLnJlc29sdmUoY3VycmVudFBvcyksIGRlcHRoOiB0YXJnZXREZXB0aCB9O1xufTtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9nZXROZXh0TGlzdERlcHRoLnRzXG5pbXBvcnQgeyBnZXROb2RlQXRQb3NpdGlvbiB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBnZXROZXh0TGlzdERlcHRoID0gKHR5cGVPck5hbWUsIHN0YXRlKSA9PiB7XG4gIGNvbnN0IGxpc3RJdGVtUG9zID0gZmluZExpc3RJdGVtUG9zKHR5cGVPck5hbWUsIHN0YXRlKTtcbiAgaWYgKCFsaXN0SXRlbVBvcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBbLCBkZXB0aF0gPSBnZXROb2RlQXRQb3NpdGlvbihzdGF0ZSwgdHlwZU9yTmFtZSwgbGlzdEl0ZW1Qb3MuJHBvcy5wb3MgKyA0KTtcbiAgcmV0dXJuIGRlcHRoO1xufTtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9oYW5kbGVCYWNrc3BhY2UudHNcbmltcG9ydCB7IGlzQXRTdGFydE9mTm9kZSwgaXNOb2RlQWN0aXZlIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuXG4vLyBzcmMva2V5bWFwL2xpc3RIZWxwZXJzL2hhc0xpc3RCZWZvcmUudHNcbnZhciBoYXNMaXN0QmVmb3JlID0gKGVkaXRvclN0YXRlLCBuYW1lLCBwYXJlbnRMaXN0VHlwZXMpID0+IHtcbiAgY29uc3QgeyAkYW5jaG9yIH0gPSBlZGl0b3JTdGF0ZS5zZWxlY3Rpb247XG4gIGNvbnN0IHByZXZpb3VzTm9kZVBvcyA9IE1hdGgubWF4KDAsICRhbmNob3IucG9zIC0gMik7XG4gIGNvbnN0IHByZXZpb3VzTm9kZSA9IGVkaXRvclN0YXRlLmRvYy5yZXNvbHZlKHByZXZpb3VzTm9kZVBvcykubm9kZSgpO1xuICBpZiAoIXByZXZpb3VzTm9kZSB8fCAhcGFyZW50TGlzdFR5cGVzLmluY2x1ZGVzKHByZXZpb3VzTm9kZS50eXBlLm5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9oYXNMaXN0SXRlbUJlZm9yZS50c1xudmFyIGhhc0xpc3RJdGVtQmVmb3JlID0gKHR5cGVPck5hbWUsIHN0YXRlKSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgeyAkYW5jaG9yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gIGNvbnN0ICR0YXJnZXRQb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZSgkYW5jaG9yLnBvcyAtIDIpO1xuICBpZiAoJHRhcmdldFBvcy5pbmRleCgpID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgoKF9hID0gJHRhcmdldFBvcy5ub2RlQmVmb3JlKSA9PSBudWxsID8gdm9pZCAwIDogX2EudHlwZS5uYW1lKSAhPT0gdHlwZU9yTmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9rZXltYXAvbGlzdEhlbHBlcnMvbGlzdEl0ZW1IYXNTdWJMaXN0LnRzXG5pbXBvcnQgeyBnZXROb2RlVHlwZSBhcyBnZXROb2RlVHlwZTIgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgbGlzdEl0ZW1IYXNTdWJMaXN0ID0gKHR5cGVPck5hbWUsIHN0YXRlLCBub2RlKSA9PiB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBub2RlVHlwZSA9IGdldE5vZGVUeXBlMih0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICBsZXQgaGFzU3ViTGlzdCA9IGZhbHNlO1xuICBub2RlLmRlc2NlbmRhbnRzKChjaGlsZCkgPT4ge1xuICAgIGlmIChjaGlsZC50eXBlID09PSBub2RlVHlwZSkge1xuICAgICAgaGFzU3ViTGlzdCA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGhhc1N1Ykxpc3Q7XG59O1xuXG4vLyBzcmMva2V5bWFwL2xpc3RIZWxwZXJzL2hhbmRsZUJhY2tzcGFjZS50c1xudmFyIGhhbmRsZUJhY2tzcGFjZSA9IChlZGl0b3IsIG5hbWUsIHBhcmVudExpc3RUeXBlcykgPT4ge1xuICBpZiAoZWRpdG9yLmNvbW1hbmRzLnVuZG9JbnB1dFJ1bGUoKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLmZyb20gIT09IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24udG8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFpc05vZGVBY3RpdmUoZWRpdG9yLnN0YXRlLCBuYW1lKSAmJiBoYXNMaXN0QmVmb3JlKGVkaXRvci5zdGF0ZSwgbmFtZSwgcGFyZW50TGlzdFR5cGVzKSkge1xuICAgIGNvbnN0IHsgJGFuY2hvciB9ID0gZWRpdG9yLnN0YXRlLnNlbGVjdGlvbjtcbiAgICBjb25zdCAkbGlzdFBvcyA9IGVkaXRvci5zdGF0ZS5kb2MucmVzb2x2ZSgkYW5jaG9yLmJlZm9yZSgpIC0gMSk7XG4gICAgY29uc3QgbGlzdERlc2NlbmRhbnRzID0gW107XG4gICAgJGxpc3RQb3Mubm9kZSgpLmRlc2NlbmRhbnRzKChub2RlLCBwb3MpID0+IHtcbiAgICAgIGlmIChub2RlLnR5cGUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICBsaXN0RGVzY2VuZGFudHMucHVzaCh7IG5vZGUsIHBvcyB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBsYXN0SXRlbSA9IGxpc3REZXNjZW5kYW50cy5hdCgtMSk7XG4gICAgaWYgKCFsYXN0SXRlbSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCAkbGFzdEl0ZW1Qb3MgPSBlZGl0b3Iuc3RhdGUuZG9jLnJlc29sdmUoJGxpc3RQb3Muc3RhcnQoKSArIGxhc3RJdGVtLnBvcyArIDEpO1xuICAgIHJldHVybiBlZGl0b3IuY2hhaW4oKS5jdXQoeyBmcm9tOiAkYW5jaG9yLnN0YXJ0KCkgLSAxLCB0bzogJGFuY2hvci5lbmQoKSArIDEgfSwgJGxhc3RJdGVtUG9zLmVuZCgpKS5qb2luRm9yd2FyZCgpLnJ1bigpO1xuICB9XG4gIGlmICghaXNOb2RlQWN0aXZlKGVkaXRvci5zdGF0ZSwgbmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFpc0F0U3RhcnRPZk5vZGUoZWRpdG9yLnN0YXRlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBsaXN0SXRlbVBvcyA9IGZpbmRMaXN0SXRlbVBvcyhuYW1lLCBlZGl0b3Iuc3RhdGUpO1xuICBpZiAoIWxpc3RJdGVtUG9zKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0ICRwcmV2ID0gZWRpdG9yLnN0YXRlLmRvYy5yZXNvbHZlKGxpc3RJdGVtUG9zLiRwb3MucG9zIC0gMik7XG4gIGNvbnN0IHByZXZOb2RlID0gJHByZXYubm9kZShsaXN0SXRlbVBvcy5kZXB0aCk7XG4gIGNvbnN0IHByZXZpb3VzTGlzdEl0ZW1IYXNTdWJMaXN0ID0gbGlzdEl0ZW1IYXNTdWJMaXN0KG5hbWUsIGVkaXRvci5zdGF0ZSwgcHJldk5vZGUpO1xuICBpZiAoaGFzTGlzdEl0ZW1CZWZvcmUobmFtZSwgZWRpdG9yLnN0YXRlKSAmJiAhcHJldmlvdXNMaXN0SXRlbUhhc1N1Ykxpc3QpIHtcbiAgICByZXR1cm4gZWRpdG9yLmNvbW1hbmRzLmpvaW5JdGVtQmFja3dhcmQoKTtcbiAgfVxuICByZXR1cm4gZWRpdG9yLmNoYWluKCkubGlmdExpc3RJdGVtKG5hbWUpLnJ1bigpO1xufTtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9oYW5kbGVEZWxldGUudHNcbmltcG9ydCB7IGlzQXRFbmRPZk5vZGUsIGlzTm9kZUFjdGl2ZSBhcyBpc05vZGVBY3RpdmUyIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuXG4vLyBzcmMva2V5bWFwL2xpc3RIZWxwZXJzL25leHRMaXN0SXNEZWVwZXIudHNcbnZhciBuZXh0TGlzdElzRGVlcGVyID0gKHR5cGVPck5hbWUsIHN0YXRlKSA9PiB7XG4gIGNvbnN0IGxpc3REZXB0aCA9IGdldE5leHRMaXN0RGVwdGgodHlwZU9yTmFtZSwgc3RhdGUpO1xuICBjb25zdCBsaXN0SXRlbVBvcyA9IGZpbmRMaXN0SXRlbVBvcyh0eXBlT3JOYW1lLCBzdGF0ZSk7XG4gIGlmICghbGlzdEl0ZW1Qb3MgfHwgIWxpc3REZXB0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobGlzdERlcHRoID4gbGlzdEl0ZW1Qb3MuZGVwdGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBzcmMva2V5bWFwL2xpc3RIZWxwZXJzL25leHRMaXN0SXNIaWdoZXIudHNcbnZhciBuZXh0TGlzdElzSGlnaGVyID0gKHR5cGVPck5hbWUsIHN0YXRlKSA9PiB7XG4gIGNvbnN0IGxpc3REZXB0aCA9IGdldE5leHRMaXN0RGVwdGgodHlwZU9yTmFtZSwgc3RhdGUpO1xuICBjb25zdCBsaXN0SXRlbVBvcyA9IGZpbmRMaXN0SXRlbVBvcyh0eXBlT3JOYW1lLCBzdGF0ZSk7XG4gIGlmICghbGlzdEl0ZW1Qb3MgfHwgIWxpc3REZXB0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobGlzdERlcHRoIDwgbGlzdEl0ZW1Qb3MuZGVwdGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBzcmMva2V5bWFwL2xpc3RIZWxwZXJzL2hhbmRsZURlbGV0ZS50c1xudmFyIGhhbmRsZURlbGV0ZSA9IChlZGl0b3IsIG5hbWUpID0+IHtcbiAgaWYgKCFpc05vZGVBY3RpdmUyKGVkaXRvci5zdGF0ZSwgbmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFpc0F0RW5kT2ZOb2RlKGVkaXRvci5zdGF0ZSwgbmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IGVkaXRvci5zdGF0ZTtcbiAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzZWxlY3Rpb247XG4gIGlmICghc2VsZWN0aW9uLmVtcHR5ICYmICRmcm9tLnNhbWVQYXJlbnQoJHRvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobmV4dExpc3RJc0RlZXBlcihuYW1lLCBlZGl0b3Iuc3RhdGUpKSB7XG4gICAgcmV0dXJuIGVkaXRvci5jaGFpbigpLmZvY3VzKGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uZnJvbSArIDQpLmxpZnQobmFtZSkuam9pbkJhY2t3YXJkKCkucnVuKCk7XG4gIH1cbiAgaWYgKG5leHRMaXN0SXNIaWdoZXIobmFtZSwgZWRpdG9yLnN0YXRlKSkge1xuICAgIHJldHVybiBlZGl0b3IuY2hhaW4oKS5qb2luRm9yd2FyZCgpLmpvaW5CYWNrd2FyZCgpLnJ1bigpO1xuICB9XG4gIHJldHVybiBlZGl0b3IuY29tbWFuZHMuam9pbkl0ZW1Gb3J3YXJkKCk7XG59O1xuXG4vLyBzcmMva2V5bWFwL2xpc3RIZWxwZXJzL2hhc0xpc3RJdGVtQWZ0ZXIudHNcbnZhciBoYXNMaXN0SXRlbUFmdGVyID0gKHR5cGVPck5hbWUsIHN0YXRlKSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgeyAkYW5jaG9yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gIGNvbnN0ICR0YXJnZXRQb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZSgkYW5jaG9yLnBvcyAtICRhbmNob3IucGFyZW50T2Zmc2V0IC0gMik7XG4gIGlmICgkdGFyZ2V0UG9zLmluZGV4KCkgPT09ICR0YXJnZXRQb3MucGFyZW50LmNoaWxkQ291bnQgLSAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgoKF9hID0gJHRhcmdldFBvcy5ub2RlQWZ0ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYS50eXBlLm5hbWUpICE9PSB0eXBlT3JOYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2tleW1hcC9saXN0LWtleW1hcC50c1xudmFyIExpc3RLZXltYXAgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogXCJsaXN0S2V5bWFwXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpc3RUeXBlczogW1xuICAgICAgICB7XG4gICAgICAgICAgaXRlbU5hbWU6IFwibGlzdEl0ZW1cIixcbiAgICAgICAgICB3cmFwcGVyTmFtZXM6IFtcImJ1bGxldExpc3RcIiwgXCJvcmRlcmVkTGlzdFwiXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaXRlbU5hbWU6IFwidGFza0l0ZW1cIixcbiAgICAgICAgICB3cmFwcGVyTmFtZXM6IFtcInRhc2tMaXN0XCJdXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9O1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgRGVsZXRlOiAoeyBlZGl0b3IgfSkgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9wdGlvbnMubGlzdFR5cGVzLmZvckVhY2goKHsgaXRlbU5hbWUgfSkgPT4ge1xuICAgICAgICAgIGlmIChlZGl0b3Iuc3RhdGUuc2NoZW1hLm5vZGVzW2l0ZW1OYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYW5kbGVEZWxldGUoZWRpdG9yLCBpdGVtTmFtZSkpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVkO1xuICAgICAgfSxcbiAgICAgIFwiTW9kLURlbGV0ZVwiOiAoeyBlZGl0b3IgfSkgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9wdGlvbnMubGlzdFR5cGVzLmZvckVhY2goKHsgaXRlbU5hbWUgfSkgPT4ge1xuICAgICAgICAgIGlmIChlZGl0b3Iuc3RhdGUuc2NoZW1hLm5vZGVzW2l0ZW1OYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYW5kbGVEZWxldGUoZWRpdG9yLCBpdGVtTmFtZSkpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVkO1xuICAgICAgfSxcbiAgICAgIEJhY2tzcGFjZTogKHsgZWRpdG9yIH0pID0+IHtcbiAgICAgICAgbGV0IGhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmxpc3RUeXBlcy5mb3JFYWNoKCh7IGl0ZW1OYW1lLCB3cmFwcGVyTmFtZXMgfSkgPT4ge1xuICAgICAgICAgIGlmIChlZGl0b3Iuc3RhdGUuc2NoZW1hLm5vZGVzW2l0ZW1OYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYW5kbGVCYWNrc3BhY2UoZWRpdG9yLCBpdGVtTmFtZSwgd3JhcHBlck5hbWVzKSkge1xuICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZWQ7XG4gICAgICB9LFxuICAgICAgXCJNb2QtQmFja3NwYWNlXCI6ICh7IGVkaXRvciB9KSA9PiB7XG4gICAgICAgIGxldCBoYW5kbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3B0aW9ucy5saXN0VHlwZXMuZm9yRWFjaCgoeyBpdGVtTmFtZSwgd3JhcHBlck5hbWVzIH0pID0+IHtcbiAgICAgICAgICBpZiAoZWRpdG9yLnN0YXRlLnNjaGVtYS5ub2Rlc1tpdGVtTmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlQmFja3NwYWNlKGVkaXRvciwgaXRlbU5hbWUsIHdyYXBwZXJOYW1lcykpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVkO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMva2l0L2luZGV4LnRzXG5pbXBvcnQgeyBFeHRlbnNpb24gYXMgRXh0ZW5zaW9uMiB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcblxuLy8gc3JjL29yZGVyZWQtbGlzdC9vcmRlcmVkLWxpc3QudHNcbmltcG9ydCB7IG1lcmdlQXR0cmlidXRlcyBhcyBtZXJnZUF0dHJpYnV0ZXMzLCBOb2RlIGFzIE5vZGUzLCB3cmFwcGluZ0lucHV0UnVsZSBhcyB3cmFwcGluZ0lucHV0UnVsZTIgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5cbi8vIHNyYy9vcmRlcmVkLWxpc3QvdXRpbHMudHNcbnZhciBPUkRFUkVEX0xJU1RfSVRFTV9SRUdFWCA9IC9eKFxccyopKFxcZCspXFwuXFxzKyguKikkLztcbnZhciBJTkRFTlRFRF9MSU5FX1JFR0VYID0gL15cXHMvO1xuZnVuY3Rpb24gY29sbGVjdE9yZGVyZWRMaXN0SXRlbXMobGluZXMpIHtcbiAgY29uc3QgbGlzdEl0ZW1zID0gW107XG4gIGxldCBjdXJyZW50TGluZUluZGV4ID0gMDtcbiAgbGV0IGNvbnN1bWVkID0gMDtcbiAgd2hpbGUgKGN1cnJlbnRMaW5lSW5kZXggPCBsaW5lcy5sZW5ndGgpIHtcbiAgICBjb25zdCBsaW5lID0gbGluZXNbY3VycmVudExpbmVJbmRleF07XG4gICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKE9SREVSRURfTElTVF9JVEVNX1JFR0VYKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgWywgaW5kZW50LCBudW1iZXIsIGNvbnRlbnRdID0gbWF0Y2g7XG4gICAgY29uc3QgaW5kZW50TGV2ZWwgPSBpbmRlbnQubGVuZ3RoO1xuICAgIGxldCBpdGVtQ29udGVudCA9IGNvbnRlbnQ7XG4gICAgbGV0IG5leHRMaW5lSW5kZXggPSBjdXJyZW50TGluZUluZGV4ICsgMTtcbiAgICBjb25zdCBpdGVtTGluZXMgPSBbbGluZV07XG4gICAgd2hpbGUgKG5leHRMaW5lSW5kZXggPCBsaW5lcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG5leHRMaW5lID0gbGluZXNbbmV4dExpbmVJbmRleF07XG4gICAgICBjb25zdCBuZXh0TWF0Y2ggPSBuZXh0TGluZS5tYXRjaChPUkRFUkVEX0xJU1RfSVRFTV9SRUdFWCk7XG4gICAgICBpZiAobmV4dE1hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKG5leHRMaW5lLnRyaW0oKSA9PT0gXCJcIikge1xuICAgICAgICBpdGVtTGluZXMucHVzaChuZXh0TGluZSk7XG4gICAgICAgIGl0ZW1Db250ZW50ICs9IFwiXFxuXCI7XG4gICAgICAgIG5leHRMaW5lSW5kZXggKz0gMTtcbiAgICAgIH0gZWxzZSBpZiAobmV4dExpbmUubWF0Y2goSU5ERU5URURfTElORV9SRUdFWCkpIHtcbiAgICAgICAgaXRlbUxpbmVzLnB1c2gobmV4dExpbmUpO1xuICAgICAgICBpdGVtQ29udGVudCArPSBgXG4ke25leHRMaW5lLnNsaWNlKGluZGVudExldmVsICsgMil9YDtcbiAgICAgICAgbmV4dExpbmVJbmRleCArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGxpc3RJdGVtcy5wdXNoKHtcbiAgICAgIGluZGVudDogaW5kZW50TGV2ZWwsXG4gICAgICBudW1iZXI6IHBhcnNlSW50KG51bWJlciwgMTApLFxuICAgICAgY29udGVudDogaXRlbUNvbnRlbnQudHJpbSgpLFxuICAgICAgcmF3OiBpdGVtTGluZXMuam9pbihcIlxcblwiKVxuICAgIH0pO1xuICAgIGNvbnN1bWVkID0gbmV4dExpbmVJbmRleDtcbiAgICBjdXJyZW50TGluZUluZGV4ID0gbmV4dExpbmVJbmRleDtcbiAgfVxuICByZXR1cm4gW2xpc3RJdGVtcywgY29uc3VtZWRdO1xufVxuZnVuY3Rpb24gYnVpbGROZXN0ZWRTdHJ1Y3R1cmUoaXRlbXMsIGJhc2VJbmRlbnQsIGxleGVyKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBjdXJyZW50SW5kZXggPSAwO1xuICB3aGlsZSAoY3VycmVudEluZGV4IDwgaXRlbXMubGVuZ3RoKSB7XG4gICAgY29uc3QgaXRlbSA9IGl0ZW1zW2N1cnJlbnRJbmRleF07XG4gICAgaWYgKGl0ZW0uaW5kZW50ID09PSBiYXNlSW5kZW50KSB7XG4gICAgICBjb25zdCBjb250ZW50TGluZXMgPSBpdGVtLmNvbnRlbnQuc3BsaXQoXCJcXG5cIik7XG4gICAgICBjb25zdCBtYWluVGV4dCA9ICgoX2EgPSBjb250ZW50TGluZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS50cmltKCkpIHx8IFwiXCI7XG4gICAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICAgIGlmIChtYWluVGV4dCkge1xuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJwYXJhZ3JhcGhcIixcbiAgICAgICAgICByYXc6IG1haW5UZXh0LFxuICAgICAgICAgIHRva2VuczogbGV4ZXIuaW5saW5lVG9rZW5zKG1haW5UZXh0KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFkZGl0aW9uYWxDb250ZW50ID0gY29udGVudExpbmVzLnNsaWNlKDEpLmpvaW4oXCJcXG5cIikudHJpbSgpO1xuICAgICAgaWYgKGFkZGl0aW9uYWxDb250ZW50KSB7XG4gICAgICAgIGNvbnN0IGJsb2NrVG9rZW5zID0gbGV4ZXIuYmxvY2tUb2tlbnMoYWRkaXRpb25hbENvbnRlbnQpO1xuICAgICAgICB0b2tlbnMucHVzaCguLi5ibG9ja1Rva2Vucyk7XG4gICAgICB9XG4gICAgICBsZXQgbG9va0FoZWFkSW5kZXggPSBjdXJyZW50SW5kZXggKyAxO1xuICAgICAgY29uc3QgbmVzdGVkSXRlbXMgPSBbXTtcbiAgICAgIHdoaWxlIChsb29rQWhlYWRJbmRleCA8IGl0ZW1zLmxlbmd0aCAmJiBpdGVtc1tsb29rQWhlYWRJbmRleF0uaW5kZW50ID4gYmFzZUluZGVudCkge1xuICAgICAgICBuZXN0ZWRJdGVtcy5wdXNoKGl0ZW1zW2xvb2tBaGVhZEluZGV4XSk7XG4gICAgICAgIGxvb2tBaGVhZEluZGV4ICs9IDE7XG4gICAgICB9XG4gICAgICBpZiAobmVzdGVkSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBuZXh0SW5kZW50ID0gTWF0aC5taW4oLi4ubmVzdGVkSXRlbXMubWFwKChuZXN0ZWRJdGVtKSA9PiBuZXN0ZWRJdGVtLmluZGVudCkpO1xuICAgICAgICBjb25zdCBuZXN0ZWRMaXN0SXRlbXMgPSBidWlsZE5lc3RlZFN0cnVjdHVyZShuZXN0ZWRJdGVtcywgbmV4dEluZGVudCwgbGV4ZXIpO1xuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJsaXN0XCIsXG4gICAgICAgICAgb3JkZXJlZDogdHJ1ZSxcbiAgICAgICAgICBzdGFydDogbmVzdGVkSXRlbXNbMF0ubnVtYmVyLFxuICAgICAgICAgIGl0ZW1zOiBuZXN0ZWRMaXN0SXRlbXMsXG4gICAgICAgICAgcmF3OiBuZXN0ZWRJdGVtcy5tYXAoKG5lc3RlZEl0ZW0pID0+IG5lc3RlZEl0ZW0ucmF3KS5qb2luKFwiXFxuXCIpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICB0eXBlOiBcImxpc3RfaXRlbVwiLFxuICAgICAgICByYXc6IGl0ZW0ucmF3LFxuICAgICAgICB0b2tlbnNcbiAgICAgIH0pO1xuICAgICAgY3VycmVudEluZGV4ID0gbG9va0FoZWFkSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRJbmRleCArPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VMaXN0SXRlbXMoaXRlbXMsIGhlbHBlcnMpIHtcbiAgcmV0dXJuIGl0ZW1zLm1hcCgoaXRlbSkgPT4ge1xuICAgIGlmIChpdGVtLnR5cGUgIT09IFwibGlzdF9pdGVtXCIpIHtcbiAgICAgIHJldHVybiBoZWxwZXJzLnBhcnNlQ2hpbGRyZW4oW2l0ZW1dKVswXTtcbiAgICB9XG4gICAgY29uc3QgY29udGVudCA9IFtdO1xuICAgIGlmIChpdGVtLnRva2VucyAmJiBpdGVtLnRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICBpdGVtLnRva2Vucy5mb3JFYWNoKChpdGVtVG9rZW4pID0+IHtcbiAgICAgICAgaWYgKGl0ZW1Ub2tlbi50eXBlID09PSBcInBhcmFncmFwaFwiIHx8IGl0ZW1Ub2tlbi50eXBlID09PSBcImxpc3RcIiB8fCBpdGVtVG9rZW4udHlwZSA9PT0gXCJibG9ja3F1b3RlXCIgfHwgaXRlbVRva2VuLnR5cGUgPT09IFwiY29kZVwiKSB7XG4gICAgICAgICAgY29udGVudC5wdXNoKC4uLmhlbHBlcnMucGFyc2VDaGlsZHJlbihbaXRlbVRva2VuXSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW1Ub2tlbi50eXBlID09PSBcInRleHRcIiAmJiBpdGVtVG9rZW4udG9rZW5zKSB7XG4gICAgICAgICAgY29uc3QgaW5saW5lQ29udGVudCA9IGhlbHBlcnMucGFyc2VDaGlsZHJlbihbaXRlbVRva2VuXSk7XG4gICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwicGFyYWdyYXBoXCIsXG4gICAgICAgICAgICBjb250ZW50OiBpbmxpbmVDb250ZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkID0gaGVscGVycy5wYXJzZUNoaWxkcmVuKFtpdGVtVG9rZW5dKTtcbiAgICAgICAgICBpZiAocGFyc2VkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaCguLi5wYXJzZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxpc3RJdGVtXCIsXG4gICAgICBjb250ZW50XG4gICAgfTtcbiAgfSk7XG59XG5cbi8vIHNyYy9vcmRlcmVkLWxpc3Qvb3JkZXJlZC1saXN0LnRzXG52YXIgTGlzdEl0ZW1OYW1lMiA9IFwibGlzdEl0ZW1cIjtcbnZhciBUZXh0U3R5bGVOYW1lMiA9IFwidGV4dFN0eWxlXCI7XG52YXIgb3JkZXJlZExpc3RJbnB1dFJlZ2V4ID0gL14oXFxkKylcXC5cXHMkLztcbnZhciBPcmRlcmVkTGlzdCA9IE5vZGUzLmNyZWF0ZSh7XG4gIG5hbWU6IFwib3JkZXJlZExpc3RcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbVR5cGVOYW1lOiBcImxpc3RJdGVtXCIsXG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICBrZWVwTWFya3M6IGZhbHNlLFxuICAgICAga2VlcEF0dHJpYnV0ZXM6IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgZ3JvdXA6IFwiYmxvY2sgbGlzdFwiLFxuICBjb250ZW50KCkge1xuICAgIHJldHVybiBgJHt0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lfStgO1xuICB9LFxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDoge1xuICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICBwYXJzZUhUTUw6IChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKFwic3RhcnRcIikgPyBwYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZShcInN0YXJ0XCIpIHx8IFwiXCIsIDEwKSA6IDE7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0eXBlOiB7XG4gICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgIHBhcnNlSFRNTDogKGVsZW1lbnQpID0+IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKVxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6IFwib2xcIlxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgY29uc3QgeyBzdGFydCwgLi4uYXR0cmlidXRlc1dpdGhvdXRTdGFydCB9ID0gSFRNTEF0dHJpYnV0ZXM7XG4gICAgcmV0dXJuIHN0YXJ0ID09PSAxID8gW1wib2xcIiwgbWVyZ2VBdHRyaWJ1dGVzMyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXNXaXRob3V0U3RhcnQpLCAwXSA6IFtcIm9sXCIsIG1lcmdlQXR0cmlidXRlczModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICB9LFxuICBtYXJrZG93blRva2VuTmFtZTogXCJsaXN0XCIsXG4gIHBhcnNlTWFya2Rvd246ICh0b2tlbiwgaGVscGVycykgPT4ge1xuICAgIGlmICh0b2tlbi50eXBlICE9PSBcImxpc3RcIiB8fCAhdG9rZW4ub3JkZXJlZCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFZhbHVlID0gdG9rZW4uc3RhcnQgfHwgMTtcbiAgICBjb25zdCBjb250ZW50ID0gdG9rZW4uaXRlbXMgPyBwYXJzZUxpc3RJdGVtcyh0b2tlbi5pdGVtcywgaGVscGVycykgOiBbXTtcbiAgICBpZiAoc3RhcnRWYWx1ZSAhPT0gMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJvcmRlcmVkTGlzdFwiLFxuICAgICAgICBhdHRyczogeyBzdGFydDogc3RhcnRWYWx1ZSB9LFxuICAgICAgICBjb250ZW50XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvcmRlcmVkTGlzdFwiLFxuICAgICAgY29udGVudFxuICAgIH07XG4gIH0sXG4gIHJlbmRlck1hcmtkb3duOiAobm9kZSwgaCkgPT4ge1xuICAgIGlmICghbm9kZS5jb250ZW50KSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGgucmVuZGVyQ2hpbGRyZW4obm9kZS5jb250ZW50LCBcIlxcblwiKTtcbiAgfSxcbiAgbWFya2Rvd25Ub2tlbml6ZXI6IHtcbiAgICBuYW1lOiBcIm9yZGVyZWRMaXN0XCIsXG4gICAgbGV2ZWw6IFwiYmxvY2tcIixcbiAgICBzdGFydDogKHNyYykgPT4ge1xuICAgICAgY29uc3QgbWF0Y2ggPSBzcmMubWF0Y2goL14oXFxzKikoXFxkKylcXC5cXHMrLyk7XG4gICAgICBjb25zdCBpbmRleCA9IG1hdGNoID09IG51bGwgPyB2b2lkIDAgOiBtYXRjaC5pbmRleDtcbiAgICAgIHJldHVybiBpbmRleCAhPT0gdm9pZCAwID8gaW5kZXggOiAtMTtcbiAgICB9LFxuICAgIHRva2VuaXplOiAoc3JjLCBfdG9rZW5zLCBsZXhlcikgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgbGluZXMgPSBzcmMuc3BsaXQoXCJcXG5cIik7XG4gICAgICBjb25zdCBbbGlzdEl0ZW1zLCBjb25zdW1lZF0gPSBjb2xsZWN0T3JkZXJlZExpc3RJdGVtcyhsaW5lcyk7XG4gICAgICBpZiAobGlzdEl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgY29uc3QgaXRlbXMgPSBidWlsZE5lc3RlZFN0cnVjdHVyZShsaXN0SXRlbXMsIDAsIGxleGVyKTtcbiAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJ0VmFsdWUgPSAoKF9hID0gbGlzdEl0ZW1zWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2EubnVtYmVyKSB8fCAxO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJsaXN0XCIsXG4gICAgICAgIG9yZGVyZWQ6IHRydWUsXG4gICAgICAgIHN0YXJ0OiBzdGFydFZhbHVlLFxuICAgICAgICBpdGVtcyxcbiAgICAgICAgcmF3OiBsaW5lcy5zbGljZSgwLCBjb25zdW1lZCkuam9pbihcIlxcblwiKVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIG1hcmtkb3duT3B0aW9uczoge1xuICAgIGluZGVudHNDb250ZW50OiB0cnVlXG4gIH0sXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b2dnbGVPcmRlcmVkTGlzdDogKCkgPT4gKHsgY29tbWFuZHMsIGNoYWluIH0pID0+IHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgICAgIHJldHVybiBjaGFpbigpLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lLCB0aGlzLm9wdGlvbnMua2VlcE1hcmtzKS51cGRhdGVBdHRyaWJ1dGVzKExpc3RJdGVtTmFtZTIsIHRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlTmFtZTIpKS5ydW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTGlzdCh0aGlzLm5hbWUsIHRoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWUsIHRoaXMub3B0aW9ucy5rZWVwTWFya3MpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcIk1vZC1TaGlmdC03XCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZU9yZGVyZWRMaXN0KClcbiAgICB9O1xuICB9LFxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIGxldCBpbnB1dFJ1bGUgPSB3cmFwcGluZ0lucHV0UnVsZTIoe1xuICAgICAgZmluZDogb3JkZXJlZExpc3RJbnB1dFJlZ2V4LFxuICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgZ2V0QXR0cmlidXRlczogKG1hdGNoKSA9PiAoeyBzdGFydDogK21hdGNoWzFdIH0pLFxuICAgICAgam9pblByZWRpY2F0ZTogKG1hdGNoLCBub2RlKSA9PiBub2RlLmNoaWxkQ291bnQgKyBub2RlLmF0dHJzLnN0YXJ0ID09PSArbWF0Y2hbMV1cbiAgICB9KTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBNYXJrcyB8fCB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMpIHtcbiAgICAgIGlucHV0UnVsZSA9IHdyYXBwaW5nSW5wdXRSdWxlMih7XG4gICAgICAgIGZpbmQ6IG9yZGVyZWRMaXN0SW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBrZWVwTWFya3M6IHRoaXMub3B0aW9ucy5rZWVwTWFya3MsXG4gICAgICAgIGtlZXBBdHRyaWJ1dGVzOiB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6IChtYXRjaCkgPT4gKHsgc3RhcnQ6ICttYXRjaFsxXSwgLi4udGhpcy5lZGl0b3IuZ2V0QXR0cmlidXRlcyhUZXh0U3R5bGVOYW1lMikgfSksXG4gICAgICAgIGpvaW5QcmVkaWNhdGU6IChtYXRjaCwgbm9kZSkgPT4gbm9kZS5jaGlsZENvdW50ICsgbm9kZS5hdHRycy5zdGFydCA9PT0gK21hdGNoWzFdLFxuICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFtpbnB1dFJ1bGVdO1xuICB9XG59KTtcblxuLy8gc3JjL3Rhc2staXRlbS90YXNrLWl0ZW0udHNcbmltcG9ydCB7IG1lcmdlQXR0cmlidXRlcyBhcyBtZXJnZUF0dHJpYnV0ZXM0LCBOb2RlIGFzIE5vZGU0LCByZW5kZXJOZXN0ZWRNYXJrZG93bkNvbnRlbnQgYXMgcmVuZGVyTmVzdGVkTWFya2Rvd25Db250ZW50Miwgd3JhcHBpbmdJbnB1dFJ1bGUgYXMgd3JhcHBpbmdJbnB1dFJ1bGUzIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xudmFyIGlucHV0UmVnZXggPSAvXlxccyooXFxbKFsoIHx4XSk/XFxdKVxccyQvO1xudmFyIFRhc2tJdGVtID0gTm9kZTQuY3JlYXRlKHtcbiAgbmFtZTogXCJ0YXNrSXRlbVwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuZXN0ZWQ6IGZhbHNlLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgdGFza0xpc3RUeXBlTmFtZTogXCJ0YXNrTGlzdFwiLFxuICAgICAgYTExeTogdm9pZCAwXG4gICAgfTtcbiAgfSxcbiAgY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLm5lc3RlZCA/IFwicGFyYWdyYXBoIGJsb2NrKlwiIDogXCJwYXJhZ3JhcGgrXCI7XG4gIH0sXG4gIGRlZmluaW5nOiB0cnVlLFxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjaGVja2VkOiB7XG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICBrZWVwT25TcGxpdDogZmFsc2UsXG4gICAgICAgIHBhcnNlSFRNTDogKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBkYXRhQ2hlY2tlZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jaGVja2VkXCIpO1xuICAgICAgICAgIHJldHVybiBkYXRhQ2hlY2tlZCA9PT0gXCJcIiB8fCBkYXRhQ2hlY2tlZCA9PT0gXCJ0cnVlXCI7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbmRlckhUTUw6IChhdHRyaWJ1dGVzKSA9PiAoe1xuICAgICAgICAgIFwiZGF0YS1jaGVja2VkXCI6IGF0dHJpYnV0ZXMuY2hlY2tlZFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6IGBsaVtkYXRhLXR5cGU9XCIke3RoaXMubmFtZX1cIl1gLFxuICAgICAgICBwcmlvcml0eTogNTFcbiAgICAgIH1cbiAgICBdO1xuICB9LFxuICByZW5kZXJIVE1MKHsgbm9kZSwgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbXG4gICAgICBcImxpXCIsXG4gICAgICBtZXJnZUF0dHJpYnV0ZXM0KHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMsIHtcbiAgICAgICAgXCJkYXRhLXR5cGVcIjogdGhpcy5uYW1lXG4gICAgICB9KSxcbiAgICAgIFtcbiAgICAgICAgXCJsYWJlbFwiLFxuICAgICAgICBbXG4gICAgICAgICAgXCJpbnB1dFwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgIGNoZWNrZWQ6IG5vZGUuYXR0cnMuY2hlY2tlZCA/IFwiY2hlY2tlZFwiIDogbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgW1wic3BhblwiXVxuICAgICAgXSxcbiAgICAgIFtcImRpdlwiLCAwXVxuICAgIF07XG4gIH0sXG4gIHBhcnNlTWFya2Rvd246ICh0b2tlbiwgaCkgPT4ge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBbXTtcbiAgICBpZiAodG9rZW4udG9rZW5zICYmIHRva2VuLnRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICBjb250ZW50LnB1c2goaC5jcmVhdGVOb2RlKFwicGFyYWdyYXBoXCIsIHt9LCBoLnBhcnNlSW5saW5lKHRva2VuLnRva2VucykpKTtcbiAgICB9IGVsc2UgaWYgKHRva2VuLnRleHQpIHtcbiAgICAgIGNvbnRlbnQucHVzaChoLmNyZWF0ZU5vZGUoXCJwYXJhZ3JhcGhcIiwge30sIFtoLmNyZWF0ZU5vZGUoXCJ0ZXh0XCIsIHsgdGV4dDogdG9rZW4udGV4dCB9KV0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudC5wdXNoKGguY3JlYXRlTm9kZShcInBhcmFncmFwaFwiLCB7fSwgW10pKTtcbiAgICB9XG4gICAgaWYgKHRva2VuLm5lc3RlZFRva2VucyAmJiB0b2tlbi5uZXN0ZWRUb2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbmVzdGVkQ29udGVudCA9IGgucGFyc2VDaGlsZHJlbih0b2tlbi5uZXN0ZWRUb2tlbnMpO1xuICAgICAgY29udGVudC5wdXNoKC4uLm5lc3RlZENvbnRlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gaC5jcmVhdGVOb2RlKFwidGFza0l0ZW1cIiwgeyBjaGVja2VkOiB0b2tlbi5jaGVja2VkIHx8IGZhbHNlIH0sIGNvbnRlbnQpO1xuICB9LFxuICByZW5kZXJNYXJrZG93bjogKG5vZGUsIGgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgY2hlY2tlZENoYXIgPSAoKF9hID0gbm9kZS5hdHRycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNoZWNrZWQpID8gXCJ4XCIgOiBcIiBcIjtcbiAgICBjb25zdCBwcmVmaXggPSBgLSBbJHtjaGVja2VkQ2hhcn1dIGA7XG4gICAgcmV0dXJuIHJlbmRlck5lc3RlZE1hcmtkb3duQ29udGVudDIobm9kZSwgaCwgcHJlZml4KTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgY29uc3Qgc2hvcnRjdXRzID0ge1xuICAgICAgRW50ZXI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNwbGl0TGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICAgIFwiU2hpZnQtVGFiXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmxpZnRMaXN0SXRlbSh0aGlzLm5hbWUpXG4gICAgfTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5uZXN0ZWQpIHtcbiAgICAgIHJldHVybiBzaG9ydGN1dHM7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5zaG9ydGN1dHMsXG4gICAgICBUYWI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNpbmtMaXN0SXRlbSh0aGlzLm5hbWUpXG4gICAgfTtcbiAgfSxcbiAgYWRkTm9kZVZpZXcoKSB7XG4gICAgcmV0dXJuICh7IG5vZGUsIEhUTUxBdHRyaWJ1dGVzLCBnZXRQb3MsIGVkaXRvciB9KSA9PiB7XG4gICAgICBjb25zdCBsaXN0SXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcbiAgICAgIGNvbnN0IGNoZWNrYm94V3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiKTtcbiAgICAgIGNvbnN0IGNoZWNrYm94U3R5bGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBjb25zdCBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29uc3QgdXBkYXRlQTExWSA9IChjdXJyZW50Tm9kZSkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjaGVja2JveC5hcmlhTGFiZWwgPSAoKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmExMXkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jaGVja2JveExhYmVsKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgY3VycmVudE5vZGUsIGNoZWNrYm94LmNoZWNrZWQpKSB8fCBgVGFzayBpdGVtIGNoZWNrYm94IGZvciAke2N1cnJlbnROb2RlLnRleHRDb250ZW50IHx8IFwiZW1wdHkgdGFzayBpdGVtXCJ9YDtcbiAgICAgIH07XG4gICAgICB1cGRhdGVBMTFZKG5vZGUpO1xuICAgICAgY2hlY2tib3hXcmFwcGVyLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgIGNoZWNrYm94LnR5cGUgPSBcImNoZWNrYm94XCI7XG4gICAgICBjaGVja2JveC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIChldmVudCkgPT4gZXZlbnQucHJldmVudERlZmF1bHQoKSk7XG4gICAgICBjaGVja2JveC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoIWVkaXRvci5pc0VkaXRhYmxlICYmICF0aGlzLm9wdGlvbnMub25SZWFkT25seUNoZWNrZWQpIHtcbiAgICAgICAgICBjaGVja2JveC5jaGVja2VkID0gIWNoZWNrYm94LmNoZWNrZWQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY2hlY2tlZCB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICBpZiAoZWRpdG9yLmlzRWRpdGFibGUgJiYgdHlwZW9mIGdldFBvcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgZWRpdG9yLmNoYWluKCkuZm9jdXModm9pZCAwLCB7IHNjcm9sbEludG9WaWV3OiBmYWxzZSB9KS5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UG9zKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBvc2l0aW9uICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROb2RlID0gdHIuZG9jLm5vZGVBdChwb3NpdGlvbik7XG4gICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBvc2l0aW9uLCB2b2lkIDAsIHtcbiAgICAgICAgICAgICAgLi4uY3VycmVudE5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IGN1cnJlbnROb2RlLmF0dHJzLFxuICAgICAgICAgICAgICBjaGVja2VkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0pLnJ1bigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZWRpdG9yLmlzRWRpdGFibGUgJiYgdGhpcy5vcHRpb25zLm9uUmVhZE9ubHlDaGVja2VkKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMub25SZWFkT25seUNoZWNrZWQobm9kZSwgY2hlY2tlZCkpIHtcbiAgICAgICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSAhY2hlY2tib3guY2hlY2tlZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmVudHJpZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgbGlzdEl0ZW0uc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICBsaXN0SXRlbS5kYXRhc2V0LmNoZWNrZWQgPSBub2RlLmF0dHJzLmNoZWNrZWQ7XG4gICAgICBjaGVja2JveC5jaGVja2VkID0gbm9kZS5hdHRycy5jaGVja2VkO1xuICAgICAgY2hlY2tib3hXcmFwcGVyLmFwcGVuZChjaGVja2JveCwgY2hlY2tib3hTdHlsZXIpO1xuICAgICAgbGlzdEl0ZW0uYXBwZW5kKGNoZWNrYm94V3JhcHBlciwgY29udGVudCk7XG4gICAgICBPYmplY3QuZW50cmllcyhIVE1MQXR0cmlidXRlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGxpc3RJdGVtLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9tOiBsaXN0SXRlbSxcbiAgICAgICAgY29udGVudERPTTogY29udGVudCxcbiAgICAgICAgdXBkYXRlOiAodXBkYXRlZE5vZGUpID0+IHtcbiAgICAgICAgICBpZiAodXBkYXRlZE5vZGUudHlwZSAhPT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpc3RJdGVtLmRhdGFzZXQuY2hlY2tlZCA9IHVwZGF0ZWROb2RlLmF0dHJzLmNoZWNrZWQ7XG4gICAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IHVwZGF0ZWROb2RlLmF0dHJzLmNoZWNrZWQ7XG4gICAgICAgICAgdXBkYXRlQTExWSh1cGRhdGVkTm9kZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgfSxcbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgd3JhcHBpbmdJbnB1dFJ1bGUzKHtcbiAgICAgICAgZmluZDogaW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBnZXRBdHRyaWJ1dGVzOiAobWF0Y2gpID0+ICh7XG4gICAgICAgICAgY2hlY2tlZDogbWF0Y2hbbWF0Y2gubGVuZ3RoIC0gMV0gPT09IFwieFwiXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvdGFzay1saXN0L3Rhc2stbGlzdC50c1xuaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzIGFzIG1lcmdlQXR0cmlidXRlczUsIE5vZGUgYXMgTm9kZTUsIHBhcnNlSW5kZW50ZWRCbG9ja3MgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgVGFza0xpc3QgPSBOb2RlNS5jcmVhdGUoe1xuICBuYW1lOiBcInRhc2tMaXN0XCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1UeXBlTmFtZTogXCJ0YXNrSXRlbVwiLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9XG4gICAgfTtcbiAgfSxcbiAgZ3JvdXA6IFwiYmxvY2sgbGlzdFwiLFxuICBjb250ZW50KCkge1xuICAgIHJldHVybiBgJHt0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lfStgO1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiBgdWxbZGF0YS10eXBlPVwiJHt0aGlzLm5hbWV9XCJdYCxcbiAgICAgICAgcHJpb3JpdHk6IDUxXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gW1widWxcIiwgbWVyZ2VBdHRyaWJ1dGVzNSh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzLCB7IFwiZGF0YS10eXBlXCI6IHRoaXMubmFtZSB9KSwgMF07XG4gIH0sXG4gIHBhcnNlTWFya2Rvd246ICh0b2tlbiwgaCkgPT4ge1xuICAgIHJldHVybiBoLmNyZWF0ZU5vZGUoXCJ0YXNrTGlzdFwiLCB7fSwgaC5wYXJzZUNoaWxkcmVuKHRva2VuLml0ZW1zIHx8IFtdKSk7XG4gIH0sXG4gIHJlbmRlck1hcmtkb3duOiAobm9kZSwgaCkgPT4ge1xuICAgIGlmICghbm9kZS5jb250ZW50KSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGgucmVuZGVyQ2hpbGRyZW4obm9kZS5jb250ZW50LCBcIlxcblwiKTtcbiAgfSxcbiAgbWFya2Rvd25Ub2tlbml6ZXI6IHtcbiAgICBuYW1lOiBcInRhc2tMaXN0XCIsXG4gICAgbGV2ZWw6IFwiYmxvY2tcIixcbiAgICBzdGFydChzcmMpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGluZGV4ID0gKF9hID0gc3JjLm1hdGNoKC9eXFxzKlstKypdXFxzK1xcWyhbIHhYXSlcXF1cXHMrLykpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pbmRleDtcbiAgICAgIHJldHVybiBpbmRleCAhPT0gdm9pZCAwID8gaW5kZXggOiAtMTtcbiAgICB9LFxuICAgIHRva2VuaXplKHNyYywgdG9rZW5zLCBsZXhlcikge1xuICAgICAgY29uc3QgcGFyc2VUYXNrTGlzdENvbnRlbnQgPSAoY29udGVudCkgPT4ge1xuICAgICAgICBjb25zdCBuZXN0ZWRSZXN1bHQgPSBwYXJzZUluZGVudGVkQmxvY2tzKFxuICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgaXRlbVBhdHRlcm46IC9eKFxccyopKFstKypdKVxccytcXFsoWyB4WF0pXFxdXFxzKyguKikkLyxcbiAgICAgICAgICAgIGV4dHJhY3RJdGVtRGF0YTogKG1hdGNoKSA9PiAoe1xuICAgICAgICAgICAgICBpbmRlbnRMZXZlbDogbWF0Y2hbMV0ubGVuZ3RoLFxuICAgICAgICAgICAgICBtYWluQ29udGVudDogbWF0Y2hbNF0sXG4gICAgICAgICAgICAgIGNoZWNrZWQ6IG1hdGNoWzNdLnRvTG93ZXJDYXNlKCkgPT09IFwieFwiXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNyZWF0ZVRva2VuOiAoZGF0YSwgbmVzdGVkVG9rZW5zKSA9PiAoe1xuICAgICAgICAgICAgICB0eXBlOiBcInRhc2tJdGVtXCIsXG4gICAgICAgICAgICAgIHJhdzogXCJcIixcbiAgICAgICAgICAgICAgbWFpbkNvbnRlbnQ6IGRhdGEubWFpbkNvbnRlbnQsXG4gICAgICAgICAgICAgIGluZGVudExldmVsOiBkYXRhLmluZGVudExldmVsLFxuICAgICAgICAgICAgICBjaGVja2VkOiBkYXRhLmNoZWNrZWQsXG4gICAgICAgICAgICAgIHRleHQ6IGRhdGEubWFpbkNvbnRlbnQsXG4gICAgICAgICAgICAgIHRva2VuczogbGV4ZXIuaW5saW5lVG9rZW5zKGRhdGEubWFpbkNvbnRlbnQpLFxuICAgICAgICAgICAgICBuZXN0ZWRUb2tlbnNcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgLy8gQWxsb3cgcmVjdXJzaXZlIG5lc3RpbmdcbiAgICAgICAgICAgIGN1c3RvbU5lc3RlZFBhcnNlcjogcGFyc2VUYXNrTGlzdENvbnRlbnRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGxleGVyXG4gICAgICAgICk7XG4gICAgICAgIGlmIChuZXN0ZWRSZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcInRhc2tMaXN0XCIsXG4gICAgICAgICAgICAgIHJhdzogbmVzdGVkUmVzdWx0LnJhdyxcbiAgICAgICAgICAgICAgaXRlbXM6IG5lc3RlZFJlc3VsdC5pdGVtc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxleGVyLmJsb2NrVG9rZW5zKGNvbnRlbnQpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlSW5kZW50ZWRCbG9ja3MoXG4gICAgICAgIHNyYyxcbiAgICAgICAge1xuICAgICAgICAgIGl0ZW1QYXR0ZXJuOiAvXihcXHMqKShbLSsqXSlcXHMrXFxbKFsgeFhdKVxcXVxccysoLiopJC8sXG4gICAgICAgICAgZXh0cmFjdEl0ZW1EYXRhOiAobWF0Y2gpID0+ICh7XG4gICAgICAgICAgICBpbmRlbnRMZXZlbDogbWF0Y2hbMV0ubGVuZ3RoLFxuICAgICAgICAgICAgbWFpbkNvbnRlbnQ6IG1hdGNoWzRdLFxuICAgICAgICAgICAgY2hlY2tlZDogbWF0Y2hbM10udG9Mb3dlckNhc2UoKSA9PT0gXCJ4XCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBjcmVhdGVUb2tlbjogKGRhdGEsIG5lc3RlZFRva2VucykgPT4gKHtcbiAgICAgICAgICAgIHR5cGU6IFwidGFza0l0ZW1cIixcbiAgICAgICAgICAgIHJhdzogXCJcIixcbiAgICAgICAgICAgIG1haW5Db250ZW50OiBkYXRhLm1haW5Db250ZW50LFxuICAgICAgICAgICAgaW5kZW50TGV2ZWw6IGRhdGEuaW5kZW50TGV2ZWwsXG4gICAgICAgICAgICBjaGVja2VkOiBkYXRhLmNoZWNrZWQsXG4gICAgICAgICAgICB0ZXh0OiBkYXRhLm1haW5Db250ZW50LFxuICAgICAgICAgICAgdG9rZW5zOiBsZXhlci5pbmxpbmVUb2tlbnMoZGF0YS5tYWluQ29udGVudCksXG4gICAgICAgICAgICBuZXN0ZWRUb2tlbnNcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvLyBVc2UgdGhlIHJlY3Vyc2l2ZSBwYXJzZXIgZm9yIG5lc3RlZCBjb250ZW50XG4gICAgICAgICAgY3VzdG9tTmVzdGVkUGFyc2VyOiBwYXJzZVRhc2tMaXN0Q29udGVudFxuICAgICAgICB9LFxuICAgICAgICBsZXhlclxuICAgICAgKTtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInRhc2tMaXN0XCIsXG4gICAgICAgIHJhdzogcmVzdWx0LnJhdyxcbiAgICAgICAgaXRlbXM6IHJlc3VsdC5pdGVtc1xuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIG1hcmtkb3duT3B0aW9uczoge1xuICAgIGluZGVudHNDb250ZW50OiB0cnVlXG4gIH0sXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b2dnbGVUYXNrTGlzdDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTGlzdCh0aGlzLm5hbWUsIHRoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcIk1vZC1TaGlmdC05XCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZVRhc2tMaXN0KClcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2tpdC9pbmRleC50c1xudmFyIExpc3RLaXQgPSBFeHRlbnNpb24yLmNyZWF0ZSh7XG4gIG5hbWU6IFwibGlzdEtpdFwiLFxuICBhZGRFeHRlbnNpb25zKCkge1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBbXTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmJ1bGxldExpc3QgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goQnVsbGV0TGlzdC5jb25maWd1cmUodGhpcy5vcHRpb25zLmJ1bGxldExpc3QpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5saXN0SXRlbSAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChMaXN0SXRlbS5jb25maWd1cmUodGhpcy5vcHRpb25zLmxpc3RJdGVtKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMubGlzdEtleW1hcCAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChMaXN0S2V5bWFwLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMubGlzdEtleW1hcCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLm9yZGVyZWRMaXN0ICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKE9yZGVyZWRMaXN0LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMub3JkZXJlZExpc3QpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy50YXNrSXRlbSAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChUYXNrSXRlbS5jb25maWd1cmUodGhpcy5vcHRpb25zLnRhc2tJdGVtKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMudGFza0xpc3QgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goVGFza0xpc3QuY29uZmlndXJlKHRoaXMub3B0aW9ucy50YXNrTGlzdCkpO1xuICAgIH1cbiAgICByZXR1cm4gZXh0ZW5zaW9ucztcbiAgfVxufSk7XG5leHBvcnQge1xuICBCdWxsZXRMaXN0LFxuICBMaXN0SXRlbSxcbiAgTGlzdEtleW1hcCxcbiAgTGlzdEtpdCxcbiAgT3JkZXJlZExpc3QsXG4gIFRhc2tJdGVtLFxuICBUYXNrTGlzdCxcbiAgYnVsbGV0TGlzdElucHV0UmVnZXgsXG4gIGlucHV0UmVnZXgsXG4gIGxpc3RIZWxwZXJzX2V4cG9ydHMgYXMgbGlzdEhlbHBlcnMsXG4gIG9yZGVyZWRMaXN0SW5wdXRSZWdleFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-list/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-paragraph/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-paragraph/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Paragraph: () => (/* binding */ Paragraph),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/paragraph.ts\n\nvar Paragraph = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"paragraph\",\n  priority: 1e3,\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  group: \"block\",\n  content: \"inline*\",\n  parseHTML() {\n    return [{ tag: \"p\" }];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"p\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  parseMarkdown: (token, helpers) => {\n    const tokens = token.tokens || [];\n    if (tokens.length === 1 && tokens[0].type === \"image\") {\n      return helpers.parseChildren([tokens[0]]);\n    }\n    return helpers.createNode(\n      \"paragraph\",\n      void 0,\n      // no attributes for paragraph\n      helpers.parseInline(tokens)\n    );\n  },\n  renderMarkdown: (node, h) => {\n    if (!node || !Array.isArray(node.content)) {\n      return \"\";\n    }\n    return h.renderChildren(node.content);\n  },\n  addCommands() {\n    return {\n      setParagraph: () => ({ commands }) => {\n        return commands.setNode(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Alt-0\": () => this.editor.commands.setParagraph()\n    };\n  }\n});\n\n// src/index.ts\nvar index_default = Paragraph;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tcGFyYWdyYXBoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDcUQ7QUFDckQsZ0JBQWdCLDhDQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEIsR0FBRztBQUNILGVBQWUsZ0JBQWdCO0FBQy9CLGlCQUFpQiw2REFBZTtBQUNoQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tb3J0b25tYWJ1bWJvL0Rvd25sb2Fkcy90ZXN0aW1pbm9ueS13ZWIxXzEwLW1haW4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXBhcmFncmFwaC9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9wYXJhZ3JhcGgudHNcbmltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBQYXJhZ3JhcGggPSBOb2RlLmNyZWF0ZSh7XG4gIG5hbWU6IFwicGFyYWdyYXBoXCIsXG4gIHByaW9yaXR5OiAxZTMsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fVxuICAgIH07XG4gIH0sXG4gIGdyb3VwOiBcImJsb2NrXCIsXG4gIGNvbnRlbnQ6IFwiaW5saW5lKlwiLFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFt7IHRhZzogXCJwXCIgfV07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcInBcIiwgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgfSxcbiAgcGFyc2VNYXJrZG93bjogKHRva2VuLCBoZWxwZXJzKSA9PiB7XG4gICAgY29uc3QgdG9rZW5zID0gdG9rZW4udG9rZW5zIHx8IFtdO1xuICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAxICYmIHRva2Vuc1swXS50eXBlID09PSBcImltYWdlXCIpIHtcbiAgICAgIHJldHVybiBoZWxwZXJzLnBhcnNlQ2hpbGRyZW4oW3Rva2Vuc1swXV0pO1xuICAgIH1cbiAgICByZXR1cm4gaGVscGVycy5jcmVhdGVOb2RlKFxuICAgICAgXCJwYXJhZ3JhcGhcIixcbiAgICAgIHZvaWQgMCxcbiAgICAgIC8vIG5vIGF0dHJpYnV0ZXMgZm9yIHBhcmFncmFwaFxuICAgICAgaGVscGVycy5wYXJzZUlubGluZSh0b2tlbnMpXG4gICAgKTtcbiAgfSxcbiAgcmVuZGVyTWFya2Rvd246IChub2RlLCBoKSA9PiB7XG4gICAgaWYgKCFub2RlIHx8ICFBcnJheS5pc0FycmF5KG5vZGUuY29udGVudCkpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gaC5yZW5kZXJDaGlsZHJlbihub2RlLmNvbnRlbnQpO1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0UGFyYWdyYXBoOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHRoaXMubmFtZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiTW9kLUFsdC0wXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNldFBhcmFncmFwaCgpXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGluZGV4X2RlZmF1bHQgPSBQYXJhZ3JhcGg7XG5leHBvcnQge1xuICBQYXJhZ3JhcGgsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-paragraph/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-strike/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@tiptap/extension-strike/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Strike: () => (/* binding */ Strike),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/strike.ts\n\nvar inputRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))$/;\nvar pasteRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))/g;\nvar Strike = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n  name: \"strike\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"s\"\n      },\n      {\n        tag: \"del\"\n      },\n      {\n        tag: \"strike\"\n      },\n      {\n        style: \"text-decoration\",\n        consuming: false,\n        getAttrs: (style) => style.includes(\"line-through\") ? {} : false\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"s\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  markdownTokenName: \"del\",\n  parseMarkdown: (token, helpers) => {\n    return helpers.applyMark(\"strike\", helpers.parseInline(token.tokens || []));\n  },\n  renderMarkdown: (node, h) => {\n    return `~~${h.renderChildren(node)}~~`;\n  },\n  addCommands() {\n    return {\n      setStrike: () => ({ commands }) => {\n        return commands.setMark(this.name);\n      },\n      toggleStrike: () => ({ commands }) => {\n        return commands.toggleMark(this.name);\n      },\n      unsetStrike: () => ({ commands }) => {\n        return commands.unsetMark(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-s\": () => this.editor.commands.toggleStrike()\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n        find: inputRegex,\n        type: this.type\n      })\n    ];\n  },\n  addPasteRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n        find: pasteRegex,\n        type: this.type\n      })\n    ];\n  }\n});\n\n// src/index.ts\nvar index_default = Strike;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tc3RyaWtlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNtRjtBQUNuRjtBQUNBO0FBQ0EsYUFBYSw4Q0FBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBLEdBQUc7QUFDSCxlQUFlLGdCQUFnQjtBQUMvQixpQkFBaUIsNkRBQWU7QUFDaEMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkMsR0FBRztBQUNIO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBLE9BQU87QUFDUCw2QkFBNkIsVUFBVTtBQUN2QztBQUNBLE9BQU87QUFDUCw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU0sMkRBQWE7QUFDbkI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTSwyREFBYTtBQUNuQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFNRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvbW9ydG9ubWFidW1iby9Eb3dubG9hZHMvdGVzdGltaW5vbnktd2ViMV8xMC1tYWluL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1zdHJpa2UvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvc3RyaWtlLnRzXG5pbXBvcnQgeyBNYXJrLCBtYXJrSW5wdXRSdWxlLCBtYXJrUGFzdGVSdWxlLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgaW5wdXRSZWdleCA9IC8oPzpefFxccykofn4oPyFcXHMrfn4pKCg/Oltefl0rKSl+fig/IVxccyt+fikpJC87XG52YXIgcGFzdGVSZWdleCA9IC8oPzpefFxccykofn4oPyFcXHMrfn4pKCg/Oltefl0rKSl+fig/IVxccyt+fikpL2c7XG52YXIgU3RyaWtlID0gTWFyay5jcmVhdGUoe1xuICBuYW1lOiBcInN0cmlrZVwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge31cbiAgICB9O1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcInNcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcImRlbFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0YWc6IFwic3RyaWtlXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiBcInRleHQtZGVjb3JhdGlvblwiLFxuICAgICAgICBjb25zdW1pbmc6IGZhbHNlLFxuICAgICAgICBnZXRBdHRyczogKHN0eWxlKSA9PiBzdHlsZS5pbmNsdWRlcyhcImxpbmUtdGhyb3VnaFwiKSA/IHt9IDogZmFsc2VcbiAgICAgIH1cbiAgICBdO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbXCJzXCIsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gIH0sXG4gIG1hcmtkb3duVG9rZW5OYW1lOiBcImRlbFwiLFxuICBwYXJzZU1hcmtkb3duOiAodG9rZW4sIGhlbHBlcnMpID0+IHtcbiAgICByZXR1cm4gaGVscGVycy5hcHBseU1hcmsoXCJzdHJpa2VcIiwgaGVscGVycy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMgfHwgW10pKTtcbiAgfSxcbiAgcmVuZGVyTWFya2Rvd246IChub2RlLCBoKSA9PiB7XG4gICAgcmV0dXJuIGB+fiR7aC5yZW5kZXJDaGlsZHJlbihub2RlKX1+fmA7XG4gIH0sXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRTdHJpa2U6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGVTdHJpa2U6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKTtcbiAgICAgIH0sXG4gICAgICB1bnNldFN0cmlrZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiTW9kLVNoaWZ0LXNcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlU3RyaWtlKClcbiAgICB9O1xuICB9LFxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogaW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KVxuICAgIF07XG4gIH0sXG4gIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiBwYXN0ZVJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGluZGV4X2RlZmF1bHQgPSBTdHJpa2U7XG5leHBvcnQge1xuICBTdHJpa2UsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdCxcbiAgaW5wdXRSZWdleCxcbiAgcGFzdGVSZWdleFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-strike/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-text-align/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-text-align/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextAlign: () => (/* binding */ TextAlign),\n/* harmony export */   \"default\": () => (/* binding */ TextAlign)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n/**\n * This extension allows you to align text.\n * @see https://www.tiptap.dev/api/extensions/text-align\n */\nconst TextAlign = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Extension.create({\n    name: 'textAlign',\n    addOptions() {\n        return {\n            types: [],\n            alignments: ['left', 'center', 'right', 'justify'],\n            defaultAlignment: null,\n        };\n    },\n    addGlobalAttributes() {\n        return [\n            {\n                types: this.options.types,\n                attributes: {\n                    textAlign: {\n                        default: this.options.defaultAlignment,\n                        parseHTML: element => {\n                            const alignment = element.style.textAlign;\n                            return this.options.alignments.includes(alignment) ? alignment : this.options.defaultAlignment;\n                        },\n                        renderHTML: attributes => {\n                            if (!attributes.textAlign) {\n                                return {};\n                            }\n                            return { style: `text-align: ${attributes.textAlign}` };\n                        },\n                    },\n                },\n            },\n        ];\n    },\n    addCommands() {\n        return {\n            setTextAlign: (alignment) => ({ commands }) => {\n                if (!this.options.alignments.includes(alignment)) {\n                    return false;\n                }\n                return this.options.types\n                    .map(type => commands.updateAttributes(type, { textAlign: alignment }))\n                    .every(response => response);\n            },\n            unsetTextAlign: () => ({ commands }) => {\n                return this.options.types\n                    .map(type => commands.resetAttributes(type, 'textAlign'))\n                    .every(response => response);\n            },\n            toggleTextAlign: alignment => ({ editor, commands }) => {\n                if (!this.options.alignments.includes(alignment)) {\n                    return false;\n                }\n                if (editor.isActive({ textAlign: alignment })) {\n                    return commands.unsetTextAlign();\n                }\n                return commands.setTextAlign(alignment);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-Shift-l': () => this.editor.commands.setTextAlign('left'),\n            'Mod-Shift-e': () => this.editor.commands.setTextAlign('center'),\n            'Mod-Shift-r': () => this.editor.commands.setTextAlign('right'),\n            'Mod-Shift-j': () => this.editor.commands.setTextAlign('justify'),\n        };\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGV4dC1hbGlnbi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbURBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsc0JBQXNCLHFCQUFxQjtBQUNoRix5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHNCQUFzQjtBQUN6RjtBQUNBLGFBQWE7QUFDYixxQ0FBcUMsVUFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsNkNBQTZDLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUUwQztBQUMzQyIsInNvdXJjZXMiOlsiL1VzZXJzL21vcnRvbm1hYnVtYm8vRG93bmxvYWRzL3Rlc3RpbWlub255LXdlYjFfMTAtbWFpbi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGV4dC1hbGlnbi9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBhbGlnbiB0ZXh0LlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zL3RleHQtYWxpZ25cbiAqL1xuY29uc3QgVGV4dEFsaWduID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ3RleHRBbGlnbicsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGVzOiBbXSxcbiAgICAgICAgICAgIGFsaWdubWVudHM6IFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnLCAnanVzdGlmeSddLFxuICAgICAgICAgICAgZGVmYXVsdEFsaWdubWVudDogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZEdsb2JhbEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZXM6IHRoaXMub3B0aW9ucy50eXBlcyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLmRlZmF1bHRBbGlnbm1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUhUTUw6IGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsaWdubWVudCA9IGVsZW1lbnQuc3R5bGUudGV4dEFsaWduO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYWxpZ25tZW50cy5pbmNsdWRlcyhhbGlnbm1lbnQpID8gYWxpZ25tZW50IDogdGhpcy5vcHRpb25zLmRlZmF1bHRBbGlnbm1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVySFRNTDogYXR0cmlidXRlcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLnRleHRBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0eWxlOiBgdGV4dC1hbGlnbjogJHthdHRyaWJ1dGVzLnRleHRBbGlnbn1gIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgYWRkQ29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXRUZXh0QWxpZ246IChhbGlnbm1lbnQpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbGlnbm1lbnRzLmluY2x1ZGVzKGFsaWdubWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGVzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAodHlwZSA9PiBjb21tYW5kcy51cGRhdGVBdHRyaWJ1dGVzKHR5cGUsIHsgdGV4dEFsaWduOiBhbGlnbm1lbnQgfSkpXG4gICAgICAgICAgICAgICAgICAgIC5ldmVyeShyZXNwb25zZSA9PiByZXNwb25zZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5zZXRUZXh0QWxpZ246ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGVzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAodHlwZSA9PiBjb21tYW5kcy5yZXNldEF0dHJpYnV0ZXModHlwZSwgJ3RleHRBbGlnbicpKVxuICAgICAgICAgICAgICAgICAgICAuZXZlcnkocmVzcG9uc2UgPT4gcmVzcG9uc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvZ2dsZVRleHRBbGlnbjogYWxpZ25tZW50ID0+ICh7IGVkaXRvciwgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmFsaWdubWVudHMuaW5jbHVkZXMoYWxpZ25tZW50KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlZGl0b3IuaXNBY3RpdmUoeyB0ZXh0QWxpZ246IGFsaWdubWVudCB9KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRUZXh0QWxpZ24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldFRleHRBbGlnbihhbGlnbm1lbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC1TaGlmdC1sJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0VGV4dEFsaWduKCdsZWZ0JyksXG4gICAgICAgICAgICAnTW9kLVNoaWZ0LWUnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZXRUZXh0QWxpZ24oJ2NlbnRlcicpLFxuICAgICAgICAgICAgJ01vZC1TaGlmdC1yJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0VGV4dEFsaWduKCdyaWdodCcpLFxuICAgICAgICAgICAgJ01vZC1TaGlmdC1qJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0VGV4dEFsaWduKCdqdXN0aWZ5JyksXG4gICAgICAgIH07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBUZXh0QWxpZ24sIFRleHRBbGlnbiBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-text-align/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-text/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-text/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/text.ts\n\nvar Text = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"text\",\n  group: \"inline\",\n  parseMarkdown: (token) => {\n    return {\n      type: \"text\",\n      text: token.text || \"\"\n    };\n  },\n  renderMarkdown: (node) => node.text || \"\"\n});\n\n// src/index.ts\nvar index_default = Text;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGV4dC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ29DO0FBQ3BDLFdBQVcsOENBQUk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tb3J0b25tYWJ1bWJvL0Rvd25sb2Fkcy90ZXN0aW1pbm9ueS13ZWIxXzEwLW1haW4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXRleHQvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdGV4dC50c1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBUZXh0ID0gTm9kZS5jcmVhdGUoe1xuICBuYW1lOiBcInRleHRcIixcbiAgZ3JvdXA6IFwiaW5saW5lXCIsXG4gIHBhcnNlTWFya2Rvd246ICh0b2tlbikgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIHRleHQ6IHRva2VuLnRleHQgfHwgXCJcIlxuICAgIH07XG4gIH0sXG4gIHJlbmRlck1hcmtkb3duOiAobm9kZSkgPT4gbm9kZS50ZXh0IHx8IFwiXCJcbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gVGV4dDtcbmV4cG9ydCB7XG4gIFRleHQsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-text/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-underline/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-underline/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Underline: () => (/* binding */ Underline),\n/* harmony export */   \"default\": () => (/* binding */ Underline)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n/**\n * This extension allows you to create underline text.\n * @see https://www.tiptap.dev/api/marks/underline\n */\nconst Underline = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: 'underline',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    parseHTML() {\n        return [\n            {\n                tag: 'u',\n            },\n            {\n                style: 'text-decoration',\n                consuming: false,\n                getAttrs: style => (style.includes('underline') ? {} : false),\n            },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['u', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setUnderline: () => ({ commands }) => {\n                return commands.setMark(this.name);\n            },\n            toggleUnderline: () => ({ commands }) => {\n                return commands.toggleMark(this.name);\n            },\n            unsetUnderline: () => ({ commands }) => {\n                return commands.unsetMark(this.name);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-u': () => this.editor.commands.toggleUnderline(),\n            'Mod-U': () => this.editor.commands.toggleUnderline(),\n        };\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdW5kZXJsaW5lL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4Q0FBSTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsZ0JBQWdCO0FBQ2pDLHFCQUFxQiw2REFBZTtBQUNwQyxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1DQUFtQyxVQUFVO0FBQzdDO0FBQ0EsYUFBYTtBQUNiLHNDQUFzQyxVQUFVO0FBQ2hEO0FBQ0EsYUFBYTtBQUNiLHFDQUFxQyxVQUFVO0FBQy9DO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFMEM7QUFDM0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tb3J0b25tYWJ1bWJvL0Rvd25sb2Fkcy90ZXN0aW1pbm9ueS13ZWIxXzEwLW1haW4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXVuZGVybGluZS9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hcmssIG1lcmdlQXR0cmlidXRlcyB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgdW5kZXJsaW5lIHRleHQuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL21hcmtzL3VuZGVybGluZVxuICovXG5jb25zdCBVbmRlcmxpbmUgPSBNYXJrLmNyZWF0ZSh7XG4gICAgbmFtZTogJ3VuZGVybGluZScsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWc6ICd1JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3R5bGU6ICd0ZXh0LWRlY29yYXRpb24nLFxuICAgICAgICAgICAgICAgIGNvbnN1bWluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgZ2V0QXR0cnM6IHN0eWxlID0+IChzdHlsZS5pbmNsdWRlcygndW5kZXJsaW5lJykgPyB7fSA6IGZhbHNlKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gWyd1JywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgICB9LFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0VW5kZXJsaW5lOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b2dnbGVVbmRlcmxpbmU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuc2V0VW5kZXJsaW5lOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC11JzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlVW5kZXJsaW5lKCksXG4gICAgICAgICAgICAnTW9kLVUnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVVbmRlcmxpbmUoKSxcbiAgICAgICAgfTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IFVuZGVybGluZSwgVW5kZXJsaW5lIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-underline/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extensions/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@tiptap/extensions/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CharacterCount: () => (/* binding */ CharacterCount),\n/* harmony export */   Dropcursor: () => (/* binding */ Dropcursor),\n/* harmony export */   Focus: () => (/* binding */ Focus),\n/* harmony export */   Gapcursor: () => (/* binding */ Gapcursor),\n/* harmony export */   Placeholder: () => (/* binding */ Placeholder),\n/* harmony export */   Selection: () => (/* binding */ Selection),\n/* harmony export */   TrailingNode: () => (/* binding */ TrailingNode),\n/* harmony export */   UndoRedo: () => (/* binding */ UndoRedo)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\");\n/* harmony import */ var _tiptap_pm_dropcursor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/pm/dropcursor */ \"(ssr)/./node_modules/@tiptap/pm/dist/dropcursor/index.js\");\n/* harmony import */ var _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/pm/view */ \"(ssr)/./node_modules/@tiptap/pm/dist/view/index.js\");\n/* harmony import */ var _tiptap_pm_gapcursor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/pm/gapcursor */ \"(ssr)/./node_modules/@tiptap/pm/dist/gapcursor/index.js\");\n/* harmony import */ var _tiptap_pm_history__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/pm/history */ \"(ssr)/./node_modules/@tiptap/pm/dist/history/index.js\");\n// src/character-count/character-count.ts\n\n\nvar CharacterCount = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n  name: \"characterCount\",\n  addOptions() {\n    return {\n      limit: null,\n      mode: \"textSize\",\n      textCounter: (text) => text.length,\n      wordCounter: (text) => text.split(\" \").filter((word) => word !== \"\").length\n    };\n  },\n  addStorage() {\n    return {\n      characters: () => 0,\n      words: () => 0\n    };\n  },\n  onBeforeCreate() {\n    this.storage.characters = (options) => {\n      const node = (options == null ? void 0 : options.node) || this.editor.state.doc;\n      const mode = (options == null ? void 0 : options.mode) || this.options.mode;\n      if (mode === \"textSize\") {\n        const text = node.textBetween(0, node.content.size, void 0, \" \");\n        return this.options.textCounter(text);\n      }\n      return node.nodeSize;\n    };\n    this.storage.words = (options) => {\n      const node = (options == null ? void 0 : options.node) || this.editor.state.doc;\n      const text = node.textBetween(0, node.content.size, \" \", \" \");\n      return this.options.wordCounter(text);\n    };\n  },\n  addProseMirrorPlugins() {\n    let initialEvaluationDone = false;\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"characterCount\"),\n        appendTransaction: (transactions, oldState, newState) => {\n          if (initialEvaluationDone) {\n            return;\n          }\n          const limit = this.options.limit;\n          if (limit === null || limit === void 0 || limit === 0) {\n            initialEvaluationDone = true;\n            return;\n          }\n          const initialContentSize = this.storage.characters({ node: newState.doc });\n          if (initialContentSize > limit) {\n            const over = initialContentSize - limit;\n            const from = 0;\n            const to = over;\n            console.warn(\n              `[CharacterCount] Initial content exceeded limit of ${limit} characters. Content was automatically trimmed.`\n            );\n            const tr = newState.tr.deleteRange(from, to);\n            initialEvaluationDone = true;\n            return tr;\n          }\n          initialEvaluationDone = true;\n        },\n        filterTransaction: (transaction, state) => {\n          const limit = this.options.limit;\n          if (!transaction.docChanged || limit === 0 || limit === null || limit === void 0) {\n            return true;\n          }\n          const oldSize = this.storage.characters({ node: state.doc });\n          const newSize = this.storage.characters({ node: transaction.doc });\n          if (newSize <= limit) {\n            return true;\n          }\n          if (oldSize > limit && newSize > limit && newSize <= oldSize) {\n            return true;\n          }\n          if (oldSize > limit && newSize > limit && newSize > oldSize) {\n            return false;\n          }\n          const isPaste = transaction.getMeta(\"paste\");\n          if (!isPaste) {\n            return false;\n          }\n          const pos = transaction.selection.$head.pos;\n          const over = newSize - limit;\n          const from = pos - over;\n          const to = pos;\n          transaction.deleteRange(from, to);\n          const updatedSize = this.storage.characters({ node: transaction.doc });\n          if (updatedSize > limit) {\n            return false;\n          }\n          return true;\n        }\n      })\n    ];\n  }\n});\n\n// src/drop-cursor/drop-cursor.ts\n\n\nvar Dropcursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n  name: \"dropCursor\",\n  addOptions() {\n    return {\n      color: \"currentColor\",\n      width: 1,\n      class: void 0\n    };\n  },\n  addProseMirrorPlugins() {\n    return [(0,_tiptap_pm_dropcursor__WEBPACK_IMPORTED_MODULE_2__.dropCursor)(this.options)];\n  }\n});\n\n// src/focus/focus.ts\n\n\n\nvar Focus = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n  name: \"focus\",\n  addOptions() {\n    return {\n      className: \"has-focus\",\n      mode: \"all\"\n    };\n  },\n  addProseMirrorPlugins() {\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"focus\"),\n        props: {\n          decorations: ({ doc, selection }) => {\n            const { isEditable, isFocused } = this.editor;\n            const { anchor } = selection;\n            const decorations = [];\n            if (!isEditable || !isFocused) {\n              return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.DecorationSet.create(doc, []);\n            }\n            let maxLevels = 0;\n            if (this.options.mode === \"deepest\") {\n              doc.descendants((node, pos) => {\n                if (node.isText) {\n                  return;\n                }\n                const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1;\n                if (!isCurrent) {\n                  return false;\n                }\n                maxLevels += 1;\n              });\n            }\n            let currentLevel = 0;\n            doc.descendants((node, pos) => {\n              if (node.isText) {\n                return false;\n              }\n              const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1;\n              if (!isCurrent) {\n                return false;\n              }\n              currentLevel += 1;\n              const outOfScope = this.options.mode === \"deepest\" && maxLevels - currentLevel > 0 || this.options.mode === \"shallowest\" && currentLevel > 1;\n              if (outOfScope) {\n                return this.options.mode === \"deepest\";\n              }\n              decorations.push(\n                _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.node(pos, pos + node.nodeSize, {\n                  class: this.options.className\n                })\n              );\n            });\n            return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.DecorationSet.create(doc, decorations);\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/gap-cursor/gap-cursor.ts\n\n\nvar Gapcursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n  name: \"gapCursor\",\n  addProseMirrorPlugins() {\n    return [(0,_tiptap_pm_gapcursor__WEBPACK_IMPORTED_MODULE_4__.gapCursor)()];\n  },\n  extendNodeSchema(extension) {\n    var _a;\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    return {\n      allowGapCursor: (_a = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.callOrReturn)((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.getExtensionField)(extension, \"allowGapCursor\", context))) != null ? _a : null\n    };\n  }\n});\n\n// src/placeholder/placeholder.ts\n\n\n\nvar Placeholder = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n  name: \"placeholder\",\n  addOptions() {\n    return {\n      emptyEditorClass: \"is-editor-empty\",\n      emptyNodeClass: \"is-empty\",\n      placeholder: \"Write something \\u2026\",\n      showOnlyWhenEditable: true,\n      showOnlyCurrent: true,\n      includeChildren: false\n    };\n  },\n  addProseMirrorPlugins() {\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"placeholder\"),\n        props: {\n          decorations: ({ doc, selection }) => {\n            const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;\n            const { anchor } = selection;\n            const decorations = [];\n            if (!active) {\n              return null;\n            }\n            const isEmptyDoc = this.editor.isEmpty;\n            doc.descendants((node, pos) => {\n              const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;\n              const isEmpty = !node.isLeaf && (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isNodeEmpty)(node);\n              if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {\n                const classes = [this.options.emptyNodeClass];\n                if (isEmptyDoc) {\n                  classes.push(this.options.emptyEditorClass);\n                }\n                const decoration = _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.node(pos, pos + node.nodeSize, {\n                  class: classes.join(\" \"),\n                  \"data-placeholder\": typeof this.options.placeholder === \"function\" ? this.options.placeholder({\n                    editor: this.editor,\n                    node,\n                    pos,\n                    hasAnchor\n                  }) : this.options.placeholder\n                });\n                decorations.push(decoration);\n              }\n              return this.options.includeChildren;\n            });\n            return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.DecorationSet.create(doc, decorations);\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/selection/selection.ts\n\n\n\nvar Selection = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n  name: \"selection\",\n  addOptions() {\n    return {\n      className: \"selection\"\n    };\n  },\n  addProseMirrorPlugins() {\n    const { editor, options } = this;\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"selection\"),\n        props: {\n          decorations(state) {\n            if (state.selection.empty || editor.isFocused || !editor.isEditable || (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isNodeSelection)(state.selection) || editor.view.dragging) {\n              return null;\n            }\n            return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.DecorationSet.create(state.doc, [\n              _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.inline(state.selection.from, state.selection.to, {\n                class: options.className\n              })\n            ]);\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/trailing-node/trailing-node.ts\n\n\nfunction nodeEqualsType({ types, node }) {\n  return node && Array.isArray(types) && types.includes(node.type) || (node == null ? void 0 : node.type) === types;\n}\nvar TrailingNode = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n  name: \"trailingNode\",\n  addOptions() {\n    return {\n      node: void 0,\n      notAfter: []\n    };\n  },\n  addProseMirrorPlugins() {\n    var _a;\n    const plugin = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(this.name);\n    const defaultNode = ((_a = this.editor.schema.topNodeType.contentMatch.defaultType) == null ? void 0 : _a.name) || this.options.node || \"paragraph\";\n    const disabledNodes = Object.entries(this.editor.schema.nodes).map(([, value]) => value).filter((node) => (this.options.notAfter || []).concat(defaultNode).includes(node.name));\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: plugin,\n        appendTransaction: (_, __, state) => {\n          const { doc, tr, schema } = state;\n          const shouldInsertNodeAtEnd = plugin.getState(state);\n          const endPosition = doc.content.size;\n          const type = schema.nodes[defaultNode];\n          if (!shouldInsertNodeAtEnd) {\n            return;\n          }\n          return tr.insert(endPosition, type.create());\n        },\n        state: {\n          init: (_, state) => {\n            const lastNode = state.tr.doc.lastChild;\n            return !nodeEqualsType({ node: lastNode, types: disabledNodes });\n          },\n          apply: (tr, value) => {\n            if (!tr.docChanged) {\n              return value;\n            }\n            const lastNode = tr.doc.lastChild;\n            return !nodeEqualsType({ node: lastNode, types: disabledNodes });\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/undo-redo/undo-redo.ts\n\n\nvar UndoRedo = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n  name: \"undoRedo\",\n  addOptions() {\n    return {\n      depth: 100,\n      newGroupDelay: 500\n    };\n  },\n  addCommands() {\n    return {\n      undo: () => ({ state, dispatch }) => {\n        return (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_5__.undo)(state, dispatch);\n      },\n      redo: () => ({ state, dispatch }) => {\n        return (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_5__.redo)(state, dispatch);\n      }\n    };\n  },\n  addProseMirrorPlugins() {\n    return [(0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_5__.history)(this.options)];\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-z\": () => this.editor.commands.undo(),\n      \"Shift-Mod-z\": () => this.editor.commands.redo(),\n      \"Mod-y\": () => this.editor.commands.redo(),\n      // Russian keyboard layouts\n      \"Mod-\\u044F\": () => this.editor.commands.undo(),\n      \"Shift-Mod-\\u044F\": () => this.editor.commands.redo()\n    };\n  }\n});\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb25zL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN5QztBQUNZO0FBQ3JELHFCQUFxQixtREFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0RBQU07QUFDaEIsaUJBQWlCLHVEQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxvQkFBb0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxPQUFPO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGlCQUFpQjtBQUNyRSxvREFBb0QsdUJBQXVCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx1QkFBdUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUN1RDtBQUNKO0FBQ25ELGlCQUFpQixtREFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFlBQVksaUVBQVU7QUFDdEI7QUFDQSxDQUFDOztBQUVEO0FBQ3VEO0FBQ3VCO0FBQ2xCO0FBQzVELFlBQVksbURBQVU7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QWUsd0RBQUk7QUFDbkIsT0FBTztBQUNQLHFCQUFxQixpQkFBaUI7QUFDdEMsZUFBZSx3REFBSTtBQUNuQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsWUFBWSwyREFBTztBQUNuQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBVUM7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL21vcnRvbm1hYnVtYm8vRG93bmxvYWRzL3Rlc3RpbWlub255LXdlYjFfMTAtbWFpbi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb25zL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2NoYXJhY3Rlci1jb3VudC9jaGFyYWN0ZXItY291bnQudHNcbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbnZhciBDaGFyYWN0ZXJDb3VudCA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiBcImNoYXJhY3RlckNvdW50XCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbWl0OiBudWxsLFxuICAgICAgbW9kZTogXCJ0ZXh0U2l6ZVwiLFxuICAgICAgdGV4dENvdW50ZXI6ICh0ZXh0KSA9PiB0ZXh0Lmxlbmd0aCxcbiAgICAgIHdvcmRDb3VudGVyOiAodGV4dCkgPT4gdGV4dC5zcGxpdChcIiBcIikuZmlsdGVyKCh3b3JkKSA9PiB3b3JkICE9PSBcIlwiKS5sZW5ndGhcbiAgICB9O1xuICB9LFxuICBhZGRTdG9yYWdlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjaGFyYWN0ZXJzOiAoKSA9PiAwLFxuICAgICAgd29yZHM6ICgpID0+IDBcbiAgICB9O1xuICB9LFxuICBvbkJlZm9yZUNyZWF0ZSgpIHtcbiAgICB0aGlzLnN0b3JhZ2UuY2hhcmFjdGVycyA9IChvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubm9kZSkgfHwgdGhpcy5lZGl0b3Iuc3RhdGUuZG9jO1xuICAgICAgY29uc3QgbW9kZSA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGUpIHx8IHRoaXMub3B0aW9ucy5tb2RlO1xuICAgICAgaWYgKG1vZGUgPT09IFwidGV4dFNpemVcIikge1xuICAgICAgICBjb25zdCB0ZXh0ID0gbm9kZS50ZXh0QmV0d2VlbigwLCBub2RlLmNvbnRlbnQuc2l6ZSwgdm9pZCAwLCBcIiBcIik7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudGV4dENvdW50ZXIodGV4dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZS5ub2RlU2l6ZTtcbiAgICB9O1xuICAgIHRoaXMuc3RvcmFnZS53b3JkcyA9IChvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubm9kZSkgfHwgdGhpcy5lZGl0b3Iuc3RhdGUuZG9jO1xuICAgICAgY29uc3QgdGV4dCA9IG5vZGUudGV4dEJldHdlZW4oMCwgbm9kZS5jb250ZW50LnNpemUsIFwiIFwiLCBcIiBcIik7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndvcmRDb3VudGVyKHRleHQpO1xuICAgIH07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICBsZXQgaW5pdGlhbEV2YWx1YXRpb25Eb25lID0gZmFsc2U7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoXCJjaGFyYWN0ZXJDb3VudFwiKSxcbiAgICAgICAgYXBwZW5kVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbnMsIG9sZFN0YXRlLCBuZXdTdGF0ZSkgPT4ge1xuICAgICAgICAgIGlmIChpbml0aWFsRXZhbHVhdGlvbkRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbGltaXQgPSB0aGlzLm9wdGlvbnMubGltaXQ7XG4gICAgICAgICAgaWYgKGxpbWl0ID09PSBudWxsIHx8IGxpbWl0ID09PSB2b2lkIDAgfHwgbGltaXQgPT09IDApIHtcbiAgICAgICAgICAgIGluaXRpYWxFdmFsdWF0aW9uRG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGluaXRpYWxDb250ZW50U2l6ZSA9IHRoaXMuc3RvcmFnZS5jaGFyYWN0ZXJzKHsgbm9kZTogbmV3U3RhdGUuZG9jIH0pO1xuICAgICAgICAgIGlmIChpbml0aWFsQ29udGVudFNpemUgPiBsaW1pdCkge1xuICAgICAgICAgICAgY29uc3Qgb3ZlciA9IGluaXRpYWxDb250ZW50U2l6ZSAtIGxpbWl0O1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IDA7XG4gICAgICAgICAgICBjb25zdCB0byA9IG92ZXI7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIGBbQ2hhcmFjdGVyQ291bnRdIEluaXRpYWwgY29udGVudCBleGNlZWRlZCBsaW1pdCBvZiAke2xpbWl0fSBjaGFyYWN0ZXJzLiBDb250ZW50IHdhcyBhdXRvbWF0aWNhbGx5IHRyaW1tZWQuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHRyID0gbmV3U3RhdGUudHIuZGVsZXRlUmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICAgICAgaW5pdGlhbEV2YWx1YXRpb25Eb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5pdGlhbEV2YWx1YXRpb25Eb25lID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZmlsdGVyVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbiwgc3RhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCBsaW1pdCA9IHRoaXMub3B0aW9ucy5saW1pdDtcbiAgICAgICAgICBpZiAoIXRyYW5zYWN0aW9uLmRvY0NoYW5nZWQgfHwgbGltaXQgPT09IDAgfHwgbGltaXQgPT09IG51bGwgfHwgbGltaXQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG9sZFNpemUgPSB0aGlzLnN0b3JhZ2UuY2hhcmFjdGVycyh7IG5vZGU6IHN0YXRlLmRvYyB9KTtcbiAgICAgICAgICBjb25zdCBuZXdTaXplID0gdGhpcy5zdG9yYWdlLmNoYXJhY3RlcnMoeyBub2RlOiB0cmFuc2FjdGlvbi5kb2MgfSk7XG4gICAgICAgICAgaWYgKG5ld1NpemUgPD0gbGltaXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2xkU2l6ZSA+IGxpbWl0ICYmIG5ld1NpemUgPiBsaW1pdCAmJiBuZXdTaXplIDw9IG9sZFNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2xkU2l6ZSA+IGxpbWl0ICYmIG5ld1NpemUgPiBsaW1pdCAmJiBuZXdTaXplID4gb2xkU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpc1Bhc3RlID0gdHJhbnNhY3Rpb24uZ2V0TWV0YShcInBhc3RlXCIpO1xuICAgICAgICAgIGlmICghaXNQYXN0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwb3MgPSB0cmFuc2FjdGlvbi5zZWxlY3Rpb24uJGhlYWQucG9zO1xuICAgICAgICAgIGNvbnN0IG92ZXIgPSBuZXdTaXplIC0gbGltaXQ7XG4gICAgICAgICAgY29uc3QgZnJvbSA9IHBvcyAtIG92ZXI7XG4gICAgICAgICAgY29uc3QgdG8gPSBwb3M7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZGVsZXRlUmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRTaXplID0gdGhpcy5zdG9yYWdlLmNoYXJhY3RlcnMoeyBub2RlOiB0cmFuc2FjdGlvbi5kb2MgfSk7XG4gICAgICAgICAgaWYgKHVwZGF0ZWRTaXplID4gbGltaXQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9kcm9wLWN1cnNvci9kcm9wLWN1cnNvci50c1xuaW1wb3J0IHsgRXh0ZW5zaW9uIGFzIEV4dGVuc2lvbjIgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBkcm9wQ3Vyc29yIH0gZnJvbSBcIkB0aXB0YXAvcG0vZHJvcGN1cnNvclwiO1xudmFyIERyb3BjdXJzb3IgPSBFeHRlbnNpb24yLmNyZWF0ZSh7XG4gIG5hbWU6IFwiZHJvcEN1cnNvclwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogXCJjdXJyZW50Q29sb3JcIixcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgY2xhc3M6IHZvaWQgMFxuICAgIH07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW2Ryb3BDdXJzb3IodGhpcy5vcHRpb25zKV07XG4gIH1cbn0pO1xuXG4vLyBzcmMvZm9jdXMvZm9jdXMudHNcbmltcG9ydCB7IEV4dGVuc2lvbiBhcyBFeHRlbnNpb24zIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgUGx1Z2luIGFzIFBsdWdpbjIsIFBsdWdpbktleSBhcyBQbHVnaW5LZXkyIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbmltcG9ydCB7IERlY29yYXRpb24sIERlY29yYXRpb25TZXQgfSBmcm9tIFwiQHRpcHRhcC9wbS92aWV3XCI7XG52YXIgRm9jdXMgPSBFeHRlbnNpb24zLmNyZWF0ZSh7XG4gIG5hbWU6IFwiZm9jdXNcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3NOYW1lOiBcImhhcy1mb2N1c1wiLFxuICAgICAgbW9kZTogXCJhbGxcIlxuICAgIH07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbjIoe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkyKFwiZm9jdXNcIiksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgZGVjb3JhdGlvbnM6ICh7IGRvYywgc2VsZWN0aW9uIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaXNFZGl0YWJsZSwgaXNGb2N1c2VkIH0gPSB0aGlzLmVkaXRvcjtcbiAgICAgICAgICAgIGNvbnN0IHsgYW5jaG9yIH0gPSBzZWxlY3Rpb247XG4gICAgICAgICAgICBjb25zdCBkZWNvcmF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgaWYgKCFpc0VkaXRhYmxlIHx8ICFpc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuY3JlYXRlKGRvYywgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1heExldmVscyA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1vZGUgPT09IFwiZGVlcGVzdFwiKSB7XG4gICAgICAgICAgICAgIGRvYy5kZXNjZW5kYW50cygobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudCA9IGFuY2hvciA+PSBwb3MgJiYgYW5jaG9yIDw9IHBvcyArIG5vZGUubm9kZVNpemUgLSAxO1xuICAgICAgICAgICAgICAgIGlmICghaXNDdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1heExldmVscyArPSAxO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjdXJyZW50TGV2ZWwgPSAwO1xuICAgICAgICAgICAgZG9jLmRlc2NlbmRhbnRzKChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudCA9IGFuY2hvciA+PSBwb3MgJiYgYW5jaG9yIDw9IHBvcyArIG5vZGUubm9kZVNpemUgLSAxO1xuICAgICAgICAgICAgICBpZiAoIWlzQ3VycmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgKz0gMTtcbiAgICAgICAgICAgICAgY29uc3Qgb3V0T2ZTY29wZSA9IHRoaXMub3B0aW9ucy5tb2RlID09PSBcImRlZXBlc3RcIiAmJiBtYXhMZXZlbHMgLSBjdXJyZW50TGV2ZWwgPiAwIHx8IHRoaXMub3B0aW9ucy5tb2RlID09PSBcInNoYWxsb3dlc3RcIiAmJiBjdXJyZW50TGV2ZWwgPiAxO1xuICAgICAgICAgICAgICBpZiAob3V0T2ZTY29wZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gXCJkZWVwZXN0XCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVjb3JhdGlvbnMucHVzaChcbiAgICAgICAgICAgICAgICBEZWNvcmF0aW9uLm5vZGUocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCB7XG4gICAgICAgICAgICAgICAgICBjbGFzczogdGhpcy5vcHRpb25zLmNsYXNzTmFtZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShkb2MsIGRlY29yYXRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9nYXAtY3Vyc29yL2dhcC1jdXJzb3IudHNcbmltcG9ydCB7IGNhbGxPclJldHVybiwgRXh0ZW5zaW9uIGFzIEV4dGVuc2lvbjQsIGdldEV4dGVuc2lvbkZpZWxkIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgZ2FwQ3Vyc29yIH0gZnJvbSBcIkB0aXB0YXAvcG0vZ2FwY3Vyc29yXCI7XG52YXIgR2FwY3Vyc29yID0gRXh0ZW5zaW9uNC5jcmVhdGUoe1xuICBuYW1lOiBcImdhcEN1cnNvclwiLFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtnYXBDdXJzb3IoKV07XG4gIH0sXG4gIGV4dGVuZE5vZGVTY2hlbWEoZXh0ZW5zaW9uKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2VcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBhbGxvd0dhcEN1cnNvcjogKF9hID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJhbGxvd0dhcEN1cnNvclwiLCBjb250ZXh0KSkpICE9IG51bGwgPyBfYSA6IG51bGxcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL3BsYWNlaG9sZGVyL3BsYWNlaG9sZGVyLnRzXG5pbXBvcnQgeyBFeHRlbnNpb24gYXMgRXh0ZW5zaW9uNSwgaXNOb2RlRW1wdHkgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luMywgUGx1Z2luS2V5IGFzIFBsdWdpbktleTMgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuaW1wb3J0IHsgRGVjb3JhdGlvbiBhcyBEZWNvcmF0aW9uMiwgRGVjb3JhdGlvblNldCBhcyBEZWNvcmF0aW9uU2V0MiB9IGZyb20gXCJAdGlwdGFwL3BtL3ZpZXdcIjtcbnZhciBQbGFjZWhvbGRlciA9IEV4dGVuc2lvbjUuY3JlYXRlKHtcbiAgbmFtZTogXCJwbGFjZWhvbGRlclwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlbXB0eUVkaXRvckNsYXNzOiBcImlzLWVkaXRvci1lbXB0eVwiLFxuICAgICAgZW1wdHlOb2RlQ2xhc3M6IFwiaXMtZW1wdHlcIixcbiAgICAgIHBsYWNlaG9sZGVyOiBcIldyaXRlIHNvbWV0aGluZyBcXHUyMDI2XCIsXG4gICAgICBzaG93T25seVdoZW5FZGl0YWJsZTogdHJ1ZSxcbiAgICAgIHNob3dPbmx5Q3VycmVudDogdHJ1ZSxcbiAgICAgIGluY2x1ZGVDaGlsZHJlbjogZmFsc2VcbiAgICB9O1xuICB9LFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW4zKHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5MyhcInBsYWNlaG9sZGVyXCIpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGRlY29yYXRpb25zOiAoeyBkb2MsIHNlbGVjdGlvbiB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmVkaXRvci5pc0VkaXRhYmxlIHx8ICF0aGlzLm9wdGlvbnMuc2hvd09ubHlXaGVuRWRpdGFibGU7XG4gICAgICAgICAgICBjb25zdCB7IGFuY2hvciB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgZGVjb3JhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGlmICghYWN0aXZlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNFbXB0eURvYyA9IHRoaXMuZWRpdG9yLmlzRW1wdHk7XG4gICAgICAgICAgICBkb2MuZGVzY2VuZGFudHMoKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBoYXNBbmNob3IgPSBhbmNob3IgPj0gcG9zICYmIGFuY2hvciA8PSBwb3MgKyBub2RlLm5vZGVTaXplO1xuICAgICAgICAgICAgICBjb25zdCBpc0VtcHR5ID0gIW5vZGUuaXNMZWFmICYmIGlzTm9kZUVtcHR5KG5vZGUpO1xuICAgICAgICAgICAgICBpZiAoKGhhc0FuY2hvciB8fCAhdGhpcy5vcHRpb25zLnNob3dPbmx5Q3VycmVudCkgJiYgaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzZXMgPSBbdGhpcy5vcHRpb25zLmVtcHR5Tm9kZUNsYXNzXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eURvYykge1xuICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKHRoaXMub3B0aW9ucy5lbXB0eUVkaXRvckNsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGVjb3JhdGlvbiA9IERlY29yYXRpb24yLm5vZGUocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCB7XG4gICAgICAgICAgICAgICAgICBjbGFzczogY2xhc3Nlcy5qb2luKFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgIFwiZGF0YS1wbGFjZWhvbGRlclwiOiB0eXBlb2YgdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIoe1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgIGhhc0FuY2hvclxuICAgICAgICAgICAgICAgICAgfSkgOiB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKGRlY29yYXRpb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaW5jbHVkZUNoaWxkcmVuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldDIuY3JlYXRlKGRvYywgZGVjb3JhdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL3NlbGVjdGlvbi9zZWxlY3Rpb24udHNcbmltcG9ydCB7IEV4dGVuc2lvbiBhcyBFeHRlbnNpb242LCBpc05vZGVTZWxlY3Rpb24gfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luNCwgUGx1Z2luS2V5IGFzIFBsdWdpbktleTQgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuaW1wb3J0IHsgRGVjb3JhdGlvbiBhcyBEZWNvcmF0aW9uMywgRGVjb3JhdGlvblNldCBhcyBEZWNvcmF0aW9uU2V0MyB9IGZyb20gXCJAdGlwdGFwL3BtL3ZpZXdcIjtcbnZhciBTZWxlY3Rpb24gPSBFeHRlbnNpb242LmNyZWF0ZSh7XG4gIG5hbWU6IFwic2VsZWN0aW9uXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzTmFtZTogXCJzZWxlY3Rpb25cIlxuICAgIH07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICBjb25zdCB7IGVkaXRvciwgb3B0aW9ucyB9ID0gdGhpcztcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbjQoe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXk0KFwic2VsZWN0aW9uXCIpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGRlY29yYXRpb25zKHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLmVtcHR5IHx8IGVkaXRvci5pc0ZvY3VzZWQgfHwgIWVkaXRvci5pc0VkaXRhYmxlIHx8IGlzTm9kZVNlbGVjdGlvbihzdGF0ZS5zZWxlY3Rpb24pIHx8IGVkaXRvci52aWV3LmRyYWdnaW5nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQzLmNyZWF0ZShzdGF0ZS5kb2MsIFtcbiAgICAgICAgICAgICAgRGVjb3JhdGlvbjMuaW5saW5lKHN0YXRlLnNlbGVjdGlvbi5mcm9tLCBzdGF0ZS5zZWxlY3Rpb24udG8sIHtcbiAgICAgICAgICAgICAgICBjbGFzczogb3B0aW9ucy5jbGFzc05hbWVcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL3RyYWlsaW5nLW5vZGUvdHJhaWxpbmctbm9kZS50c1xuaW1wb3J0IHsgRXh0ZW5zaW9uIGFzIEV4dGVuc2lvbjcgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luNSwgUGx1Z2luS2V5IGFzIFBsdWdpbktleTUgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuZnVuY3Rpb24gbm9kZUVxdWFsc1R5cGUoeyB0eXBlcywgbm9kZSB9KSB7XG4gIHJldHVybiBub2RlICYmIEFycmF5LmlzQXJyYXkodHlwZXMpICYmIHR5cGVzLmluY2x1ZGVzKG5vZGUudHlwZSkgfHwgKG5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGUudHlwZSkgPT09IHR5cGVzO1xufVxudmFyIFRyYWlsaW5nTm9kZSA9IEV4dGVuc2lvbjcuY3JlYXRlKHtcbiAgbmFtZTogXCJ0cmFpbGluZ05vZGVcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogdm9pZCAwLFxuICAgICAgbm90QWZ0ZXI6IFtdXG4gICAgfTtcbiAgfSxcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwbHVnaW4gPSBuZXcgUGx1Z2luS2V5NSh0aGlzLm5hbWUpO1xuICAgIGNvbnN0IGRlZmF1bHROb2RlID0gKChfYSA9IHRoaXMuZWRpdG9yLnNjaGVtYS50b3BOb2RlVHlwZS5jb250ZW50TWF0Y2guZGVmYXVsdFR5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5uYW1lKSB8fCB0aGlzLm9wdGlvbnMubm9kZSB8fCBcInBhcmFncmFwaFwiO1xuICAgIGNvbnN0IGRpc2FibGVkTm9kZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLmVkaXRvci5zY2hlbWEubm9kZXMpLm1hcCgoWywgdmFsdWVdKSA9PiB2YWx1ZSkuZmlsdGVyKChub2RlKSA9PiAodGhpcy5vcHRpb25zLm5vdEFmdGVyIHx8IFtdKS5jb25jYXQoZGVmYXVsdE5vZGUpLmluY2x1ZGVzKG5vZGUubmFtZSkpO1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luNSh7XG4gICAgICAgIGtleTogcGx1Z2luLFxuICAgICAgICBhcHBlbmRUcmFuc2FjdGlvbjogKF8sIF9fLCBzdGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgZG9jLCB0ciwgc2NoZW1hIH0gPSBzdGF0ZTtcbiAgICAgICAgICBjb25zdCBzaG91bGRJbnNlcnROb2RlQXRFbmQgPSBwbHVnaW4uZ2V0U3RhdGUoc3RhdGUpO1xuICAgICAgICAgIGNvbnN0IGVuZFBvc2l0aW9uID0gZG9jLmNvbnRlbnQuc2l6ZTtcbiAgICAgICAgICBjb25zdCB0eXBlID0gc2NoZW1hLm5vZGVzW2RlZmF1bHROb2RlXTtcbiAgICAgICAgICBpZiAoIXNob3VsZEluc2VydE5vZGVBdEVuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHIuaW5zZXJ0KGVuZFBvc2l0aW9uLCB0eXBlLmNyZWF0ZSgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICBpbml0OiAoXywgc3RhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3ROb2RlID0gc3RhdGUudHIuZG9jLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIHJldHVybiAhbm9kZUVxdWFsc1R5cGUoeyBub2RlOiBsYXN0Tm9kZSwgdHlwZXM6IGRpc2FibGVkTm9kZXMgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhcHBseTogKHRyLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0ci5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxhc3ROb2RlID0gdHIuZG9jLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIHJldHVybiAhbm9kZUVxdWFsc1R5cGUoeyBub2RlOiBsYXN0Tm9kZSwgdHlwZXM6IGRpc2FibGVkTm9kZXMgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvdW5kby1yZWRvL3VuZG8tcmVkby50c1xuaW1wb3J0IHsgRXh0ZW5zaW9uIGFzIEV4dGVuc2lvbjggfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBoaXN0b3J5LCByZWRvLCB1bmRvIH0gZnJvbSBcIkB0aXB0YXAvcG0vaGlzdG9yeVwiO1xudmFyIFVuZG9SZWRvID0gRXh0ZW5zaW9uOC5jcmVhdGUoe1xuICBuYW1lOiBcInVuZG9SZWRvXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlcHRoOiAxMDAsXG4gICAgICBuZXdHcm91cERlbGF5OiA1MDBcbiAgICB9O1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdW5kbzogKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHVuZG8oc3RhdGUsIGRpc3BhdGNoKTtcbiAgICAgIH0sXG4gICAgICByZWRvOiAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICByZXR1cm4gcmVkbyhzdGF0ZSwgZGlzcGF0Y2gpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW2hpc3RvcnkodGhpcy5vcHRpb25zKV07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcIk1vZC16XCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnVuZG8oKSxcbiAgICAgIFwiU2hpZnQtTW9kLXpcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMucmVkbygpLFxuICAgICAgXCJNb2QteVwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKCksXG4gICAgICAvLyBSdXNzaWFuIGtleWJvYXJkIGxheW91dHNcbiAgICAgIFwiTW9kLVxcdTA0NEZcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudW5kbygpLFxuICAgICAgXCJTaGlmdC1Nb2QtXFx1MDQ0RlwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKClcbiAgICB9O1xuICB9XG59KTtcbmV4cG9ydCB7XG4gIENoYXJhY3RlckNvdW50LFxuICBEcm9wY3Vyc29yLFxuICBGb2N1cyxcbiAgR2FwY3Vyc29yLFxuICBQbGFjZWhvbGRlcixcbiAgU2VsZWN0aW9uLFxuICBUcmFpbGluZ05vZGUsXG4gIFVuZG9SZWRvXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extensions/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/commands/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/commands/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoJoin: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.autoJoin),\n/* harmony export */   baseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.baseKeymap),\n/* harmony export */   chainCommands: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.chainCommands),\n/* harmony export */   createParagraphNear: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.createParagraphNear),\n/* harmony export */   deleteSelection: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.deleteSelection),\n/* harmony export */   exitCode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.exitCode),\n/* harmony export */   joinBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinBackward),\n/* harmony export */   joinDown: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinDown),\n/* harmony export */   joinForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinForward),\n/* harmony export */   joinTextblockBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinTextblockBackward),\n/* harmony export */   joinTextblockForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinTextblockForward),\n/* harmony export */   joinUp: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinUp),\n/* harmony export */   lift: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.lift),\n/* harmony export */   liftEmptyBlock: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.liftEmptyBlock),\n/* harmony export */   macBaseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.macBaseKeymap),\n/* harmony export */   newlineInCode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.newlineInCode),\n/* harmony export */   pcBaseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.pcBaseKeymap),\n/* harmony export */   selectAll: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectAll),\n/* harmony export */   selectNodeBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectNodeBackward),\n/* harmony export */   selectNodeForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectNodeForward),\n/* harmony export */   selectParentNode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectParentNode),\n/* harmony export */   selectTextblockEnd: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectTextblockEnd),\n/* harmony export */   selectTextblockStart: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectTextblockStart),\n/* harmony export */   setBlockType: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.setBlockType),\n/* harmony export */   splitBlock: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlock),\n/* harmony export */   splitBlockAs: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlockAs),\n/* harmony export */   splitBlockKeepMarks: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlockKeepMarks),\n/* harmony export */   toggleMark: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.toggleMark),\n/* harmony export */   wrapIn: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.wrapIn)\n/* harmony export */ });\n/* harmony import */ var prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-commands */ \"(ssr)/./node_modules/prosemirror-commands/dist/index.js\");\n// commands/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2NvbW1hbmRzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3FDIiwic291cmNlcyI6WyIvVXNlcnMvbW9ydG9ubWFidW1iby9Eb3dubG9hZHMvdGVzdGltaW5vbnktd2ViMV8xMC1tYWluL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2Rpc3QvY29tbWFuZHMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY29tbWFuZHMvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1jb21tYW5kc1wiO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/commands/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/dropcursor/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/dropcursor/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dropCursor: () => (/* reexport safe */ prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_0__.dropCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-dropcursor */ \"(ssr)/./node_modules/prosemirror-dropcursor/dist/index.js\");\n// dropcursor/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2Ryb3BjdXJzb3IvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUN1QyIsInNvdXJjZXMiOlsiL1VzZXJzL21vcnRvbm1hYnVtYm8vRG93bmxvYWRzL3Rlc3RpbWlub255LXdlYjFfMTAtbWFpbi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2Ryb3BjdXJzb3IvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZHJvcGN1cnNvci9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInByb3NlbWlycm9yLWRyb3BjdXJzb3JcIjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/dropcursor/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/gapcursor/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/gapcursor/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GapCursor: () => (/* reexport safe */ prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__.GapCursor),\n/* harmony export */   gapCursor: () => (/* reexport safe */ prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__.gapCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-gapcursor */ \"(ssr)/./node_modules/prosemirror-gapcursor/dist/index.js\");\n// gapcursor/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2dhcGN1cnNvci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNzQyIsInNvdXJjZXMiOlsiL1VzZXJzL21vcnRvbm1hYnVtYm8vRG93bmxvYWRzL3Rlc3RpbWlub255LXdlYjFfMTAtbWFpbi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2dhcGN1cnNvci9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBnYXBjdXJzb3IvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1nYXBjdXJzb3JcIjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/gapcursor/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/history/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/history/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeHistory: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.closeHistory),\n/* harmony export */   history: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.history),\n/* harmony export */   redo: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redo),\n/* harmony export */   redoDepth: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redoDepth),\n/* harmony export */   redoNoScroll: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redoNoScroll),\n/* harmony export */   undo: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undo),\n/* harmony export */   undoDepth: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undoDepth),\n/* harmony export */   undoNoScroll: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undoNoScroll)\n/* harmony export */ });\n/* harmony import */ var prosemirror_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-history */ \"(ssr)/./node_modules/prosemirror-history/dist/index.js\");\n// history/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2hpc3RvcnkvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDb0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tb3J0b25tYWJ1bWJvL0Rvd25sb2Fkcy90ZXN0aW1pbm9ueS13ZWIxXzEwLW1haW4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vZGlzdC9oaXN0b3J5L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGhpc3RvcnkvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1oaXN0b3J5XCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/history/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/keymap/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/keymap/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keydownHandler: () => (/* reexport safe */ prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keydownHandler),\n/* harmony export */   keymap: () => (/* reexport safe */ prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keymap)\n/* harmony export */ });\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-keymap */ \"(ssr)/./node_modules/prosemirror-keymap/dist/index.js\");\n// keymap/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2tleW1hcC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNtQyIsInNvdXJjZXMiOlsiL1VzZXJzL21vcnRvbm1hYnVtYm8vRG93bmxvYWRzL3Rlc3RpbWlub255LXdlYjFfMTAtbWFpbi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2tleW1hcC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBrZXltYXAvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1rZXltYXBcIjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/keymap/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/model/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/model/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentMatch: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ContentMatch),\n/* harmony export */   DOMParser: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser),\n/* harmony export */   DOMSerializer: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer),\n/* harmony export */   Fragment: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment),\n/* harmony export */   Mark: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark),\n/* harmony export */   MarkType: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.MarkType),\n/* harmony export */   Node: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Node),\n/* harmony export */   NodeRange: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange),\n/* harmony export */   NodeType: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeType),\n/* harmony export */   ReplaceError: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ReplaceError),\n/* harmony export */   ResolvedPos: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ResolvedPos),\n/* harmony export */   Schema: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Schema),\n/* harmony export */   Slice: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice)\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n// model/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L21vZGVsL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDa0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tb3J0b25tYWJ1bWJvL0Rvd25sb2Fkcy90ZXN0aW1pbm9ueS13ZWIxXzEwLW1haW4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vZGlzdC9tb2RlbC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBtb2RlbC9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInByb3NlbWlycm9yLW1vZGVsXCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/model/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/schema-list/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/schema-list/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addListNodes: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.addListNodes),\n/* harmony export */   bulletList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.bulletList),\n/* harmony export */   liftListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.liftListItem),\n/* harmony export */   listItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.listItem),\n/* harmony export */   orderedList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.orderedList),\n/* harmony export */   sinkListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.sinkListItem),\n/* harmony export */   splitListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.splitListItem),\n/* harmony export */   splitListItemKeepMarks: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.splitListItemKeepMarks),\n/* harmony export */   wrapInList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.wrapInList),\n/* harmony export */   wrapRangeInList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.wrapRangeInList)\n/* harmony export */ });\n/* harmony import */ var prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-schema-list */ \"(ssr)/./node_modules/prosemirror-schema-list/dist/index.js\");\n// schema-list/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L3NjaGVtYS1saXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDd0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tb3J0b25tYWJ1bWJvL0Rvd25sb2Fkcy90ZXN0aW1pbm9ueS13ZWIxXzEwLW1haW4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vZGlzdC9zY2hlbWEtbGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzY2hlbWEtbGlzdC9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInByb3NlbWlycm9yLXNjaGVtYS1saXN0XCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/schema-list/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/state/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/state/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AllSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection),\n/* harmony export */   EditorState: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState),\n/* harmony export */   NodeSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection),\n/* harmony export */   Plugin: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin),\n/* harmony export */   PluginKey: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey),\n/* harmony export */   Selection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection),\n/* harmony export */   SelectionRange: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.SelectionRange),\n/* harmony export */   TextSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection),\n/* harmony export */   Transaction: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Transaction)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n// state/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L3N0YXRlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNrQyIsInNvdXJjZXMiOlsiL1VzZXJzL21vcnRvbm1hYnVtYm8vRG93bmxvYWRzL3Rlc3RpbWlub255LXdlYjFfMTAtbWFpbi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L3N0YXRlL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHN0YXRlL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3Itc3RhdGVcIjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/transform/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/transform/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AddMarkStep),\n/* harmony export */   AddNodeMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AddNodeMarkStep),\n/* harmony export */   AttrStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AttrStep),\n/* harmony export */   DocAttrStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.DocAttrStep),\n/* harmony export */   MapResult: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.MapResult),\n/* harmony export */   Mapping: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Mapping),\n/* harmony export */   RemoveMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveMarkStep),\n/* harmony export */   RemoveNodeMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveNodeMarkStep),\n/* harmony export */   ReplaceAroundStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep),\n/* harmony export */   ReplaceStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceStep),\n/* harmony export */   Step: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Step),\n/* harmony export */   StepMap: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.StepMap),\n/* harmony export */   StepResult: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.StepResult),\n/* harmony export */   Transform: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Transform),\n/* harmony export */   TransformError: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.TransformError),\n/* harmony export */   canJoin: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin),\n/* harmony export */   canSplit: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit),\n/* harmony export */   dropPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.dropPoint),\n/* harmony export */   findWrapping: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping),\n/* harmony export */   insertPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.insertPoint),\n/* harmony export */   joinPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint),\n/* harmony export */   liftTarget: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget),\n/* harmony export */   replaceStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n// transform/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L3RyYW5zZm9ybS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNzQyIsInNvdXJjZXMiOlsiL1VzZXJzL21vcnRvbm1hYnVtYm8vRG93bmxvYWRzL3Rlc3RpbWlub255LXdlYjFfMTAtbWFpbi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L3RyYW5zZm9ybS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0cmFuc2Zvcm0vaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci10cmFuc2Zvcm1cIjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/transform/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/view/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/view/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoration: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.Decoration),\n/* harmony export */   DecorationSet: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.DecorationSet),\n/* harmony export */   EditorView: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.EditorView),\n/* harmony export */   __endComposition: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__endComposition),\n/* harmony export */   __parseFromClipboard: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__parseFromClipboard)\n/* harmony export */ });\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/prosemirror-view/dist/index.js\");\n// view/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L3ZpZXcvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDaUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tb3J0b25tYWJ1bWJvL0Rvd25sb2Fkcy90ZXN0aW1pbm9ueS13ZWIxXzEwLW1haW4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vZGlzdC92aWV3L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHZpZXcvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci12aWV3XCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/view/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/react/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@tiptap/react/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommandManager: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.CommandManager),\n/* harmony export */   Editor: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Editor),\n/* harmony export */   EditorConsumer: () => (/* binding */ EditorConsumer),\n/* harmony export */   EditorContent: () => (/* binding */ EditorContent),\n/* harmony export */   EditorContext: () => (/* binding */ EditorContext),\n/* harmony export */   EditorProvider: () => (/* binding */ EditorProvider),\n/* harmony export */   Extendable: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Extendable),\n/* harmony export */   Extension: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Extension),\n/* harmony export */   Fragment: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Fragment),\n/* harmony export */   InputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.InputRule),\n/* harmony export */   Mark: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Mark),\n/* harmony export */   MarkView: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.MarkView),\n/* harmony export */   MarkViewContent: () => (/* binding */ MarkViewContent),\n/* harmony export */   Node: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Node),\n/* harmony export */   NodePos: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.NodePos),\n/* harmony export */   NodeView: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.NodeView),\n/* harmony export */   NodeViewContent: () => (/* binding */ NodeViewContent),\n/* harmony export */   NodeViewWrapper: () => (/* binding */ NodeViewWrapper),\n/* harmony export */   PasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.PasteRule),\n/* harmony export */   PureEditorContent: () => (/* binding */ PureEditorContent),\n/* harmony export */   ReactMarkView: () => (/* binding */ ReactMarkView),\n/* harmony export */   ReactMarkViewContext: () => (/* binding */ ReactMarkViewContext),\n/* harmony export */   ReactMarkViewRenderer: () => (/* binding */ ReactMarkViewRenderer),\n/* harmony export */   ReactNodeView: () => (/* binding */ ReactNodeView),\n/* harmony export */   ReactNodeViewContentProvider: () => (/* binding */ ReactNodeViewContentProvider),\n/* harmony export */   ReactNodeViewContext: () => (/* binding */ ReactNodeViewContext),\n/* harmony export */   ReactNodeViewRenderer: () => (/* binding */ ReactNodeViewRenderer),\n/* harmony export */   ReactRenderer: () => (/* binding */ ReactRenderer),\n/* harmony export */   Tracker: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Tracker),\n/* harmony export */   callOrReturn: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.callOrReturn),\n/* harmony export */   canInsertNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.canInsertNode),\n/* harmony export */   combineTransactionSteps: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.combineTransactionSteps),\n/* harmony export */   commands: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.commands),\n/* harmony export */   createAtomBlockMarkdownSpec: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createAtomBlockMarkdownSpec),\n/* harmony export */   createBlockMarkdownSpec: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createBlockMarkdownSpec),\n/* harmony export */   createChainableState: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createChainableState),\n/* harmony export */   createDocument: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createDocument),\n/* harmony export */   createElement: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createElement),\n/* harmony export */   createInlineMarkdownSpec: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createInlineMarkdownSpec),\n/* harmony export */   createNodeFromContent: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createNodeFromContent),\n/* harmony export */   createStyleTag: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createStyleTag),\n/* harmony export */   defaultBlockAt: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.defaultBlockAt),\n/* harmony export */   deleteProps: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.deleteProps),\n/* harmony export */   elementFromString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.elementFromString),\n/* harmony export */   escapeForRegEx: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.escapeForRegEx),\n/* harmony export */   extensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.extensions),\n/* harmony export */   findChildren: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.findChildren),\n/* harmony export */   findChildrenInRange: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.findChildrenInRange),\n/* harmony export */   findDuplicates: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.findDuplicates),\n/* harmony export */   findParentNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.findParentNode),\n/* harmony export */   findParentNodeClosestToPos: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.findParentNodeClosestToPos),\n/* harmony export */   flattenExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.flattenExtensions),\n/* harmony export */   fromString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.fromString),\n/* harmony export */   generateHTML: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.generateHTML),\n/* harmony export */   generateJSON: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.generateJSON),\n/* harmony export */   generateText: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.generateText),\n/* harmony export */   getAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getAttributes),\n/* harmony export */   getAttributesFromExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getAttributesFromExtensions),\n/* harmony export */   getChangedRanges: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getChangedRanges),\n/* harmony export */   getDebugJSON: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getDebugJSON),\n/* harmony export */   getExtensionField: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getExtensionField),\n/* harmony export */   getHTMLFromFragment: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getHTMLFromFragment),\n/* harmony export */   getMarkAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getMarkAttributes),\n/* harmony export */   getMarkRange: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getMarkRange),\n/* harmony export */   getMarkType: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getMarkType),\n/* harmony export */   getMarksBetween: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getMarksBetween),\n/* harmony export */   getNodeAtPosition: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getNodeAtPosition),\n/* harmony export */   getNodeAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getNodeAttributes),\n/* harmony export */   getNodeType: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getNodeType),\n/* harmony export */   getRenderedAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getRenderedAttributes),\n/* harmony export */   getSchema: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getSchema),\n/* harmony export */   getSchemaByResolvedExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getSchemaByResolvedExtensions),\n/* harmony export */   getSchemaTypeByName: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getSchemaTypeByName),\n/* harmony export */   getSchemaTypeNameByName: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getSchemaTypeNameByName),\n/* harmony export */   getSplittedAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getSplittedAttributes),\n/* harmony export */   getText: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getText),\n/* harmony export */   getTextBetween: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getTextBetween),\n/* harmony export */   getTextContentFromNodes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getTextContentFromNodes),\n/* harmony export */   getTextSerializersFromSchema: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getTextSerializersFromSchema),\n/* harmony export */   h: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.h),\n/* harmony export */   injectExtensionAttributesToParseRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.injectExtensionAttributesToParseRule),\n/* harmony export */   inputRulesPlugin: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.inputRulesPlugin),\n/* harmony export */   isActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isActive),\n/* harmony export */   isAndroid: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isAndroid),\n/* harmony export */   isAtEndOfNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isAtEndOfNode),\n/* harmony export */   isAtStartOfNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isAtStartOfNode),\n/* harmony export */   isEmptyObject: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isEmptyObject),\n/* harmony export */   isExtensionRulesEnabled: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isExtensionRulesEnabled),\n/* harmony export */   isFunction: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isFunction),\n/* harmony export */   isList: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isList),\n/* harmony export */   isMacOS: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isMacOS),\n/* harmony export */   isMarkActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isMarkActive),\n/* harmony export */   isNodeActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isNodeActive),\n/* harmony export */   isNodeEmpty: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isNodeEmpty),\n/* harmony export */   isNodeSelection: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isNodeSelection),\n/* harmony export */   isNumber: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isNumber),\n/* harmony export */   isPlainObject: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isPlainObject),\n/* harmony export */   isRegExp: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isRegExp),\n/* harmony export */   isString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isString),\n/* harmony export */   isTextSelection: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isTextSelection),\n/* harmony export */   isiOS: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isiOS),\n/* harmony export */   markInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.markInputRule),\n/* harmony export */   markPasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.markPasteRule),\n/* harmony export */   markdown: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.markdown),\n/* harmony export */   mergeAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.mergeAttributes),\n/* harmony export */   mergeDeep: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.mergeDeep),\n/* harmony export */   minMax: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.minMax),\n/* harmony export */   nodeInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.nodeInputRule),\n/* harmony export */   nodePasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.nodePasteRule),\n/* harmony export */   objectIncludes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.objectIncludes),\n/* harmony export */   parseAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.parseAttributes),\n/* harmony export */   parseIndentedBlocks: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.parseIndentedBlocks),\n/* harmony export */   pasteRulesPlugin: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.pasteRulesPlugin),\n/* harmony export */   posToDOMRect: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.posToDOMRect),\n/* harmony export */   removeDuplicates: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.removeDuplicates),\n/* harmony export */   renderNestedMarkdownContent: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.renderNestedMarkdownContent),\n/* harmony export */   resolveExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.resolveExtensions),\n/* harmony export */   resolveFocusPosition: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.resolveFocusPosition),\n/* harmony export */   rewriteUnknownContent: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.rewriteUnknownContent),\n/* harmony export */   selectionToInsertionEnd: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.selectionToInsertionEnd),\n/* harmony export */   serializeAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.serializeAttributes),\n/* harmony export */   sortExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.sortExtensions),\n/* harmony export */   splitExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.splitExtensions),\n/* harmony export */   textInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.textInputRule),\n/* harmony export */   textPasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.textPasteRule),\n/* harmony export */   textblockTypeInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.textblockTypeInputRule),\n/* harmony export */   updateMarkViewAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.updateMarkViewAttributes),\n/* harmony export */   useCurrentEditor: () => (/* binding */ useCurrentEditor),\n/* harmony export */   useEditor: () => (/* binding */ useEditor),\n/* harmony export */   useEditorState: () => (/* binding */ useEditorState),\n/* harmony export */   useReactNodeView: () => (/* binding */ useReactNodeView),\n/* harmony export */   wrappingInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.wrappingInputRule)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var fast_deep_equal_es6_react_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fast-deep-equal/es6/react.js */ \"(ssr)/./node_modules/fast-deep-equal/es6/react.js\");\n/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/with-selector.js\");\n// src/Context.tsx\n\n\n// src/EditorContent.tsx\n\n\n\n\nvar mergeRefs = (...refs) => {\n  return (node) => {\n    refs.forEach((ref) => {\n      if (typeof ref === \"function\") {\n        ref(node);\n      } else if (ref) {\n        ;\n        ref.current = node;\n      }\n    });\n  };\n};\nvar Portals = ({ contentComponent }) => {\n  const renderers = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore)(\n    contentComponent.subscribe,\n    contentComponent.getSnapshot,\n    contentComponent.getServerSnapshot\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, { children: Object.values(renderers) });\n};\nfunction getInstance() {\n  const subscribers = /* @__PURE__ */ new Set();\n  let renderers = {};\n  return {\n    /**\n     * Subscribe to the editor instance's changes.\n     */\n    subscribe(callback) {\n      subscribers.add(callback);\n      return () => {\n        subscribers.delete(callback);\n      };\n    },\n    getSnapshot() {\n      return renderers;\n    },\n    getServerSnapshot() {\n      return renderers;\n    },\n    /**\n     * Adds a new NodeView Renderer to the editor.\n     */\n    setRenderer(id, renderer) {\n      renderers = {\n        ...renderers,\n        [id]: react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(renderer.reactElement, renderer.element, id)\n      };\n      subscribers.forEach((subscriber) => subscriber());\n    },\n    /**\n     * Removes a NodeView Renderer from the editor.\n     */\n    removeRenderer(id) {\n      const nextRenderers = { ...renderers };\n      delete nextRenderers[id];\n      renderers = nextRenderers;\n      subscribers.forEach((subscriber) => subscriber());\n    }\n  };\n}\nvar PureEditorContent = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(props) {\n    var _a;\n    super(props);\n    this.editorContentRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n    this.initialized = false;\n    this.state = {\n      hasContentComponentInitialized: Boolean((_a = props.editor) == null ? void 0 : _a.contentComponent)\n    };\n  }\n  componentDidMount() {\n    this.init();\n  }\n  componentDidUpdate() {\n    this.init();\n  }\n  init() {\n    const editor = this.props.editor;\n    if (editor && !editor.isDestroyed && editor.options.element) {\n      if (editor.contentComponent) {\n        return;\n      }\n      const element = this.editorContentRef.current;\n      element.append(editor.view.dom);\n      editor.setOptions({\n        element\n      });\n      editor.contentComponent = getInstance();\n      if (!this.state.hasContentComponentInitialized) {\n        this.unsubscribeToContentComponent = editor.contentComponent.subscribe(() => {\n          this.setState((prevState) => {\n            if (!prevState.hasContentComponentInitialized) {\n              return {\n                hasContentComponentInitialized: true\n              };\n            }\n            return prevState;\n          });\n          if (this.unsubscribeToContentComponent) {\n            this.unsubscribeToContentComponent();\n          }\n        });\n      }\n      editor.createNodeViews();\n      this.initialized = true;\n    }\n  }\n  componentWillUnmount() {\n    var _a;\n    const editor = this.props.editor;\n    if (!editor) {\n      return;\n    }\n    this.initialized = false;\n    if (!editor.isDestroyed) {\n      editor.view.setProps({\n        nodeViews: {}\n      });\n    }\n    if (this.unsubscribeToContentComponent) {\n      this.unsubscribeToContentComponent();\n    }\n    editor.contentComponent = null;\n    try {\n      if (!((_a = editor.view.dom) == null ? void 0 : _a.firstChild)) {\n        return;\n      }\n      const newElement = document.createElement(\"div\");\n      newElement.append(editor.view.dom);\n      editor.setOptions({\n        element: newElement\n      });\n    } catch {\n    }\n  }\n  render() {\n    const { editor, innerRef, ...rest } = this.props;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, { children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", { ref: mergeRefs(innerRef, this.editorContentRef), ...rest }),\n      (editor == null ? void 0 : editor.contentComponent) && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(Portals, { contentComponent: editor.contentComponent })\n    ] });\n  }\n};\nvar EditorContentWithKey = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(\n  (props, ref) => {\n    const key = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n      return Math.floor(Math.random() * 4294967295).toString();\n    }, [props.editor]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(PureEditorContent, {\n      key,\n      innerRef: ref,\n      ...props\n    });\n  }\n);\nvar EditorContent = react__WEBPACK_IMPORTED_MODULE_0__.memo(EditorContentWithKey);\n\n// src/useEditor.ts\n\n\n\n\n// src/useEditorState.ts\n\n\n\nvar useIsomorphicLayoutEffect = typeof window !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar EditorStateManager = class {\n  constructor(initialEditor) {\n    this.transactionNumber = 0;\n    this.lastTransactionNumber = 0;\n    this.subscribers = /* @__PURE__ */ new Set();\n    this.editor = initialEditor;\n    this.lastSnapshot = { editor: initialEditor, transactionNumber: 0 };\n    this.getSnapshot = this.getSnapshot.bind(this);\n    this.getServerSnapshot = this.getServerSnapshot.bind(this);\n    this.watch = this.watch.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n  }\n  /**\n   * Get the current editor instance.\n   */\n  getSnapshot() {\n    if (this.transactionNumber === this.lastTransactionNumber) {\n      return this.lastSnapshot;\n    }\n    this.lastTransactionNumber = this.transactionNumber;\n    this.lastSnapshot = { editor: this.editor, transactionNumber: this.transactionNumber };\n    return this.lastSnapshot;\n  }\n  /**\n   * Always disable the editor on the server-side.\n   */\n  getServerSnapshot() {\n    return { editor: null, transactionNumber: 0 };\n  }\n  /**\n   * Subscribe to the editor instance's changes.\n   */\n  subscribe(callback) {\n    this.subscribers.add(callback);\n    return () => {\n      this.subscribers.delete(callback);\n    };\n  }\n  /**\n   * Watch the editor instance for changes.\n   */\n  watch(nextEditor) {\n    this.editor = nextEditor;\n    if (this.editor) {\n      const fn = () => {\n        this.transactionNumber += 1;\n        this.subscribers.forEach((callback) => callback());\n      };\n      const currentEditor = this.editor;\n      currentEditor.on(\"transaction\", fn);\n      return () => {\n        currentEditor.off(\"transaction\", fn);\n      };\n    }\n    return void 0;\n  }\n};\nfunction useEditorState(options) {\n  var _a;\n  const [editorStateManager] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => new EditorStateManager(options.editor));\n  const selectedState = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_5__.useSyncExternalStoreWithSelector)(\n    editorStateManager.subscribe,\n    editorStateManager.getSnapshot,\n    editorStateManager.getServerSnapshot,\n    options.selector,\n    (_a = options.equalityFn) != null ? _a : fast_deep_equal_es6_react_js__WEBPACK_IMPORTED_MODULE_4__\n  );\n  useIsomorphicLayoutEffect(() => {\n    return editorStateManager.watch(options.editor);\n  }, [options.editor, editorStateManager]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(selectedState);\n  return selectedState;\n}\n\n// src/useEditor.ts\nvar isDev = \"development\" !== \"production\";\nvar isSSR = typeof window === \"undefined\";\nvar isNext = isSSR || Boolean(typeof window !== \"undefined\" && window.next);\nvar EditorInstanceManager = class _EditorInstanceManager {\n  constructor(options) {\n    /**\n     * The current editor instance.\n     */\n    this.editor = null;\n    /**\n     * The subscriptions to notify when the editor instance\n     * has been created or destroyed.\n     */\n    this.subscriptions = /* @__PURE__ */ new Set();\n    /**\n     * Whether the editor has been mounted.\n     */\n    this.isComponentMounted = false;\n    /**\n     * The most recent dependencies array.\n     */\n    this.previousDeps = null;\n    /**\n     * The unique instance ID. This is used to identify the editor instance. And will be re-generated for each new instance.\n     */\n    this.instanceId = \"\";\n    this.options = options;\n    this.subscriptions = /* @__PURE__ */ new Set();\n    this.setEditor(this.getInitialEditor());\n    this.scheduleDestroy();\n    this.getEditor = this.getEditor.bind(this);\n    this.getServerSnapshot = this.getServerSnapshot.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n    this.refreshEditorInstance = this.refreshEditorInstance.bind(this);\n    this.scheduleDestroy = this.scheduleDestroy.bind(this);\n    this.onRender = this.onRender.bind(this);\n    this.createEditor = this.createEditor.bind(this);\n  }\n  setEditor(editor) {\n    this.editor = editor;\n    this.instanceId = Math.random().toString(36).slice(2, 9);\n    this.subscriptions.forEach((cb) => cb());\n  }\n  getInitialEditor() {\n    if (this.options.current.immediatelyRender === void 0) {\n      if (isSSR || isNext) {\n        if (isDev) {\n          throw new Error(\n            \"Tiptap Error: SSR has been detected, please set `immediatelyRender` explicitly to `false` to avoid hydration mismatches.\"\n          );\n        }\n        return null;\n      }\n      return this.createEditor();\n    }\n    if (this.options.current.immediatelyRender && isSSR && isDev) {\n      throw new Error(\n        \"Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches.\"\n      );\n    }\n    if (this.options.current.immediatelyRender) {\n      return this.createEditor();\n    }\n    return null;\n  }\n  /**\n   * Create a new editor instance. And attach event listeners.\n   */\n  createEditor() {\n    const optionsToApply = {\n      ...this.options.current,\n      // Always call the most recent version of the callback function by default\n      onBeforeCreate: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onBeforeCreate) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onBlur: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onBlur) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onCreate: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onCreate) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onDestroy: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onDestroy) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onFocus: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onFocus) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onSelectionUpdate: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onSelectionUpdate) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onTransaction: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onTransaction) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onUpdate: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onUpdate) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onContentError: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onContentError) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onDrop: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onDrop) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onPaste: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onPaste) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onDelete: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onDelete) == null ? void 0 : _b.call(_a, ...args);\n      }\n    };\n    const editor = new _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Editor(optionsToApply);\n    return editor;\n  }\n  /**\n   * Get the current editor instance.\n   */\n  getEditor() {\n    return this.editor;\n  }\n  /**\n   * Always disable the editor on the server-side.\n   */\n  getServerSnapshot() {\n    return null;\n  }\n  /**\n   * Subscribe to the editor instance's changes.\n   */\n  subscribe(onStoreChange) {\n    this.subscriptions.add(onStoreChange);\n    return () => {\n      this.subscriptions.delete(onStoreChange);\n    };\n  }\n  static compareOptions(a, b) {\n    return Object.keys(a).every((key) => {\n      if ([\n        \"onCreate\",\n        \"onBeforeCreate\",\n        \"onDestroy\",\n        \"onUpdate\",\n        \"onTransaction\",\n        \"onFocus\",\n        \"onBlur\",\n        \"onSelectionUpdate\",\n        \"onContentError\",\n        \"onDrop\",\n        \"onPaste\"\n      ].includes(key)) {\n        return true;\n      }\n      if (key === \"extensions\" && a.extensions && b.extensions) {\n        if (a.extensions.length !== b.extensions.length) {\n          return false;\n        }\n        return a.extensions.every((extension, index) => {\n          var _a;\n          if (extension !== ((_a = b.extensions) == null ? void 0 : _a[index])) {\n            return false;\n          }\n          return true;\n        });\n      }\n      if (a[key] !== b[key]) {\n        return false;\n      }\n      return true;\n    });\n  }\n  /**\n   * On each render, we will create, update, or destroy the editor instance.\n   * @param deps The dependencies to watch for changes\n   * @returns A cleanup function\n   */\n  onRender(deps) {\n    return () => {\n      this.isComponentMounted = true;\n      clearTimeout(this.scheduledDestructionTimeout);\n      if (this.editor && !this.editor.isDestroyed && deps.length === 0) {\n        if (!_EditorInstanceManager.compareOptions(this.options.current, this.editor.options)) {\n          this.editor.setOptions({\n            ...this.options.current,\n            editable: this.editor.isEditable\n          });\n        }\n      } else {\n        this.refreshEditorInstance(deps);\n      }\n      return () => {\n        this.isComponentMounted = false;\n        this.scheduleDestroy();\n      };\n    };\n  }\n  /**\n   * Recreate the editor instance if the dependencies have changed.\n   */\n  refreshEditorInstance(deps) {\n    if (this.editor && !this.editor.isDestroyed) {\n      if (this.previousDeps === null) {\n        this.previousDeps = deps;\n        return;\n      }\n      const depsAreEqual = this.previousDeps.length === deps.length && this.previousDeps.every((dep, index) => dep === deps[index]);\n      if (depsAreEqual) {\n        return;\n      }\n    }\n    if (this.editor && !this.editor.isDestroyed) {\n      this.editor.destroy();\n    }\n    this.setEditor(this.createEditor());\n    this.previousDeps = deps;\n  }\n  /**\n   * Schedule the destruction of the editor instance.\n   * This will only destroy the editor if it was not mounted on the next tick.\n   * This is to avoid destroying the editor instance when it's actually still mounted.\n   */\n  scheduleDestroy() {\n    const currentInstanceId = this.instanceId;\n    const currentEditor = this.editor;\n    this.scheduledDestructionTimeout = setTimeout(() => {\n      if (this.isComponentMounted && this.instanceId === currentInstanceId) {\n        if (currentEditor) {\n          currentEditor.setOptions(this.options.current);\n        }\n        return;\n      }\n      if (currentEditor && !currentEditor.isDestroyed) {\n        currentEditor.destroy();\n        if (this.instanceId === currentInstanceId) {\n          this.setEditor(null);\n        }\n      }\n    }, 1);\n  }\n};\nfunction useEditor(options = {}, deps = []) {\n  const mostRecentOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(options);\n  mostRecentOptions.current = options;\n  const [instanceManager] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => new EditorInstanceManager(mostRecentOptions));\n  const editor = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore)(\n    instanceManager.subscribe,\n    instanceManager.getEditor,\n    instanceManager.getServerSnapshot\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(editor);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(instanceManager.onRender(deps));\n  useEditorState({\n    editor,\n    selector: ({ transactionNumber }) => {\n      if (options.shouldRerenderOnTransaction === false || options.shouldRerenderOnTransaction === void 0) {\n        return null;\n      }\n      if (options.immediatelyRender && transactionNumber === 0) {\n        return 0;\n      }\n      return transactionNumber + 1;\n    }\n  });\n  return editor;\n}\n\n// src/Context.tsx\n\nvar EditorContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  editor: null\n});\nvar EditorConsumer = EditorContext.Consumer;\nvar useCurrentEditor = () => (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorContext);\nfunction EditorProvider({\n  children,\n  slotAfter,\n  slotBefore,\n  editorContainerProps = {},\n  ...editorOptions\n}) {\n  const editor = useEditor(editorOptions);\n  const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({ editor }), [editor]);\n  if (!editor) {\n    return null;\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(EditorContext.Provider, { value: contextValue, children: [\n    slotBefore,\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(EditorConsumer, { children: ({ editor: currentEditor }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(EditorContent, { editor: currentEditor, ...editorContainerProps }) }),\n    children,\n    slotAfter\n  ] });\n}\n\n// src/useReactNodeView.ts\n\nvar ReactNodeViewContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  onDragStart: () => {\n  },\n  nodeViewContentChildren: void 0,\n  nodeViewContentRef: () => {\n  }\n});\nvar ReactNodeViewContentProvider = ({ children, content }) => {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(ReactNodeViewContext.Provider, { value: { nodeViewContentChildren: content } }, children);\n};\nvar useReactNodeView = () => (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ReactNodeViewContext);\n\n// src/NodeViewContent.tsx\n\nfunction NodeViewContent({\n  as: Tag = \"div\",\n  ...props\n}) {\n  const { nodeViewContentRef, nodeViewContentChildren } = useReactNodeView();\n  return (\n    // @ts-ignore\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\n      Tag,\n      {\n        ...props,\n        ref: nodeViewContentRef,\n        \"data-node-view-content\": \"\",\n        style: {\n          whiteSpace: \"pre-wrap\",\n          ...props.style\n        },\n        children: nodeViewContentChildren\n      }\n    )\n  );\n}\n\n// src/NodeViewWrapper.tsx\n\n\nvar NodeViewWrapper = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {\n  const { onDragStart } = useReactNodeView();\n  const Tag = props.as || \"div\";\n  return (\n    // @ts-ignore\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\n      Tag,\n      {\n        ...props,\n        ref,\n        \"data-node-view-wrapper\": \"\",\n        onDragStart,\n        style: {\n          whiteSpace: \"normal\",\n          ...props.style\n        }\n      }\n    )\n  );\n});\n\n// src/ReactMarkViewRenderer.tsx\n\n\n\n// src/ReactRenderer.tsx\n\n\n\nfunction isClassComponent(Component) {\n  return !!(typeof Component === \"function\" && Component.prototype && Component.prototype.isReactComponent);\n}\nfunction isForwardRefComponent(Component) {\n  return !!(typeof Component === \"object\" && Component.$$typeof && (Component.$$typeof.toString() === \"Symbol(react.forward_ref)\" || Component.$$typeof.description === \"react.forward_ref\"));\n}\nfunction isMemoComponent(Component) {\n  return !!(typeof Component === \"object\" && Component.$$typeof && (Component.$$typeof.toString() === \"Symbol(react.memo)\" || Component.$$typeof.description === \"react.memo\"));\n}\nfunction canReceiveRef(Component) {\n  if (isClassComponent(Component)) {\n    return true;\n  }\n  if (isForwardRefComponent(Component)) {\n    return true;\n  }\n  if (isMemoComponent(Component)) {\n    const wrappedComponent = Component.type;\n    if (wrappedComponent) {\n      return isClassComponent(wrappedComponent) || isForwardRefComponent(wrappedComponent);\n    }\n  }\n  return false;\n}\nfunction isReact19Plus() {\n  try {\n    if (react__WEBPACK_IMPORTED_MODULE_0__.version) {\n      const majorVersion = parseInt(react__WEBPACK_IMPORTED_MODULE_0__.version.split(\".\")[0], 10);\n      return majorVersion >= 19;\n    }\n  } catch {\n  }\n  return false;\n}\nvar ReactRenderer = class {\n  /**\n   * Immediately creates element and renders the provided React component.\n   */\n  constructor(component, { editor, props = {}, as = \"div\", className = \"\" }) {\n    this.ref = null;\n    this.id = Math.floor(Math.random() * 4294967295).toString();\n    this.component = component;\n    this.editor = editor;\n    this.props = props;\n    this.element = document.createElement(as);\n    this.element.classList.add(\"react-renderer\");\n    if (className) {\n      this.element.classList.add(...className.split(\" \"));\n    }\n    if (this.editor.isInitialized) {\n      (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(() => {\n        this.render();\n      });\n    } else {\n      queueMicrotask(() => {\n        this.render();\n      });\n    }\n  }\n  /**\n   * Render the React component.\n   */\n  render() {\n    var _a;\n    const Component = this.component;\n    const props = this.props;\n    const editor = this.editor;\n    const isReact19 = isReact19Plus();\n    const componentCanReceiveRef = canReceiveRef(Component);\n    const elementProps = { ...props };\n    if (elementProps.ref && !(isReact19 || componentCanReceiveRef)) {\n      delete elementProps.ref;\n    }\n    if (!elementProps.ref && (isReact19 || componentCanReceiveRef)) {\n      elementProps.ref = (ref) => {\n        this.ref = ref;\n      };\n    }\n    this.reactElement = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(Component, { ...elementProps });\n    (_a = editor == null ? void 0 : editor.contentComponent) == null ? void 0 : _a.setRenderer(this.id, this);\n  }\n  /**\n   * Re-renders the React component with new props.\n   */\n  updateProps(props = {}) {\n    this.props = {\n      ...this.props,\n      ...props\n    };\n    this.render();\n  }\n  /**\n   * Destroy the React component.\n   */\n  destroy() {\n    var _a;\n    const editor = this.editor;\n    (_a = editor == null ? void 0 : editor.contentComponent) == null ? void 0 : _a.removeRenderer(this.id);\n    try {\n      if (this.element && this.element.parentNode) {\n        this.element.parentNode.removeChild(this.element);\n      }\n    } catch {\n    }\n  }\n  /**\n   * Update the attributes of the element that holds the React component.\n   */\n  updateAttributes(attributes) {\n    Object.keys(attributes).forEach((key) => {\n      this.element.setAttribute(key, attributes[key]);\n    });\n  }\n};\n\n// src/ReactMarkViewRenderer.tsx\n\nvar ReactMarkViewContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  markViewContentRef: () => {\n  }\n});\nvar MarkViewContent = (props) => {\n  const { as: Tag = \"span\", ...rest } = props;\n  const { markViewContentRef } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ReactMarkViewContext);\n  return (\n    // @ts-ignore\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(Tag, { ...rest, ref: markViewContentRef, \"data-mark-view-content\": \"\" })\n  );\n};\nvar ReactMarkView = class extends _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.MarkView {\n  constructor(component, props, options) {\n    super(component, props, options);\n    const { as = \"span\", attrs, className = \"\" } = options || {};\n    const componentProps = { ...props, updateAttributes: this.updateAttributes.bind(this) };\n    this.contentDOMElement = document.createElement(\"span\");\n    const markViewContentRef = (el) => {\n      if (el && !el.contains(this.contentDOMElement)) {\n        el.appendChild(this.contentDOMElement);\n      }\n    };\n    const context = {\n      markViewContentRef\n    };\n    const ReactMarkViewProvider = react__WEBPACK_IMPORTED_MODULE_0__.memo((componentProps2) => {\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(ReactMarkViewContext.Provider, { value: context, children: react__WEBPACK_IMPORTED_MODULE_0__.createElement(component, componentProps2) });\n    });\n    ReactMarkViewProvider.displayName = \"ReactMarkView\";\n    this.renderer = new ReactRenderer(ReactMarkViewProvider, {\n      editor: props.editor,\n      props: componentProps,\n      as,\n      className: `mark-${props.mark.type.name} ${className}`.trim()\n    });\n    if (attrs) {\n      this.renderer.updateAttributes(attrs);\n    }\n  }\n  get dom() {\n    return this.renderer.element;\n  }\n  get contentDOM() {\n    return this.contentDOMElement;\n  }\n};\nfunction ReactMarkViewRenderer(component, options = {}) {\n  return (props) => new ReactMarkView(component, props, options);\n}\n\n// src/ReactNodeViewRenderer.tsx\n\n\n\nvar ReactNodeView = class extends _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.NodeView {\n  constructor(component, props, options) {\n    super(component, props, options);\n    if (!this.node.isLeaf) {\n      if (this.options.contentDOMElementTag) {\n        this.contentDOMElement = document.createElement(this.options.contentDOMElementTag);\n      } else {\n        this.contentDOMElement = document.createElement(this.node.isInline ? \"span\" : \"div\");\n      }\n      this.contentDOMElement.dataset.nodeViewContentReact = \"\";\n      this.contentDOMElement.dataset.nodeViewWrapper = \"\";\n      this.contentDOMElement.style.whiteSpace = \"inherit\";\n      const contentTarget = this.dom.querySelector(\"[data-node-view-content]\");\n      if (!contentTarget) {\n        return;\n      }\n      contentTarget.appendChild(this.contentDOMElement);\n    }\n  }\n  /**\n   * Setup the React component.\n   * Called on initialization.\n   */\n  mount() {\n    const props = {\n      editor: this.editor,\n      node: this.node,\n      decorations: this.decorations,\n      innerDecorations: this.innerDecorations,\n      view: this.view,\n      selected: false,\n      extension: this.extension,\n      HTMLAttributes: this.HTMLAttributes,\n      getPos: () => this.getPos(),\n      updateAttributes: (attributes = {}) => this.updateAttributes(attributes),\n      deleteNode: () => this.deleteNode(),\n      ref: (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)()\n    };\n    if (!this.component.displayName) {\n      const capitalizeFirstChar = (string) => {\n        return string.charAt(0).toUpperCase() + string.substring(1);\n      };\n      this.component.displayName = capitalizeFirstChar(this.extension.name);\n    }\n    const onDragStart = this.onDragStart.bind(this);\n    const nodeViewContentRef = (element) => {\n      if (element && this.contentDOMElement && element.firstChild !== this.contentDOMElement) {\n        if (element.hasAttribute(\"data-node-view-wrapper\")) {\n          element.removeAttribute(\"data-node-view-wrapper\");\n        }\n        element.appendChild(this.contentDOMElement);\n      }\n    };\n    const context = { onDragStart, nodeViewContentRef };\n    const Component = this.component;\n    const ReactNodeViewProvider = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)((componentProps) => {\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(ReactNodeViewContext.Provider, { value: context, children: (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Component, componentProps) });\n    });\n    ReactNodeViewProvider.displayName = \"ReactNodeView\";\n    let as = this.node.isInline ? \"span\" : \"div\";\n    if (this.options.as) {\n      as = this.options.as;\n    }\n    const { className = \"\" } = this.options;\n    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this);\n    this.renderer = new ReactRenderer(ReactNodeViewProvider, {\n      editor: this.editor,\n      props,\n      as,\n      className: `node-${this.node.type.name} ${className}`.trim()\n    });\n    this.editor.on(\"selectionUpdate\", this.handleSelectionUpdate);\n    this.updateElementAttributes();\n  }\n  /**\n   * Return the DOM element.\n   * This is the element that will be used to display the node view.\n   */\n  get dom() {\n    var _a;\n    if (this.renderer.element.firstElementChild && !((_a = this.renderer.element.firstElementChild) == null ? void 0 : _a.hasAttribute(\"data-node-view-wrapper\"))) {\n      throw Error(\"Please use the NodeViewWrapper component for your node view.\");\n    }\n    return this.renderer.element;\n  }\n  /**\n   * Return the content DOM element.\n   * This is the element that will be used to display the rich-text content of the node.\n   */\n  get contentDOM() {\n    if (this.node.isLeaf) {\n      return null;\n    }\n    return this.contentDOMElement;\n  }\n  /**\n   * On editor selection update, check if the node is selected.\n   * If it is, call `selectNode`, otherwise call `deselectNode`.\n   */\n  handleSelectionUpdate() {\n    const { from, to } = this.editor.state.selection;\n    const pos = this.getPos();\n    if (typeof pos !== \"number\") {\n      return;\n    }\n    if (from <= pos && to >= pos + this.node.nodeSize) {\n      if (this.renderer.props.selected) {\n        return;\n      }\n      this.selectNode();\n    } else {\n      if (!this.renderer.props.selected) {\n        return;\n      }\n      this.deselectNode();\n    }\n  }\n  /**\n   * On update, update the React component.\n   * To prevent unnecessary updates, the `update` option can be used.\n   */\n  update(node, decorations, innerDecorations) {\n    const rerenderComponent = (props) => {\n      this.renderer.updateProps(props);\n      if (typeof this.options.attrs === \"function\") {\n        this.updateElementAttributes();\n      }\n    };\n    if (node.type !== this.node.type) {\n      return false;\n    }\n    if (typeof this.options.update === \"function\") {\n      const oldNode = this.node;\n      const oldDecorations = this.decorations;\n      const oldInnerDecorations = this.innerDecorations;\n      this.node = node;\n      this.decorations = decorations;\n      this.innerDecorations = innerDecorations;\n      return this.options.update({\n        oldNode,\n        oldDecorations,\n        newNode: node,\n        newDecorations: decorations,\n        oldInnerDecorations,\n        innerDecorations,\n        updateProps: () => rerenderComponent({ node, decorations, innerDecorations })\n      });\n    }\n    if (node === this.node && this.decorations === decorations && this.innerDecorations === innerDecorations) {\n      return true;\n    }\n    this.node = node;\n    this.decorations = decorations;\n    this.innerDecorations = innerDecorations;\n    rerenderComponent({ node, decorations, innerDecorations });\n    return true;\n  }\n  /**\n   * Select the node.\n   * Add the `selected` prop and the `ProseMirror-selectednode` class.\n   */\n  selectNode() {\n    this.renderer.updateProps({\n      selected: true\n    });\n    this.renderer.element.classList.add(\"ProseMirror-selectednode\");\n  }\n  /**\n   * Deselect the node.\n   * Remove the `selected` prop and the `ProseMirror-selectednode` class.\n   */\n  deselectNode() {\n    this.renderer.updateProps({\n      selected: false\n    });\n    this.renderer.element.classList.remove(\"ProseMirror-selectednode\");\n  }\n  /**\n   * Destroy the React component instance.\n   */\n  destroy() {\n    this.renderer.destroy();\n    this.editor.off(\"selectionUpdate\", this.handleSelectionUpdate);\n    this.contentDOMElement = null;\n  }\n  /**\n   * Update the attributes of the top-level element that holds the React component.\n   * Applying the attributes defined in the `attrs` option.\n   */\n  updateElementAttributes() {\n    if (this.options.attrs) {\n      let attrsObj = {};\n      if (typeof this.options.attrs === \"function\") {\n        const extensionAttributes = this.editor.extensionManager.attributes;\n        const HTMLAttributes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getRenderedAttributes)(this.node, extensionAttributes);\n        attrsObj = this.options.attrs({ node: this.node, HTMLAttributes });\n      } else {\n        attrsObj = this.options.attrs;\n      }\n      this.renderer.updateAttributes(attrsObj);\n    }\n  }\n};\nfunction ReactNodeViewRenderer(component, options) {\n  return (props) => {\n    if (!props.editor.contentComponent) {\n      return {};\n    }\n    return new ReactNodeView(component, props, options);\n  };\n}\n\n// src/index.ts\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUMyRDs7QUFFM0Q7QUFDMEM7QUFDVDtBQUM0QztBQUNyQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQyxvQkFBb0IsMkZBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNEQUFHLENBQUMsdURBQVEsSUFBSSxvQ0FBb0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbURBQXFCO0FBQ25DO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDRDQUFlO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0Q0FBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MscUNBQXFDO0FBQ3BGLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQ0FBcUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtRUFBcUI7QUFDcEQsd0NBQXdDLGlDQUFpQztBQUN6RSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM2QjtBQXNCM0I7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL21vcnRvbm1hYnVtYm8vRG93bmxvYWRzL3Rlc3RpbWlub255LXdlYjFfMTAtbWFpbi9ub2RlX21vZHVsZXMvQHRpcHRhcC9yZWFjdC9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9Db250ZXh0LnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlTWVtbyB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvRWRpdG9yQ29udGVudC50c3hcbmltcG9ydCBSZWFjdCwgeyBmb3J3YXJkUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmUgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRnJhZ21lbnQsIGpzeCwganN4cyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIG1lcmdlUmVmcyA9ICguLi5yZWZzKSA9PiB7XG4gIHJldHVybiAobm9kZSkgPT4ge1xuICAgIHJlZnMuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJlZihub2RlKTtcbiAgICAgIH0gZWxzZSBpZiAocmVmKSB7XG4gICAgICAgIDtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufTtcbnZhciBQb3J0YWxzID0gKHsgY29udGVudENvbXBvbmVudCB9KSA9PiB7XG4gIGNvbnN0IHJlbmRlcmVycyA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgIGNvbnRlbnRDb21wb25lbnQuc3Vic2NyaWJlLFxuICAgIGNvbnRlbnRDb21wb25lbnQuZ2V0U25hcHNob3QsXG4gICAgY29udGVudENvbXBvbmVudC5nZXRTZXJ2ZXJTbmFwc2hvdFxuICApO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChGcmFnbWVudCwgeyBjaGlsZHJlbjogT2JqZWN0LnZhbHVlcyhyZW5kZXJlcnMpIH0pO1xufTtcbmZ1bmN0aW9uIGdldEluc3RhbmNlKCkge1xuICBjb25zdCBzdWJzY3JpYmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCByZW5kZXJlcnMgPSB7fTtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gdGhlIGVkaXRvciBpbnN0YW5jZSdzIGNoYW5nZXMuXG4gICAgICovXG4gICAgc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgICBzdWJzY3JpYmVycy5hZGQoY2FsbGJhY2spO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgc3Vic2NyaWJlcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRTbmFwc2hvdCgpIHtcbiAgICAgIHJldHVybiByZW5kZXJlcnM7XG4gICAgfSxcbiAgICBnZXRTZXJ2ZXJTbmFwc2hvdCgpIHtcbiAgICAgIHJldHVybiByZW5kZXJlcnM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IE5vZGVWaWV3IFJlbmRlcmVyIHRvIHRoZSBlZGl0b3IuXG4gICAgICovXG4gICAgc2V0UmVuZGVyZXIoaWQsIHJlbmRlcmVyKSB7XG4gICAgICByZW5kZXJlcnMgPSB7XG4gICAgICAgIC4uLnJlbmRlcmVycyxcbiAgICAgICAgW2lkXTogUmVhY3RET00uY3JlYXRlUG9ydGFsKHJlbmRlcmVyLnJlYWN0RWxlbWVudCwgcmVuZGVyZXIuZWxlbWVudCwgaWQpXG4gICAgICB9O1xuICAgICAgc3Vic2NyaWJlcnMuZm9yRWFjaCgoc3Vic2NyaWJlcikgPT4gc3Vic2NyaWJlcigpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBOb2RlVmlldyBSZW5kZXJlciBmcm9tIHRoZSBlZGl0b3IuXG4gICAgICovXG4gICAgcmVtb3ZlUmVuZGVyZXIoaWQpIHtcbiAgICAgIGNvbnN0IG5leHRSZW5kZXJlcnMgPSB7IC4uLnJlbmRlcmVycyB9O1xuICAgICAgZGVsZXRlIG5leHRSZW5kZXJlcnNbaWRdO1xuICAgICAgcmVuZGVyZXJzID0gbmV4dFJlbmRlcmVycztcbiAgICAgIHN1YnNjcmliZXJzLmZvckVhY2goKHN1YnNjcmliZXIpID0+IHN1YnNjcmliZXIoKSk7XG4gICAgfVxuICB9O1xufVxudmFyIFB1cmVFZGl0b3JDb250ZW50ID0gY2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHZhciBfYTtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5lZGl0b3JDb250ZW50UmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBoYXNDb250ZW50Q29tcG9uZW50SW5pdGlhbGl6ZWQ6IEJvb2xlYW4oKF9hID0gcHJvcHMuZWRpdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY29udGVudENvbXBvbmVudClcbiAgICB9O1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuICBpbml0KCkge1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yO1xuICAgIGlmIChlZGl0b3IgJiYgIWVkaXRvci5pc0Rlc3Ryb3llZCAmJiBlZGl0b3Iub3B0aW9ucy5lbGVtZW50KSB7XG4gICAgICBpZiAoZWRpdG9yLmNvbnRlbnRDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWRpdG9yQ29udGVudFJlZi5jdXJyZW50O1xuICAgICAgZWxlbWVudC5hcHBlbmQoZWRpdG9yLnZpZXcuZG9tKTtcbiAgICAgIGVkaXRvci5zZXRPcHRpb25zKHtcbiAgICAgICAgZWxlbWVudFxuICAgICAgfSk7XG4gICAgICBlZGl0b3IuY29udGVudENvbXBvbmVudCA9IGdldEluc3RhbmNlKCk7XG4gICAgICBpZiAoIXRoaXMuc3RhdGUuaGFzQ29udGVudENvbXBvbmVudEluaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVUb0NvbnRlbnRDb21wb25lbnQgPSBlZGl0b3IuY29udGVudENvbXBvbmVudC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoKHByZXZTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFwcmV2U3RhdGUuaGFzQ29udGVudENvbXBvbmVudEluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaGFzQ29udGVudENvbXBvbmVudEluaXRpYWxpemVkOiB0cnVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0aGlzLnVuc3Vic2NyaWJlVG9Db250ZW50Q29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlVG9Db250ZW50Q29tcG9uZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVkaXRvci5jcmVhdGVOb2RlVmlld3MoKTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3I7XG4gICAgaWYgKCFlZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIGlmICghZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICBlZGl0b3Iudmlldy5zZXRQcm9wcyh7XG4gICAgICAgIG5vZGVWaWV3czoge31cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy51bnN1YnNjcmliZVRvQ29udGVudENvbXBvbmVudCkge1xuICAgICAgdGhpcy51bnN1YnNjcmliZVRvQ29udGVudENvbXBvbmVudCgpO1xuICAgIH1cbiAgICBlZGl0b3IuY29udGVudENvbXBvbmVudCA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghKChfYSA9IGVkaXRvci52aWV3LmRvbSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZpcnN0Q2hpbGQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgbmV3RWxlbWVudC5hcHBlbmQoZWRpdG9yLnZpZXcuZG9tKTtcbiAgICAgIGVkaXRvci5zZXRPcHRpb25zKHtcbiAgICAgICAgZWxlbWVudDogbmV3RWxlbWVudFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGVkaXRvciwgaW5uZXJSZWYsIC4uLnJlc3QgfSA9IHRoaXMucHJvcHM7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgcmVmOiBtZXJnZVJlZnMoaW5uZXJSZWYsIHRoaXMuZWRpdG9yQ29udGVudFJlZiksIC4uLnJlc3QgfSksXG4gICAgICAoZWRpdG9yID09IG51bGwgPyB2b2lkIDAgOiBlZGl0b3IuY29udGVudENvbXBvbmVudCkgJiYgLyogQF9fUFVSRV9fICovIGpzeChQb3J0YWxzLCB7IGNvbnRlbnRDb21wb25lbnQ6IGVkaXRvci5jb250ZW50Q29tcG9uZW50IH0pXG4gICAgXSB9KTtcbiAgfVxufTtcbnZhciBFZGl0b3JDb250ZW50V2l0aEtleSA9IGZvcndhcmRSZWYoXG4gIChwcm9wcywgcmVmKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNDI5NDk2NzI5NSkudG9TdHJpbmcoKTtcbiAgICB9LCBbcHJvcHMuZWRpdG9yXSk7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHVyZUVkaXRvckNvbnRlbnQsIHtcbiAgICAgIGtleSxcbiAgICAgIGlubmVyUmVmOiByZWYsXG4gICAgICAuLi5wcm9wc1xuICAgIH0pO1xuICB9XG4pO1xudmFyIEVkaXRvckNvbnRlbnQgPSBSZWFjdC5tZW1vKEVkaXRvckNvbnRlbnRXaXRoS2V5KTtcblxuLy8gc3JjL3VzZUVkaXRvci50c1xuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgdXNlRGVidWdWYWx1ZSBhcyB1c2VEZWJ1Z1ZhbHVlMiwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIsIHVzZVJlZiwgdXNlU3RhdGUgYXMgdXNlU3RhdGUyIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSBhcyB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS9pbmRleC5qc1wiO1xuXG4vLyBzcmMvdXNlRWRpdG9yU3RhdGUudHNcbmltcG9ydCBkZWVwRXF1YWwgZnJvbSBcImZhc3QtZGVlcC1lcXVhbC9lczYvcmVhY3QuanNcIjtcbmltcG9ydCB7IHVzZURlYnVnVmFsdWUsIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS93aXRoLXNlbGVjdG9yLmpzXCI7XG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG52YXIgRWRpdG9yU3RhdGVNYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsRWRpdG9yKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbk51bWJlciA9IDA7XG4gICAgdGhpcy5sYXN0VHJhbnNhY3Rpb25OdW1iZXIgPSAwO1xuICAgIHRoaXMuc3Vic2NyaWJlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuZWRpdG9yID0gaW5pdGlhbEVkaXRvcjtcbiAgICB0aGlzLmxhc3RTbmFwc2hvdCA9IHsgZWRpdG9yOiBpbml0aWFsRWRpdG9yLCB0cmFuc2FjdGlvbk51bWJlcjogMCB9O1xuICAgIHRoaXMuZ2V0U25hcHNob3QgPSB0aGlzLmdldFNuYXBzaG90LmJpbmQodGhpcyk7XG4gICAgdGhpcy5nZXRTZXJ2ZXJTbmFwc2hvdCA9IHRoaXMuZ2V0U2VydmVyU25hcHNob3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLndhdGNoID0gdGhpcy53YXRjaC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc3Vic2NyaWJlID0gdGhpcy5zdWJzY3JpYmUuYmluZCh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZS5cbiAgICovXG4gIGdldFNuYXBzaG90KCkge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uTnVtYmVyID09PSB0aGlzLmxhc3RUcmFuc2FjdGlvbk51bWJlcikge1xuICAgICAgcmV0dXJuIHRoaXMubGFzdFNuYXBzaG90O1xuICAgIH1cbiAgICB0aGlzLmxhc3RUcmFuc2FjdGlvbk51bWJlciA9IHRoaXMudHJhbnNhY3Rpb25OdW1iZXI7XG4gICAgdGhpcy5sYXN0U25hcHNob3QgPSB7IGVkaXRvcjogdGhpcy5lZGl0b3IsIHRyYW5zYWN0aW9uTnVtYmVyOiB0aGlzLnRyYW5zYWN0aW9uTnVtYmVyIH07XG4gICAgcmV0dXJuIHRoaXMubGFzdFNuYXBzaG90O1xuICB9XG4gIC8qKlxuICAgKiBBbHdheXMgZGlzYWJsZSB0aGUgZWRpdG9yIG9uIHRoZSBzZXJ2ZXItc2lkZS5cbiAgICovXG4gIGdldFNlcnZlclNuYXBzaG90KCkge1xuICAgIHJldHVybiB7IGVkaXRvcjogbnVsbCwgdHJhbnNhY3Rpb25OdW1iZXI6IDAgfTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIHRoZSBlZGl0b3IgaW5zdGFuY2UncyBjaGFuZ2VzLlxuICAgKi9cbiAgc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5hZGQoY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzLnN1YnNjcmliZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogV2F0Y2ggdGhlIGVkaXRvciBpbnN0YW5jZSBmb3IgY2hhbmdlcy5cbiAgICovXG4gIHdhdGNoKG5leHRFZGl0b3IpIHtcbiAgICB0aGlzLmVkaXRvciA9IG5leHRFZGl0b3I7XG4gICAgaWYgKHRoaXMuZWRpdG9yKSB7XG4gICAgICBjb25zdCBmbiA9ICgpID0+IHtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbk51bWJlciArPSAxO1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJzLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjaygpKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBjdXJyZW50RWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICBjdXJyZW50RWRpdG9yLm9uKFwidHJhbnNhY3Rpb25cIiwgZm4pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY3VycmVudEVkaXRvci5vZmYoXCJ0cmFuc2FjdGlvblwiLCBmbik7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59O1xuZnVuY3Rpb24gdXNlRWRpdG9yU3RhdGUob3B0aW9ucykge1xuICB2YXIgX2E7XG4gIGNvbnN0IFtlZGl0b3JTdGF0ZU1hbmFnZXJdID0gdXNlU3RhdGUoKCkgPT4gbmV3IEVkaXRvclN0YXRlTWFuYWdlcihvcHRpb25zLmVkaXRvcikpO1xuICBjb25zdCBzZWxlY3RlZFN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgZWRpdG9yU3RhdGVNYW5hZ2VyLnN1YnNjcmliZSxcbiAgICBlZGl0b3JTdGF0ZU1hbmFnZXIuZ2V0U25hcHNob3QsXG4gICAgZWRpdG9yU3RhdGVNYW5hZ2VyLmdldFNlcnZlclNuYXBzaG90LFxuICAgIG9wdGlvbnMuc2VsZWN0b3IsXG4gICAgKF9hID0gb3B0aW9ucy5lcXVhbGl0eUZuKSAhPSBudWxsID8gX2EgOiBkZWVwRXF1YWxcbiAgKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIGVkaXRvclN0YXRlTWFuYWdlci53YXRjaChvcHRpb25zLmVkaXRvcik7XG4gIH0sIFtvcHRpb25zLmVkaXRvciwgZWRpdG9yU3RhdGVNYW5hZ2VyXSk7XG4gIHVzZURlYnVnVmFsdWUoc2VsZWN0ZWRTdGF0ZSk7XG4gIHJldHVybiBzZWxlY3RlZFN0YXRlO1xufVxuXG4vLyBzcmMvdXNlRWRpdG9yLnRzXG52YXIgaXNEZXYgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCI7XG52YXIgaXNTU1IgPSB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiO1xudmFyIGlzTmV4dCA9IGlzU1NSIHx8IEJvb2xlYW4odHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubmV4dCk7XG52YXIgRWRpdG9ySW5zdGFuY2VNYW5hZ2VyID0gY2xhc3MgX0VkaXRvckluc3RhbmNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2UuXG4gICAgICovXG4gICAgdGhpcy5lZGl0b3IgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIFRoZSBzdWJzY3JpcHRpb25zIHRvIG5vdGlmeSB3aGVuIHRoZSBlZGl0b3IgaW5zdGFuY2VcbiAgICAgKiBoYXMgYmVlbiBjcmVhdGVkIG9yIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGVkaXRvciBoYXMgYmVlbiBtb3VudGVkLlxuICAgICAqL1xuICAgIHRoaXMuaXNDb21wb25lbnRNb3VudGVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGhlIG1vc3QgcmVjZW50IGRlcGVuZGVuY2llcyBhcnJheS5cbiAgICAgKi9cbiAgICB0aGlzLnByZXZpb3VzRGVwcyA9IG51bGw7XG4gICAgLyoqXG4gICAgICogVGhlIHVuaXF1ZSBpbnN0YW5jZSBJRC4gVGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBlZGl0b3IgaW5zdGFuY2UuIEFuZCB3aWxsIGJlIHJlLWdlbmVyYXRlZCBmb3IgZWFjaCBuZXcgaW5zdGFuY2UuXG4gICAgICovXG4gICAgdGhpcy5pbnN0YW5jZUlkID0gXCJcIjtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5zZXRFZGl0b3IodGhpcy5nZXRJbml0aWFsRWRpdG9yKCkpO1xuICAgIHRoaXMuc2NoZWR1bGVEZXN0cm95KCk7XG4gICAgdGhpcy5nZXRFZGl0b3IgPSB0aGlzLmdldEVkaXRvci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZ2V0U2VydmVyU25hcHNob3QgPSB0aGlzLmdldFNlcnZlclNuYXBzaG90LmJpbmQodGhpcyk7XG4gICAgdGhpcy5zdWJzY3JpYmUgPSB0aGlzLnN1YnNjcmliZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVmcmVzaEVkaXRvckluc3RhbmNlID0gdGhpcy5yZWZyZXNoRWRpdG9ySW5zdGFuY2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNjaGVkdWxlRGVzdHJveSA9IHRoaXMuc2NoZWR1bGVEZXN0cm95LmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblJlbmRlciA9IHRoaXMub25SZW5kZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLmNyZWF0ZUVkaXRvciA9IHRoaXMuY3JlYXRlRWRpdG9yLmJpbmQodGhpcyk7XG4gIH1cbiAgc2V0RWRpdG9yKGVkaXRvcikge1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgIHRoaXMuaW5zdGFuY2VJZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsIDkpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gIH1cbiAgZ2V0SW5pdGlhbEVkaXRvcigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmN1cnJlbnQuaW1tZWRpYXRlbHlSZW5kZXIgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKGlzU1NSIHx8IGlzTmV4dCkge1xuICAgICAgICBpZiAoaXNEZXYpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIlRpcHRhcCBFcnJvcjogU1NSIGhhcyBiZWVuIGRldGVjdGVkLCBwbGVhc2Ugc2V0IGBpbW1lZGlhdGVseVJlbmRlcmAgZXhwbGljaXRseSB0byBgZmFsc2VgIHRvIGF2b2lkIGh5ZHJhdGlvbiBtaXNtYXRjaGVzLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVkaXRvcigpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmN1cnJlbnQuaW1tZWRpYXRlbHlSZW5kZXIgJiYgaXNTU1IgJiYgaXNEZXYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJUaXB0YXAgRXJyb3I6IFNTUiBoYXMgYmVlbiBkZXRlY3RlZCwgYW5kIGBpbW1lZGlhdGVseVJlbmRlcmAgaGFzIGJlZW4gc2V0IHRvIGB0cnVlYCB0aGlzIGlzIGFuIHVuc3VwcG9ydGVkIGNvbmZpZ3VyYXRpb24gdGhhdCBtYXkgcmVzdWx0IGluIGVycm9ycywgZXhwbGljaXRseSBzZXQgYGltbWVkaWF0ZWx5UmVuZGVyYCB0byBgZmFsc2VgIHRvIGF2b2lkIGh5ZHJhdGlvbiBtaXNtYXRjaGVzLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmN1cnJlbnQuaW1tZWRpYXRlbHlSZW5kZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVkaXRvcigpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGVkaXRvciBpbnN0YW5jZS4gQW5kIGF0dGFjaCBldmVudCBsaXN0ZW5lcnMuXG4gICAqL1xuICBjcmVhdGVFZGl0b3IoKSB7XG4gICAgY29uc3Qgb3B0aW9uc1RvQXBwbHkgPSB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMuY3VycmVudCxcbiAgICAgIC8vIEFsd2F5cyBjYWxsIHRoZSBtb3N0IHJlY2VudCB2ZXJzaW9uIG9mIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBieSBkZWZhdWx0XG4gICAgICBvbkJlZm9yZUNyZWF0ZTogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vbkJlZm9yZUNyZWF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIG9uQmx1cjogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vbkJsdXIpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBvbkNyZWF0ZTogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vbkNyZWF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIG9uRGVzdHJveTogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vbkRlc3Ryb3kpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBvbkZvY3VzOiAoLi4uYXJncykgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmN1cnJlbnQpLm9uRm9jdXMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBvblNlbGVjdGlvblVwZGF0ZTogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vblNlbGVjdGlvblVwZGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIG9uVHJhbnNhY3Rpb246ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25UcmFuc2FjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIG9uVXBkYXRlOiAoLi4uYXJncykgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmN1cnJlbnQpLm9uVXBkYXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgb25Db250ZW50RXJyb3I6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25Db250ZW50RXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBvbkRyb3A6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25Ecm9wKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgb25QYXN0ZTogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vblBhc3RlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgb25EZWxldGU6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25EZWxldGUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGVkaXRvciA9IG5ldyBFZGl0b3Iob3B0aW9uc1RvQXBwbHkpO1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2UuXG4gICAqL1xuICBnZXRFZGl0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yO1xuICB9XG4gIC8qKlxuICAgKiBBbHdheXMgZGlzYWJsZSB0aGUgZWRpdG9yIG9uIHRoZSBzZXJ2ZXItc2lkZS5cbiAgICovXG4gIGdldFNlcnZlclNuYXBzaG90KCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gdGhlIGVkaXRvciBpbnN0YW5jZSdzIGNoYW5nZXMuXG4gICAqL1xuICBzdWJzY3JpYmUob25TdG9yZUNoYW5nZSkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQob25TdG9yZUNoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5kZWxldGUob25TdG9yZUNoYW5nZSk7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgY29tcGFyZU9wdGlvbnMoYSwgYikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhhKS5ldmVyeSgoa2V5KSA9PiB7XG4gICAgICBpZiAoW1xuICAgICAgICBcIm9uQ3JlYXRlXCIsXG4gICAgICAgIFwib25CZWZvcmVDcmVhdGVcIixcbiAgICAgICAgXCJvbkRlc3Ryb3lcIixcbiAgICAgICAgXCJvblVwZGF0ZVwiLFxuICAgICAgICBcIm9uVHJhbnNhY3Rpb25cIixcbiAgICAgICAgXCJvbkZvY3VzXCIsXG4gICAgICAgIFwib25CbHVyXCIsXG4gICAgICAgIFwib25TZWxlY3Rpb25VcGRhdGVcIixcbiAgICAgICAgXCJvbkNvbnRlbnRFcnJvclwiLFxuICAgICAgICBcIm9uRHJvcFwiLFxuICAgICAgICBcIm9uUGFzdGVcIlxuICAgICAgXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gXCJleHRlbnNpb25zXCIgJiYgYS5leHRlbnNpb25zICYmIGIuZXh0ZW5zaW9ucykge1xuICAgICAgICBpZiAoYS5leHRlbnNpb25zLmxlbmd0aCAhPT0gYi5leHRlbnNpb25zLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS5leHRlbnNpb25zLmV2ZXJ5KChleHRlbnNpb24sIGluZGV4KSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIGlmIChleHRlbnNpb24gIT09ICgoX2EgPSBiLmV4dGVuc2lvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYVtpbmRleF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChhW2tleV0gIT09IGJba2V5XSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogT24gZWFjaCByZW5kZXIsIHdlIHdpbGwgY3JlYXRlLCB1cGRhdGUsIG9yIGRlc3Ryb3kgdGhlIGVkaXRvciBpbnN0YW5jZS5cbiAgICogQHBhcmFtIGRlcHMgVGhlIGRlcGVuZGVuY2llcyB0byB3YXRjaCBmb3IgY2hhbmdlc1xuICAgKiBAcmV0dXJucyBBIGNsZWFudXAgZnVuY3Rpb25cbiAgICovXG4gIG9uUmVuZGVyKGRlcHMpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhpcy5pc0NvbXBvbmVudE1vdW50ZWQgPSB0cnVlO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2NoZWR1bGVkRGVzdHJ1Y3Rpb25UaW1lb3V0KTtcbiAgICAgIGlmICh0aGlzLmVkaXRvciAmJiAhdGhpcy5lZGl0b3IuaXNEZXN0cm95ZWQgJiYgZGVwcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKCFfRWRpdG9ySW5zdGFuY2VNYW5hZ2VyLmNvbXBhcmVPcHRpb25zKHRoaXMub3B0aW9ucy5jdXJyZW50LCB0aGlzLmVkaXRvci5vcHRpb25zKSkge1xuICAgICAgICAgIHRoaXMuZWRpdG9yLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLmN1cnJlbnQsXG4gICAgICAgICAgICBlZGl0YWJsZTogdGhpcy5lZGl0b3IuaXNFZGl0YWJsZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlZnJlc2hFZGl0b3JJbnN0YW5jZShkZXBzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHRoaXMuaXNDb21wb25lbnRNb3VudGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVEZXN0cm95KCk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJlY3JlYXRlIHRoZSBlZGl0b3IgaW5zdGFuY2UgaWYgdGhlIGRlcGVuZGVuY2llcyBoYXZlIGNoYW5nZWQuXG4gICAqL1xuICByZWZyZXNoRWRpdG9ySW5zdGFuY2UoZGVwcykge1xuICAgIGlmICh0aGlzLmVkaXRvciAmJiAhdGhpcy5lZGl0b3IuaXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICh0aGlzLnByZXZpb3VzRGVwcyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLnByZXZpb3VzRGVwcyA9IGRlcHM7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlcHNBcmVFcXVhbCA9IHRoaXMucHJldmlvdXNEZXBzLmxlbmd0aCA9PT0gZGVwcy5sZW5ndGggJiYgdGhpcy5wcmV2aW91c0RlcHMuZXZlcnkoKGRlcCwgaW5kZXgpID0+IGRlcCA9PT0gZGVwc1tpbmRleF0pO1xuICAgICAgaWYgKGRlcHNBcmVFcXVhbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmVkaXRvciAmJiAhdGhpcy5lZGl0b3IuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHRoaXMuZWRpdG9yLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5zZXRFZGl0b3IodGhpcy5jcmVhdGVFZGl0b3IoKSk7XG4gICAgdGhpcy5wcmV2aW91c0RlcHMgPSBkZXBzO1xuICB9XG4gIC8qKlxuICAgKiBTY2hlZHVsZSB0aGUgZGVzdHJ1Y3Rpb24gb2YgdGhlIGVkaXRvciBpbnN0YW5jZS5cbiAgICogVGhpcyB3aWxsIG9ubHkgZGVzdHJveSB0aGUgZWRpdG9yIGlmIGl0IHdhcyBub3QgbW91bnRlZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgKiBUaGlzIGlzIHRvIGF2b2lkIGRlc3Ryb3lpbmcgdGhlIGVkaXRvciBpbnN0YW5jZSB3aGVuIGl0J3MgYWN0dWFsbHkgc3RpbGwgbW91bnRlZC5cbiAgICovXG4gIHNjaGVkdWxlRGVzdHJveSgpIHtcbiAgICBjb25zdCBjdXJyZW50SW5zdGFuY2VJZCA9IHRoaXMuaW5zdGFuY2VJZDtcbiAgICBjb25zdCBjdXJyZW50RWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgdGhpcy5zY2hlZHVsZWREZXN0cnVjdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzQ29tcG9uZW50TW91bnRlZCAmJiB0aGlzLmluc3RhbmNlSWQgPT09IGN1cnJlbnRJbnN0YW5jZUlkKSB7XG4gICAgICAgIGlmIChjdXJyZW50RWRpdG9yKSB7XG4gICAgICAgICAgY3VycmVudEVkaXRvci5zZXRPcHRpb25zKHRoaXMub3B0aW9ucy5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudEVkaXRvciAmJiAhY3VycmVudEVkaXRvci5pc0Rlc3Ryb3llZCkge1xuICAgICAgICBjdXJyZW50RWRpdG9yLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2VJZCA9PT0gY3VycmVudEluc3RhbmNlSWQpIHtcbiAgICAgICAgICB0aGlzLnNldEVkaXRvcihudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIDEpO1xuICB9XG59O1xuZnVuY3Rpb24gdXNlRWRpdG9yKG9wdGlvbnMgPSB7fSwgZGVwcyA9IFtdKSB7XG4gIGNvbnN0IG1vc3RSZWNlbnRPcHRpb25zID0gdXNlUmVmKG9wdGlvbnMpO1xuICBtb3N0UmVjZW50T3B0aW9ucy5jdXJyZW50ID0gb3B0aW9ucztcbiAgY29uc3QgW2luc3RhbmNlTWFuYWdlcl0gPSB1c2VTdGF0ZTIoKCkgPT4gbmV3IEVkaXRvckluc3RhbmNlTWFuYWdlcihtb3N0UmVjZW50T3B0aW9ucykpO1xuICBjb25zdCBlZGl0b3IgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIoXG4gICAgaW5zdGFuY2VNYW5hZ2VyLnN1YnNjcmliZSxcbiAgICBpbnN0YW5jZU1hbmFnZXIuZ2V0RWRpdG9yLFxuICAgIGluc3RhbmNlTWFuYWdlci5nZXRTZXJ2ZXJTbmFwc2hvdFxuICApO1xuICB1c2VEZWJ1Z1ZhbHVlMihlZGl0b3IpO1xuICB1c2VFZmZlY3QyKGluc3RhbmNlTWFuYWdlci5vblJlbmRlcihkZXBzKSk7XG4gIHVzZUVkaXRvclN0YXRlKHtcbiAgICBlZGl0b3IsXG4gICAgc2VsZWN0b3I6ICh7IHRyYW5zYWN0aW9uTnVtYmVyIH0pID0+IHtcbiAgICAgIGlmIChvcHRpb25zLnNob3VsZFJlcmVuZGVyT25UcmFuc2FjdGlvbiA9PT0gZmFsc2UgfHwgb3B0aW9ucy5zaG91bGRSZXJlbmRlck9uVHJhbnNhY3Rpb24gPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZWx5UmVuZGVyICYmIHRyYW5zYWN0aW9uTnVtYmVyID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uTnVtYmVyICsgMTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZWRpdG9yO1xufVxuXG4vLyBzcmMvQ29udGV4dC50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gyLCBqc3hzIGFzIGpzeHMyIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgRWRpdG9yQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xuICBlZGl0b3I6IG51bGxcbn0pO1xudmFyIEVkaXRvckNvbnN1bWVyID0gRWRpdG9yQ29udGV4dC5Db25zdW1lcjtcbnZhciB1c2VDdXJyZW50RWRpdG9yID0gKCkgPT4gdXNlQ29udGV4dChFZGl0b3JDb250ZXh0KTtcbmZ1bmN0aW9uIEVkaXRvclByb3ZpZGVyKHtcbiAgY2hpbGRyZW4sXG4gIHNsb3RBZnRlcixcbiAgc2xvdEJlZm9yZSxcbiAgZWRpdG9yQ29udGFpbmVyUHJvcHMgPSB7fSxcbiAgLi4uZWRpdG9yT3B0aW9uc1xufSkge1xuICBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoZWRpdG9yT3B0aW9ucyk7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8oKCkgPT4gKHsgZWRpdG9yIH0pLCBbZWRpdG9yXSk7XG4gIGlmICghZWRpdG9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzMihFZGl0b3JDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0VmFsdWUsIGNoaWxkcmVuOiBbXG4gICAgc2xvdEJlZm9yZSxcbiAgICAvKiBAX19QVVJFX18gKi8ganN4MihFZGl0b3JDb25zdW1lciwgeyBjaGlsZHJlbjogKHsgZWRpdG9yOiBjdXJyZW50RWRpdG9yIH0pID0+IC8qIEBfX1BVUkVfXyAqLyBqc3gyKEVkaXRvckNvbnRlbnQsIHsgZWRpdG9yOiBjdXJyZW50RWRpdG9yLCAuLi5lZGl0b3JDb250YWluZXJQcm9wcyB9KSB9KSxcbiAgICBjaGlsZHJlbixcbiAgICBzbG90QWZ0ZXJcbiAgXSB9KTtcbn1cblxuLy8gc3JjL3VzZVJlYWN0Tm9kZVZpZXcudHNcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDIsIGNyZWF0ZUVsZW1lbnQsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDIgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBSZWFjdE5vZGVWaWV3Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQyKHtcbiAgb25EcmFnU3RhcnQ6ICgpID0+IHtcbiAgfSxcbiAgbm9kZVZpZXdDb250ZW50Q2hpbGRyZW46IHZvaWQgMCxcbiAgbm9kZVZpZXdDb250ZW50UmVmOiAoKSA9PiB7XG4gIH1cbn0pO1xudmFyIFJlYWN0Tm9kZVZpZXdDb250ZW50UHJvdmlkZXIgPSAoeyBjaGlsZHJlbiwgY29udGVudCB9KSA9PiB7XG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFJlYWN0Tm9kZVZpZXdDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB7IG5vZGVWaWV3Q29udGVudENoaWxkcmVuOiBjb250ZW50IH0gfSwgY2hpbGRyZW4pO1xufTtcbnZhciB1c2VSZWFjdE5vZGVWaWV3ID0gKCkgPT4gdXNlQ29udGV4dDIoUmVhY3ROb2RlVmlld0NvbnRleHQpO1xuXG4vLyBzcmMvTm9kZVZpZXdDb250ZW50LnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmZ1bmN0aW9uIE5vZGVWaWV3Q29udGVudCh7XG4gIGFzOiBUYWcgPSBcImRpdlwiLFxuICAuLi5wcm9wc1xufSkge1xuICBjb25zdCB7IG5vZGVWaWV3Q29udGVudFJlZiwgbm9kZVZpZXdDb250ZW50Q2hpbGRyZW4gfSA9IHVzZVJlYWN0Tm9kZVZpZXcoKTtcbiAgcmV0dXJuIChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgLyogQF9fUFVSRV9fICovIGpzeDMoXG4gICAgICBUYWcsXG4gICAgICB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICByZWY6IG5vZGVWaWV3Q29udGVudFJlZixcbiAgICAgICAgXCJkYXRhLW5vZGUtdmlldy1jb250ZW50XCI6IFwiXCIsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgd2hpdGVTcGFjZTogXCJwcmUtd3JhcFwiLFxuICAgICAgICAgIC4uLnByb3BzLnN0eWxlXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBub2RlVmlld0NvbnRlbnRDaGlsZHJlblxuICAgICAgfVxuICAgIClcbiAgKTtcbn1cblxuLy8gc3JjL05vZGVWaWV3V3JhcHBlci50c3hcbmltcG9ydCBSZWFjdDMgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4NCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIE5vZGVWaWV3V3JhcHBlciA9IFJlYWN0My5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IHsgb25EcmFnU3RhcnQgfSA9IHVzZVJlYWN0Tm9kZVZpZXcoKTtcbiAgY29uc3QgVGFnID0gcHJvcHMuYXMgfHwgXCJkaXZcIjtcbiAgcmV0dXJuIChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgLyogQF9fUFVSRV9fICovIGpzeDQoXG4gICAgICBUYWcsXG4gICAgICB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICByZWYsXG4gICAgICAgIFwiZGF0YS1ub2RlLXZpZXctd3JhcHBlclwiOiBcIlwiLFxuICAgICAgICBvbkRyYWdTdGFydCxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICB3aGl0ZVNwYWNlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgIC4uLnByb3BzLnN0eWxlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApXG4gICk7XG59KTtcblxuLy8gc3JjL1JlYWN0TWFya1ZpZXdSZW5kZXJlci50c3hcbmltcG9ydCB7IE1hcmtWaWV3IH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IFJlYWN0NCBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL1JlYWN0UmVuZGVyZXIudHN4XG5pbXBvcnQgeyB2ZXJzaW9uIGFzIHJlYWN0VmVyc2lvbiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZmx1c2hTeW5jIH0gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDUgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmZ1bmN0aW9uIGlzQ2xhc3NDb21wb25lbnQoQ29tcG9uZW50KSB7XG4gIHJldHVybiAhISh0eXBlb2YgQ29tcG9uZW50ID09PSBcImZ1bmN0aW9uXCIgJiYgQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuZnVuY3Rpb24gaXNGb3J3YXJkUmVmQ29tcG9uZW50KENvbXBvbmVudCkge1xuICByZXR1cm4gISEodHlwZW9mIENvbXBvbmVudCA9PT0gXCJvYmplY3RcIiAmJiBDb21wb25lbnQuJCR0eXBlb2YgJiYgKENvbXBvbmVudC4kJHR5cGVvZi50b1N0cmluZygpID09PSBcIlN5bWJvbChyZWFjdC5mb3J3YXJkX3JlZilcIiB8fCBDb21wb25lbnQuJCR0eXBlb2YuZGVzY3JpcHRpb24gPT09IFwicmVhY3QuZm9yd2FyZF9yZWZcIikpO1xufVxuZnVuY3Rpb24gaXNNZW1vQ29tcG9uZW50KENvbXBvbmVudCkge1xuICByZXR1cm4gISEodHlwZW9mIENvbXBvbmVudCA9PT0gXCJvYmplY3RcIiAmJiBDb21wb25lbnQuJCR0eXBlb2YgJiYgKENvbXBvbmVudC4kJHR5cGVvZi50b1N0cmluZygpID09PSBcIlN5bWJvbChyZWFjdC5tZW1vKVwiIHx8IENvbXBvbmVudC4kJHR5cGVvZi5kZXNjcmlwdGlvbiA9PT0gXCJyZWFjdC5tZW1vXCIpKTtcbn1cbmZ1bmN0aW9uIGNhblJlY2VpdmVSZWYoQ29tcG9uZW50KSB7XG4gIGlmIChpc0NsYXNzQ29tcG9uZW50KENvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNGb3J3YXJkUmVmQ29tcG9uZW50KENvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNNZW1vQ29tcG9uZW50KENvbXBvbmVudCkpIHtcbiAgICBjb25zdCB3cmFwcGVkQ29tcG9uZW50ID0gQ29tcG9uZW50LnR5cGU7XG4gICAgaWYgKHdyYXBwZWRDb21wb25lbnQpIHtcbiAgICAgIHJldHVybiBpc0NsYXNzQ29tcG9uZW50KHdyYXBwZWRDb21wb25lbnQpIHx8IGlzRm9yd2FyZFJlZkNvbXBvbmVudCh3cmFwcGVkQ29tcG9uZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNSZWFjdDE5UGx1cygpIHtcbiAgdHJ5IHtcbiAgICBpZiAocmVhY3RWZXJzaW9uKSB7XG4gICAgICBjb25zdCBtYWpvclZlcnNpb24gPSBwYXJzZUludChyZWFjdFZlcnNpb24uc3BsaXQoXCIuXCIpWzBdLCAxMCk7XG4gICAgICByZXR1cm4gbWFqb3JWZXJzaW9uID49IDE5O1xuICAgIH1cbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxudmFyIFJlYWN0UmVuZGVyZXIgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBJbW1lZGlhdGVseSBjcmVhdGVzIGVsZW1lbnQgYW5kIHJlbmRlcnMgdGhlIHByb3ZpZGVkIFJlYWN0IGNvbXBvbmVudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbXBvbmVudCwgeyBlZGl0b3IsIHByb3BzID0ge30sIGFzID0gXCJkaXZcIiwgY2xhc3NOYW1lID0gXCJcIiB9KSB7XG4gICAgdGhpcy5yZWYgPSBudWxsO1xuICAgIHRoaXMuaWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0Mjk0OTY3Mjk1KS50b1N0cmluZygpO1xuICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGFzKTtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInJlYWN0LXJlbmRlcmVyXCIpO1xuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZS5zcGxpdChcIiBcIikpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lZGl0b3IuaXNJbml0aWFsaXplZCkge1xuICAgICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgUmVhY3QgY29tcG9uZW50LlxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBDb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcbiAgICBjb25zdCBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgY29uc3QgaXNSZWFjdDE5ID0gaXNSZWFjdDE5UGx1cygpO1xuICAgIGNvbnN0IGNvbXBvbmVudENhblJlY2VpdmVSZWYgPSBjYW5SZWNlaXZlUmVmKENvbXBvbmVudCk7XG4gICAgY29uc3QgZWxlbWVudFByb3BzID0geyAuLi5wcm9wcyB9O1xuICAgIGlmIChlbGVtZW50UHJvcHMucmVmICYmICEoaXNSZWFjdDE5IHx8IGNvbXBvbmVudENhblJlY2VpdmVSZWYpKSB7XG4gICAgICBkZWxldGUgZWxlbWVudFByb3BzLnJlZjtcbiAgICB9XG4gICAgaWYgKCFlbGVtZW50UHJvcHMucmVmICYmIChpc1JlYWN0MTkgfHwgY29tcG9uZW50Q2FuUmVjZWl2ZVJlZikpIHtcbiAgICAgIGVsZW1lbnRQcm9wcy5yZWYgPSAocmVmKSA9PiB7XG4gICAgICAgIHRoaXMucmVmID0gcmVmO1xuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5yZWFjdEVsZW1lbnQgPSAvKiBAX19QVVJFX18gKi8ganN4NShDb21wb25lbnQsIHsgLi4uZWxlbWVudFByb3BzIH0pO1xuICAgIChfYSA9IGVkaXRvciA9PSBudWxsID8gdm9pZCAwIDogZWRpdG9yLmNvbnRlbnRDb21wb25lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zZXRSZW5kZXJlcih0aGlzLmlkLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogUmUtcmVuZGVycyB0aGUgUmVhY3QgY29tcG9uZW50IHdpdGggbmV3IHByb3BzLlxuICAgKi9cbiAgdXBkYXRlUHJvcHMocHJvcHMgPSB7fSkge1xuICAgIHRoaXMucHJvcHMgPSB7XG4gICAgICAuLi50aGlzLnByb3BzLFxuICAgICAgLi4ucHJvcHNcbiAgICB9O1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgIChfYSA9IGVkaXRvciA9PSBudWxsID8gdm9pZCAwIDogZWRpdG9yLmNvbnRlbnRDb21wb25lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZW1vdmVSZW5kZXJlcih0aGlzLmlkKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudCAmJiB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBlbGVtZW50IHRoYXQgaG9sZHMgdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICovXG4gIHVwZGF0ZUF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9SZWFjdE1hcmtWaWV3UmVuZGVyZXIudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4NiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFJlYWN0TWFya1ZpZXdDb250ZXh0ID0gUmVhY3Q0LmNyZWF0ZUNvbnRleHQoe1xuICBtYXJrVmlld0NvbnRlbnRSZWY6ICgpID0+IHtcbiAgfVxufSk7XG52YXIgTWFya1ZpZXdDb250ZW50ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHsgYXM6IFRhZyA9IFwic3BhblwiLCAuLi5yZXN0IH0gPSBwcm9wcztcbiAgY29uc3QgeyBtYXJrVmlld0NvbnRlbnRSZWYgfSA9IFJlYWN0NC51c2VDb250ZXh0KFJlYWN0TWFya1ZpZXdDb250ZXh0KTtcbiAgcmV0dXJuIChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgLyogQF9fUFVSRV9fICovIGpzeDYoVGFnLCB7IC4uLnJlc3QsIHJlZjogbWFya1ZpZXdDb250ZW50UmVmLCBcImRhdGEtbWFyay12aWV3LWNvbnRlbnRcIjogXCJcIiB9KVxuICApO1xufTtcbnZhciBSZWFjdE1hcmtWaWV3ID0gY2xhc3MgZXh0ZW5kcyBNYXJrVmlldyB7XG4gIGNvbnN0cnVjdG9yKGNvbXBvbmVudCwgcHJvcHMsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihjb21wb25lbnQsIHByb3BzLCBvcHRpb25zKTtcbiAgICBjb25zdCB7IGFzID0gXCJzcGFuXCIsIGF0dHJzLCBjbGFzc05hbWUgPSBcIlwiIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGNvbXBvbmVudFByb3BzID0geyAuLi5wcm9wcywgdXBkYXRlQXR0cmlidXRlczogdGhpcy51cGRhdGVBdHRyaWJ1dGVzLmJpbmQodGhpcykgfTtcbiAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgY29uc3QgbWFya1ZpZXdDb250ZW50UmVmID0gKGVsKSA9PiB7XG4gICAgICBpZiAoZWwgJiYgIWVsLmNvbnRhaW5zKHRoaXMuY29udGVudERPTUVsZW1lbnQpKSB7XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuY29udGVudERPTUVsZW1lbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIG1hcmtWaWV3Q29udGVudFJlZlxuICAgIH07XG4gICAgY29uc3QgUmVhY3RNYXJrVmlld1Byb3ZpZGVyID0gUmVhY3Q0Lm1lbW8oKGNvbXBvbmVudFByb3BzMikgPT4ge1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g2KFJlYWN0TWFya1ZpZXdDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0LCBjaGlsZHJlbjogUmVhY3Q0LmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBjb21wb25lbnRQcm9wczIpIH0pO1xuICAgIH0pO1xuICAgIFJlYWN0TWFya1ZpZXdQcm92aWRlci5kaXNwbGF5TmFtZSA9IFwiUmVhY3RNYXJrVmlld1wiO1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVhY3RSZW5kZXJlcihSZWFjdE1hcmtWaWV3UHJvdmlkZXIsIHtcbiAgICAgIGVkaXRvcjogcHJvcHMuZWRpdG9yLFxuICAgICAgcHJvcHM6IGNvbXBvbmVudFByb3BzLFxuICAgICAgYXMsXG4gICAgICBjbGFzc05hbWU6IGBtYXJrLSR7cHJvcHMubWFyay50eXBlLm5hbWV9ICR7Y2xhc3NOYW1lfWAudHJpbSgpXG4gICAgfSk7XG4gICAgaWYgKGF0dHJzKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUF0dHJpYnV0ZXMoYXR0cnMpO1xuICAgIH1cbiAgfVxuICBnZXQgZG9tKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmVsZW1lbnQ7XG4gIH1cbiAgZ2V0IGNvbnRlbnRET00oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudERPTUVsZW1lbnQ7XG4gIH1cbn07XG5mdW5jdGlvbiBSZWFjdE1hcmtWaWV3UmVuZGVyZXIoY29tcG9uZW50LCBvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIChwcm9wcykgPT4gbmV3IFJlYWN0TWFya1ZpZXcoY29tcG9uZW50LCBwcm9wcywgb3B0aW9ucyk7XG59XG5cbi8vIHNyYy9SZWFjdE5vZGVWaWV3UmVuZGVyZXIudHN4XG5pbXBvcnQgeyBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMsIE5vZGVWaWV3IH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCBhcyBjcmVhdGVFbGVtZW50MiwgY3JlYXRlUmVmLCBtZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4NyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFJlYWN0Tm9kZVZpZXcgPSBjbGFzcyBleHRlbmRzIE5vZGVWaWV3IHtcbiAgY29uc3RydWN0b3IoY29tcG9uZW50LCBwcm9wcywgb3B0aW9ucykge1xuICAgIHN1cGVyKGNvbXBvbmVudCwgcHJvcHMsIG9wdGlvbnMpO1xuICAgIGlmICghdGhpcy5ub2RlLmlzTGVhZikge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50RE9NRWxlbWVudFRhZykge1xuICAgICAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm9wdGlvbnMuY29udGVudERPTUVsZW1lbnRUYWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb250ZW50RE9NRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5ub2RlLmlzSW5saW5lID8gXCJzcGFuXCIgOiBcImRpdlwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGVudERPTUVsZW1lbnQuZGF0YXNldC5ub2RlVmlld0NvbnRlbnRSZWFjdCA9IFwiXCI7XG4gICAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50LmRhdGFzZXQubm9kZVZpZXdXcmFwcGVyID0gXCJcIjtcbiAgICAgIHRoaXMuY29udGVudERPTUVsZW1lbnQuc3R5bGUud2hpdGVTcGFjZSA9IFwiaW5oZXJpdFwiO1xuICAgICAgY29uc3QgY29udGVudFRhcmdldCA9IHRoaXMuZG9tLnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1ub2RlLXZpZXctY29udGVudF1cIik7XG4gICAgICBpZiAoIWNvbnRlbnRUYXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29udGVudFRhcmdldC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRET01FbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldHVwIHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAqIENhbGxlZCBvbiBpbml0aWFsaXphdGlvbi5cbiAgICovXG4gIG1vdW50KCkge1xuICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgIG5vZGU6IHRoaXMubm9kZSxcbiAgICAgIGRlY29yYXRpb25zOiB0aGlzLmRlY29yYXRpb25zLFxuICAgICAgaW5uZXJEZWNvcmF0aW9uczogdGhpcy5pbm5lckRlY29yYXRpb25zLFxuICAgICAgdmlldzogdGhpcy52aWV3LFxuICAgICAgc2VsZWN0ZWQ6IGZhbHNlLFxuICAgICAgZXh0ZW5zaW9uOiB0aGlzLmV4dGVuc2lvbixcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB0aGlzLkhUTUxBdHRyaWJ1dGVzLFxuICAgICAgZ2V0UG9zOiAoKSA9PiB0aGlzLmdldFBvcygpLFxuICAgICAgdXBkYXRlQXR0cmlidXRlczogKGF0dHJpYnV0ZXMgPSB7fSkgPT4gdGhpcy51cGRhdGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpLFxuICAgICAgZGVsZXRlTm9kZTogKCkgPT4gdGhpcy5kZWxldGVOb2RlKCksXG4gICAgICByZWY6IGNyZWF0ZVJlZigpXG4gICAgfTtcbiAgICBpZiAoIXRoaXMuY29tcG9uZW50LmRpc3BsYXlOYW1lKSB7XG4gICAgICBjb25zdCBjYXBpdGFsaXplRmlyc3RDaGFyID0gKHN0cmluZykgPT4ge1xuICAgICAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnN1YnN0cmluZygxKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmNvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGNhcGl0YWxpemVGaXJzdENoYXIodGhpcy5leHRlbnNpb24ubmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IG9uRHJhZ1N0YXJ0ID0gdGhpcy5vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IG5vZGVWaWV3Q29udGVudFJlZiA9IChlbGVtZW50KSA9PiB7XG4gICAgICBpZiAoZWxlbWVudCAmJiB0aGlzLmNvbnRlbnRET01FbGVtZW50ICYmIGVsZW1lbnQuZmlyc3RDaGlsZCAhPT0gdGhpcy5jb250ZW50RE9NRWxlbWVudCkge1xuICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJkYXRhLW5vZGUtdmlldy13cmFwcGVyXCIpKSB7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLW5vZGUtdmlldy13cmFwcGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RE9NRWxlbWVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjb250ZXh0ID0geyBvbkRyYWdTdGFydCwgbm9kZVZpZXdDb250ZW50UmVmIH07XG4gICAgY29uc3QgQ29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgY29uc3QgUmVhY3ROb2RlVmlld1Byb3ZpZGVyID0gbWVtbygoY29tcG9uZW50UHJvcHMpID0+IHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4NyhSZWFjdE5vZGVWaWV3Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dCwgY2hpbGRyZW46IGNyZWF0ZUVsZW1lbnQyKENvbXBvbmVudCwgY29tcG9uZW50UHJvcHMpIH0pO1xuICAgIH0pO1xuICAgIFJlYWN0Tm9kZVZpZXdQcm92aWRlci5kaXNwbGF5TmFtZSA9IFwiUmVhY3ROb2RlVmlld1wiO1xuICAgIGxldCBhcyA9IHRoaXMubm9kZS5pc0lubGluZSA/IFwic3BhblwiIDogXCJkaXZcIjtcbiAgICBpZiAodGhpcy5vcHRpb25zLmFzKSB7XG4gICAgICBhcyA9IHRoaXMub3B0aW9ucy5hcztcbiAgICB9XG4gICAgY29uc3QgeyBjbGFzc05hbWUgPSBcIlwiIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgdGhpcy5oYW5kbGVTZWxlY3Rpb25VcGRhdGUgPSB0aGlzLmhhbmRsZVNlbGVjdGlvblVwZGF0ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVhY3RSZW5kZXJlcihSZWFjdE5vZGVWaWV3UHJvdmlkZXIsIHtcbiAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICBwcm9wcyxcbiAgICAgIGFzLFxuICAgICAgY2xhc3NOYW1lOiBgbm9kZS0ke3RoaXMubm9kZS50eXBlLm5hbWV9ICR7Y2xhc3NOYW1lfWAudHJpbSgpXG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3Iub24oXCJzZWxlY3Rpb25VcGRhdGVcIiwgdGhpcy5oYW5kbGVTZWxlY3Rpb25VcGRhdGUpO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudEF0dHJpYnV0ZXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBET00gZWxlbWVudC5cbiAgICogVGhpcyBpcyB0aGUgZWxlbWVudCB0aGF0IHdpbGwgYmUgdXNlZCB0byBkaXNwbGF5IHRoZSBub2RlIHZpZXcuXG4gICAqL1xuICBnZXQgZG9tKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAodGhpcy5yZW5kZXJlci5lbGVtZW50LmZpcnN0RWxlbWVudENoaWxkICYmICEoKF9hID0gdGhpcy5yZW5kZXJlci5lbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaGFzQXR0cmlidXRlKFwiZGF0YS1ub2RlLXZpZXctd3JhcHBlclwiKSkpIHtcbiAgICAgIHRocm93IEVycm9yKFwiUGxlYXNlIHVzZSB0aGUgTm9kZVZpZXdXcmFwcGVyIGNvbXBvbmVudCBmb3IgeW91ciBub2RlIHZpZXcuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5lbGVtZW50O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvbnRlbnQgRE9NIGVsZW1lbnQuXG4gICAqIFRoaXMgaXMgdGhlIGVsZW1lbnQgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGlzcGxheSB0aGUgcmljaC10ZXh0IGNvbnRlbnQgb2YgdGhlIG5vZGUuXG4gICAqL1xuICBnZXQgY29udGVudERPTSgpIHtcbiAgICBpZiAodGhpcy5ub2RlLmlzTGVhZikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRlbnRET01FbGVtZW50O1xuICB9XG4gIC8qKlxuICAgKiBPbiBlZGl0b3Igc2VsZWN0aW9uIHVwZGF0ZSwgY2hlY2sgaWYgdGhlIG5vZGUgaXMgc2VsZWN0ZWQuXG4gICAqIElmIGl0IGlzLCBjYWxsIGBzZWxlY3ROb2RlYCwgb3RoZXJ3aXNlIGNhbGwgYGRlc2VsZWN0Tm9kZWAuXG4gICAqL1xuICBoYW5kbGVTZWxlY3Rpb25VcGRhdGUoKSB7XG4gICAgY29uc3QgeyBmcm9tLCB0byB9ID0gdGhpcy5lZGl0b3Iuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UG9zKCk7XG4gICAgaWYgKHR5cGVvZiBwb3MgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGZyb20gPD0gcG9zICYmIHRvID49IHBvcyArIHRoaXMubm9kZS5ub2RlU2l6ZSkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyZXIucHJvcHMuc2VsZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zZWxlY3ROb2RlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5yZW5kZXJlci5wcm9wcy5zZWxlY3RlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmRlc2VsZWN0Tm9kZSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogT24gdXBkYXRlLCB1cGRhdGUgdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICogVG8gcHJldmVudCB1bm5lY2Vzc2FyeSB1cGRhdGVzLCB0aGUgYHVwZGF0ZWAgb3B0aW9uIGNhbiBiZSB1c2VkLlxuICAgKi9cbiAgdXBkYXRlKG5vZGUsIGRlY29yYXRpb25zLCBpbm5lckRlY29yYXRpb25zKSB7XG4gICAgY29uc3QgcmVyZW5kZXJDb21wb25lbnQgPSAocHJvcHMpID0+IHtcbiAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlUHJvcHMocHJvcHMpO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuYXR0cnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRBdHRyaWJ1dGVzKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAobm9kZS50eXBlICE9PSB0aGlzLm5vZGUudHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy51cGRhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc3Qgb2xkTm9kZSA9IHRoaXMubm9kZTtcbiAgICAgIGNvbnN0IG9sZERlY29yYXRpb25zID0gdGhpcy5kZWNvcmF0aW9ucztcbiAgICAgIGNvbnN0IG9sZElubmVyRGVjb3JhdGlvbnMgPSB0aGlzLmlubmVyRGVjb3JhdGlvbnM7XG4gICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IGRlY29yYXRpb25zO1xuICAgICAgdGhpcy5pbm5lckRlY29yYXRpb25zID0gaW5uZXJEZWNvcmF0aW9ucztcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudXBkYXRlKHtcbiAgICAgICAgb2xkTm9kZSxcbiAgICAgICAgb2xkRGVjb3JhdGlvbnMsXG4gICAgICAgIG5ld05vZGU6IG5vZGUsXG4gICAgICAgIG5ld0RlY29yYXRpb25zOiBkZWNvcmF0aW9ucyxcbiAgICAgICAgb2xkSW5uZXJEZWNvcmF0aW9ucyxcbiAgICAgICAgaW5uZXJEZWNvcmF0aW9ucyxcbiAgICAgICAgdXBkYXRlUHJvcHM6ICgpID0+IHJlcmVuZGVyQ29tcG9uZW50KHsgbm9kZSwgZGVjb3JhdGlvbnMsIGlubmVyRGVjb3JhdGlvbnMgfSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gdGhpcy5ub2RlICYmIHRoaXMuZGVjb3JhdGlvbnMgPT09IGRlY29yYXRpb25zICYmIHRoaXMuaW5uZXJEZWNvcmF0aW9ucyA9PT0gaW5uZXJEZWNvcmF0aW9ucykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy5kZWNvcmF0aW9ucyA9IGRlY29yYXRpb25zO1xuICAgIHRoaXMuaW5uZXJEZWNvcmF0aW9ucyA9IGlubmVyRGVjb3JhdGlvbnM7XG4gICAgcmVyZW5kZXJDb21wb25lbnQoeyBub2RlLCBkZWNvcmF0aW9ucywgaW5uZXJEZWNvcmF0aW9ucyB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2VsZWN0IHRoZSBub2RlLlxuICAgKiBBZGQgdGhlIGBzZWxlY3RlZGAgcHJvcCBhbmQgdGhlIGBQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGVgIGNsYXNzLlxuICAgKi9cbiAgc2VsZWN0Tm9kZSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZVByb3BzKHtcbiAgICAgIHNlbGVjdGVkOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5yZW5kZXJlci5lbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGVcIik7XG4gIH1cbiAgLyoqXG4gICAqIERlc2VsZWN0IHRoZSBub2RlLlxuICAgKiBSZW1vdmUgdGhlIGBzZWxlY3RlZGAgcHJvcCBhbmQgdGhlIGBQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGVgIGNsYXNzLlxuICAgKi9cbiAgZGVzZWxlY3ROb2RlKCkge1xuICAgIHRoaXMucmVuZGVyZXIudXBkYXRlUHJvcHMoe1xuICAgICAgc2VsZWN0ZWQ6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5yZW5kZXJlci5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGVcIik7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlci5kZXN0cm95KCk7XG4gICAgdGhpcy5lZGl0b3Iub2ZmKFwic2VsZWN0aW9uVXBkYXRlXCIsIHRoaXMuaGFuZGxlU2VsZWN0aW9uVXBkYXRlKTtcbiAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50ID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSB0b3AtbGV2ZWwgZWxlbWVudCB0aGF0IGhvbGRzIHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEFwcGx5aW5nIHRoZSBhdHRyaWJ1dGVzIGRlZmluZWQgaW4gdGhlIGBhdHRyc2Agb3B0aW9uLlxuICAgKi9cbiAgdXBkYXRlRWxlbWVudEF0dHJpYnV0ZXMoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdHRycykge1xuICAgICAgbGV0IGF0dHJzT2JqID0ge307XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5hdHRycyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSB0aGlzLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmF0dHJpYnV0ZXM7XG4gICAgICAgIGNvbnN0IEhUTUxBdHRyaWJ1dGVzID0gZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKHRoaXMubm9kZSwgZXh0ZW5zaW9uQXR0cmlidXRlcyk7XG4gICAgICAgIGF0dHJzT2JqID0gdGhpcy5vcHRpb25zLmF0dHJzKHsgbm9kZTogdGhpcy5ub2RlLCBIVE1MQXR0cmlidXRlcyB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJzT2JqID0gdGhpcy5vcHRpb25zLmF0dHJzO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVBdHRyaWJ1dGVzKGF0dHJzT2JqKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBSZWFjdE5vZGVWaWV3UmVuZGVyZXIoY29tcG9uZW50LCBvcHRpb25zKSB7XG4gIHJldHVybiAocHJvcHMpID0+IHtcbiAgICBpZiAoIXByb3BzLmVkaXRvci5jb250ZW50Q29tcG9uZW50KSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVhY3ROb2RlVmlldyhjb21wb25lbnQsIHByb3BzLCBvcHRpb25zKTtcbiAgfTtcbn1cblxuLy8gc3JjL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5leHBvcnQge1xuICBFZGl0b3JDb25zdW1lcixcbiAgRWRpdG9yQ29udGVudCxcbiAgRWRpdG9yQ29udGV4dCxcbiAgRWRpdG9yUHJvdmlkZXIsXG4gIE1hcmtWaWV3Q29udGVudCxcbiAgTm9kZVZpZXdDb250ZW50LFxuICBOb2RlVmlld1dyYXBwZXIsXG4gIFB1cmVFZGl0b3JDb250ZW50LFxuICBSZWFjdE1hcmtWaWV3LFxuICBSZWFjdE1hcmtWaWV3Q29udGV4dCxcbiAgUmVhY3RNYXJrVmlld1JlbmRlcmVyLFxuICBSZWFjdE5vZGVWaWV3LFxuICBSZWFjdE5vZGVWaWV3Q29udGVudFByb3ZpZGVyLFxuICBSZWFjdE5vZGVWaWV3Q29udGV4dCxcbiAgUmVhY3ROb2RlVmlld1JlbmRlcmVyLFxuICBSZWFjdFJlbmRlcmVyLFxuICB1c2VDdXJyZW50RWRpdG9yLFxuICB1c2VFZGl0b3IsXG4gIHVzZUVkaXRvclN0YXRlLFxuICB1c2VSZWFjdE5vZGVWaWV3XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/react/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/starter-kit/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@tiptap/starter-kit/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StarterKit: () => (/* binding */ StarterKit),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_extension_blockquote__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-blockquote */ \"(ssr)/./node_modules/@tiptap/extension-blockquote/dist/index.js\");\n/* harmony import */ var _tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/extension-bold */ \"(ssr)/./node_modules/@tiptap/extension-bold/dist/index.js\");\n/* harmony import */ var _tiptap_extension_code__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/extension-code */ \"(ssr)/./node_modules/@tiptap/extension-code/dist/index.js\");\n/* harmony import */ var _tiptap_extension_code_block__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/extension-code-block */ \"(ssr)/./node_modules/@tiptap/extension-code-block/dist/index.js\");\n/* harmony import */ var _tiptap_extension_document__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/extension-document */ \"(ssr)/./node_modules/@tiptap/extension-document/dist/index.js\");\n/* harmony import */ var _tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/extension-hard-break */ \"(ssr)/./node_modules/@tiptap/extension-hard-break/dist/index.js\");\n/* harmony import */ var _tiptap_extension_heading__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/extension-heading */ \"(ssr)/./node_modules/@tiptap/extension-heading/dist/index.js\");\n/* harmony import */ var _tiptap_extension_horizontal_rule__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tiptap/extension-horizontal-rule */ \"(ssr)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js\");\n/* harmony import */ var _tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tiptap/extension-italic */ \"(ssr)/./node_modules/@tiptap/extension-italic/dist/index.js\");\n/* harmony import */ var _tiptap_extension_link__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tiptap/extension-link */ \"(ssr)/./node_modules/@tiptap/extension-link/dist/index.js\");\n/* harmony import */ var _tiptap_extension_list__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tiptap/extension-list */ \"(ssr)/./node_modules/@tiptap/extension-list/dist/index.js\");\n/* harmony import */ var _tiptap_extension_paragraph__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tiptap/extension-paragraph */ \"(ssr)/./node_modules/@tiptap/extension-paragraph/dist/index.js\");\n/* harmony import */ var _tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tiptap/extension-strike */ \"(ssr)/./node_modules/@tiptap/extension-strike/dist/index.js\");\n/* harmony import */ var _tiptap_extension_text__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tiptap/extension-text */ \"(ssr)/./node_modules/@tiptap/extension-text/dist/index.js\");\n/* harmony import */ var _tiptap_extension_underline__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tiptap/extension-underline */ \"(ssr)/./node_modules/@tiptap/starter-kit/node_modules/@tiptap/extension-underline/dist/index.js\");\n/* harmony import */ var _tiptap_extensions__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @tiptap/extensions */ \"(ssr)/./node_modules/@tiptap/extensions/dist/index.js\");\n// src/starter-kit.ts\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar StarterKit = _tiptap_core__WEBPACK_IMPORTED_MODULE_16__.Extension.create({\n  name: \"starterKit\",\n  addExtensions() {\n    var _a, _b, _c, _d;\n    const extensions = [];\n    if (this.options.bold !== false) {\n      extensions.push(_tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_1__.Bold.configure(this.options.bold));\n    }\n    if (this.options.blockquote !== false) {\n      extensions.push(_tiptap_extension_blockquote__WEBPACK_IMPORTED_MODULE_0__.Blockquote.configure(this.options.blockquote));\n    }\n    if (this.options.bulletList !== false) {\n      extensions.push(_tiptap_extension_list__WEBPACK_IMPORTED_MODULE_10__.BulletList.configure(this.options.bulletList));\n    }\n    if (this.options.code !== false) {\n      extensions.push(_tiptap_extension_code__WEBPACK_IMPORTED_MODULE_2__.Code.configure(this.options.code));\n    }\n    if (this.options.codeBlock !== false) {\n      extensions.push(_tiptap_extension_code_block__WEBPACK_IMPORTED_MODULE_3__.CodeBlock.configure(this.options.codeBlock));\n    }\n    if (this.options.document !== false) {\n      extensions.push(_tiptap_extension_document__WEBPACK_IMPORTED_MODULE_4__.Document.configure(this.options.document));\n    }\n    if (this.options.dropcursor !== false) {\n      extensions.push(_tiptap_extensions__WEBPACK_IMPORTED_MODULE_15__.Dropcursor.configure(this.options.dropcursor));\n    }\n    if (this.options.gapcursor !== false) {\n      extensions.push(_tiptap_extensions__WEBPACK_IMPORTED_MODULE_15__.Gapcursor.configure(this.options.gapcursor));\n    }\n    if (this.options.hardBreak !== false) {\n      extensions.push(_tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_5__.HardBreak.configure(this.options.hardBreak));\n    }\n    if (this.options.heading !== false) {\n      extensions.push(_tiptap_extension_heading__WEBPACK_IMPORTED_MODULE_6__.Heading.configure(this.options.heading));\n    }\n    if (this.options.undoRedo !== false) {\n      extensions.push(_tiptap_extensions__WEBPACK_IMPORTED_MODULE_15__.UndoRedo.configure(this.options.undoRedo));\n    }\n    if (this.options.horizontalRule !== false) {\n      extensions.push(_tiptap_extension_horizontal_rule__WEBPACK_IMPORTED_MODULE_7__.HorizontalRule.configure(this.options.horizontalRule));\n    }\n    if (this.options.italic !== false) {\n      extensions.push(_tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_8__.Italic.configure(this.options.italic));\n    }\n    if (this.options.listItem !== false) {\n      extensions.push(_tiptap_extension_list__WEBPACK_IMPORTED_MODULE_10__.ListItem.configure(this.options.listItem));\n    }\n    if (this.options.listKeymap !== false) {\n      extensions.push(_tiptap_extension_list__WEBPACK_IMPORTED_MODULE_10__.ListKeymap.configure((_a = this.options) == null ? void 0 : _a.listKeymap));\n    }\n    if (this.options.link !== false) {\n      extensions.push(_tiptap_extension_link__WEBPACK_IMPORTED_MODULE_9__.Link.configure((_b = this.options) == null ? void 0 : _b.link));\n    }\n    if (this.options.orderedList !== false) {\n      extensions.push(_tiptap_extension_list__WEBPACK_IMPORTED_MODULE_10__.OrderedList.configure(this.options.orderedList));\n    }\n    if (this.options.paragraph !== false) {\n      extensions.push(_tiptap_extension_paragraph__WEBPACK_IMPORTED_MODULE_11__.Paragraph.configure(this.options.paragraph));\n    }\n    if (this.options.strike !== false) {\n      extensions.push(_tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_12__.Strike.configure(this.options.strike));\n    }\n    if (this.options.text !== false) {\n      extensions.push(_tiptap_extension_text__WEBPACK_IMPORTED_MODULE_13__.Text.configure(this.options.text));\n    }\n    if (this.options.underline !== false) {\n      extensions.push(_tiptap_extension_underline__WEBPACK_IMPORTED_MODULE_14__.Underline.configure((_c = this.options) == null ? void 0 : _c.underline));\n    }\n    if (this.options.trailingNode !== false) {\n      extensions.push(_tiptap_extensions__WEBPACK_IMPORTED_MODULE_15__.TrailingNode.configure((_d = this.options) == null ? void 0 : _d.trailingNode));\n    }\n    return extensions;\n  }\n});\n\n// src/index.ts\nvar index_default = StarterKit;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9zdGFydGVyLWtpdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN5QztBQUNpQjtBQUNaO0FBQ0E7QUFDVztBQUNIO0FBQ0c7QUFDTDtBQUNlO0FBQ2pCO0FBQ0o7QUFDeUM7QUFDL0I7QUFDTjtBQUNKO0FBQ1U7QUFDMkI7QUFDbkYsaUJBQWlCLG9EQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQUk7QUFDMUI7QUFDQTtBQUNBLHNCQUFzQixvRUFBVTtBQUNoQztBQUNBO0FBQ0Esc0JBQXNCLCtEQUFVO0FBQ2hDO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQUk7QUFDMUI7QUFDQTtBQUNBLHNCQUFzQixtRUFBUztBQUMvQjtBQUNBO0FBQ0Esc0JBQXNCLGdFQUFRO0FBQzlCO0FBQ0E7QUFDQSxzQkFBc0IsMkRBQVU7QUFDaEM7QUFDQTtBQUNBLHNCQUFzQiwwREFBUztBQUMvQjtBQUNBO0FBQ0Esc0JBQXNCLG1FQUFTO0FBQy9CO0FBQ0E7QUFDQSxzQkFBc0IsOERBQU87QUFDN0I7QUFDQTtBQUNBLHNCQUFzQix5REFBUTtBQUM5QjtBQUNBO0FBQ0Esc0JBQXNCLDZFQUFjO0FBQ3BDO0FBQ0E7QUFDQSxzQkFBc0IsNERBQU07QUFDNUI7QUFDQTtBQUNBLHNCQUFzQiw2REFBUTtBQUM5QjtBQUNBO0FBQ0Esc0JBQXNCLCtEQUFVO0FBQ2hDO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQUk7QUFDMUI7QUFDQTtBQUNBLHNCQUFzQixnRUFBVztBQUNqQztBQUNBO0FBQ0Esc0JBQXNCLG1FQUFTO0FBQy9CO0FBQ0E7QUFDQSxzQkFBc0IsNkRBQU07QUFDNUI7QUFDQTtBQUNBLHNCQUFzQix5REFBSTtBQUMxQjtBQUNBO0FBQ0Esc0JBQXNCLG1FQUFTO0FBQy9CO0FBQ0E7QUFDQSxzQkFBc0IsNkRBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL21vcnRvbm1hYnVtYm8vRG93bmxvYWRzL3Rlc3RpbWlub255LXdlYjFfMTAtbWFpbi9ub2RlX21vZHVsZXMvQHRpcHRhcC9zdGFydGVyLWtpdC9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9zdGFydGVyLWtpdC50c1xuaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgQmxvY2txdW90ZSB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1ibG9ja3F1b3RlXCI7XG5pbXBvcnQgeyBCb2xkIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWJvbGRcIjtcbmltcG9ydCB7IENvZGUgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tY29kZVwiO1xuaW1wb3J0IHsgQ29kZUJsb2NrIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWNvZGUtYmxvY2tcIjtcbmltcG9ydCB7IERvY3VtZW50IH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWRvY3VtZW50XCI7XG5pbXBvcnQgeyBIYXJkQnJlYWsgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24taGFyZC1icmVha1wiO1xuaW1wb3J0IHsgSGVhZGluZyB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1oZWFkaW5nXCI7XG5pbXBvcnQgeyBIb3Jpem9udGFsUnVsZSB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1ob3Jpem9udGFsLXJ1bGVcIjtcbmltcG9ydCB7IEl0YWxpYyB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1pdGFsaWNcIjtcbmltcG9ydCB7IExpbmsgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tbGlua1wiO1xuaW1wb3J0IHsgQnVsbGV0TGlzdCwgTGlzdEl0ZW0sIExpc3RLZXltYXAsIE9yZGVyZWRMaXN0IH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWxpc3RcIjtcbmltcG9ydCB7IFBhcmFncmFwaCB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1wYXJhZ3JhcGhcIjtcbmltcG9ydCB7IFN0cmlrZSB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1zdHJpa2VcIjtcbmltcG9ydCB7IFRleHQgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tdGV4dFwiO1xuaW1wb3J0IHsgVW5kZXJsaW5lIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLXVuZGVybGluZVwiO1xuaW1wb3J0IHsgRHJvcGN1cnNvciwgR2FwY3Vyc29yLCBUcmFpbGluZ05vZGUsIFVuZG9SZWRvIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uc1wiO1xudmFyIFN0YXJ0ZXJLaXQgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogXCJzdGFydGVyS2l0XCIsXG4gIGFkZEV4dGVuc2lvbnMoKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBbXTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmJvbGQgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goQm9sZC5jb25maWd1cmUodGhpcy5vcHRpb25zLmJvbGQpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ibG9ja3F1b3RlICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEJsb2NrcXVvdGUuY29uZmlndXJlKHRoaXMub3B0aW9ucy5ibG9ja3F1b3RlKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuYnVsbGV0TGlzdCAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChCdWxsZXRMaXN0LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuYnVsbGV0TGlzdCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmNvZGUgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goQ29kZS5jb25maWd1cmUodGhpcy5vcHRpb25zLmNvZGUpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb2RlQmxvY2sgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goQ29kZUJsb2NrLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuY29kZUJsb2NrKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZG9jdW1lbnQgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goRG9jdW1lbnQuY29uZmlndXJlKHRoaXMub3B0aW9ucy5kb2N1bWVudCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmRyb3BjdXJzb3IgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goRHJvcGN1cnNvci5jb25maWd1cmUodGhpcy5vcHRpb25zLmRyb3BjdXJzb3IpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5nYXBjdXJzb3IgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goR2FwY3Vyc29yLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuZ2FwY3Vyc29yKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuaGFyZEJyZWFrICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEhhcmRCcmVhay5jb25maWd1cmUodGhpcy5vcHRpb25zLmhhcmRCcmVhaykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRpbmcgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goSGVhZGluZy5jb25maWd1cmUodGhpcy5vcHRpb25zLmhlYWRpbmcpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy51bmRvUmVkbyAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChVbmRvUmVkby5jb25maWd1cmUodGhpcy5vcHRpb25zLnVuZG9SZWRvKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbFJ1bGUgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goSG9yaXpvbnRhbFJ1bGUuY29uZmlndXJlKHRoaXMub3B0aW9ucy5ob3Jpem9udGFsUnVsZSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLml0YWxpYyAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChJdGFsaWMuY29uZmlndXJlKHRoaXMub3B0aW9ucy5pdGFsaWMpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5saXN0SXRlbSAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChMaXN0SXRlbS5jb25maWd1cmUodGhpcy5vcHRpb25zLmxpc3RJdGVtKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMubGlzdEtleW1hcCAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChMaXN0S2V5bWFwLmNvbmZpZ3VyZSgoX2EgPSB0aGlzLm9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5saXN0S2V5bWFwKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMubGluayAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChMaW5rLmNvbmZpZ3VyZSgoX2IgPSB0aGlzLm9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5saW5rKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMub3JkZXJlZExpc3QgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goT3JkZXJlZExpc3QuY29uZmlndXJlKHRoaXMub3B0aW9ucy5vcmRlcmVkTGlzdCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnBhcmFncmFwaCAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChQYXJhZ3JhcGguY29uZmlndXJlKHRoaXMub3B0aW9ucy5wYXJhZ3JhcGgpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zdHJpa2UgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goU3RyaWtlLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuc3RyaWtlKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMudGV4dCAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChUZXh0LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMudGV4dCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnVuZGVybGluZSAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChVbmRlcmxpbmUuY29uZmlndXJlKChfYyA9IHRoaXMub3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnVuZGVybGluZSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnRyYWlsaW5nTm9kZSAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChUcmFpbGluZ05vZGUuY29uZmlndXJlKChfZCA9IHRoaXMub3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnRyYWlsaW5nTm9kZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZXh0ZW5zaW9ucztcbiAgfVxufSk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGluZGV4X2RlZmF1bHQgPSBTdGFydGVyS2l0O1xuZXhwb3J0IHtcbiAgU3RhcnRlcktpdCxcbiAgaW5kZXhfZGVmYXVsdCBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/starter-kit/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/starter-kit/node_modules/@tiptap/extension-underline/dist/index.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@tiptap/starter-kit/node_modules/@tiptap/extension-underline/dist/index.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Underline: () => (/* binding */ Underline),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/underline.ts\n\nvar Underline = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n  name: \"underline\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"u\"\n      },\n      {\n        style: \"text-decoration\",\n        consuming: false,\n        getAttrs: (style) => style.includes(\"underline\") ? {} : false\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"u\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  parseMarkdown(token, helpers) {\n    return helpers.applyMark(this.name || \"underline\", helpers.parseInline(token.tokens || []));\n  },\n  renderMarkdown(node, helpers) {\n    return `++${helpers.renderChildren(node)}++`;\n  },\n  markdownTokenizer: {\n    name: \"underline\",\n    level: \"inline\",\n    start(src) {\n      return src.indexOf(\"++\");\n    },\n    tokenize(src, _tokens, lexer) {\n      const rule = /^(\\+\\+)([\\s\\S]+?)(\\+\\+)/;\n      const match = rule.exec(src);\n      if (!match) {\n        return void 0;\n      }\n      const innerContent = match[2].trim();\n      return {\n        type: \"underline\",\n        raw: match[0],\n        text: innerContent,\n        tokens: lexer.inlineTokens(innerContent)\n      };\n    }\n  },\n  addCommands() {\n    return {\n      setUnderline: () => ({ commands }) => {\n        return commands.setMark(this.name);\n      },\n      toggleUnderline: () => ({ commands }) => {\n        return commands.toggleMark(this.name);\n      },\n      unsetUnderline: () => ({ commands }) => {\n        return commands.unsetMark(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-u\": () => this.editor.commands.toggleUnderline(),\n      \"Mod-U\": () => this.editor.commands.toggleUnderline()\n    };\n  }\n});\n\n// src/index.ts\nvar index_default = Underline;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9zdGFydGVyLWtpdC9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdW5kZXJsaW5lL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDcUQ7QUFDckQsZ0JBQWdCLDhDQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZUFBZSxnQkFBZ0I7QUFDL0IsaUJBQWlCLDZEQUFlO0FBQ2hDLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTtBQUN2QztBQUNBLE9BQU87QUFDUCxnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBLE9BQU87QUFDUCwrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL21vcnRvbm1hYnVtYm8vRG93bmxvYWRzL3Rlc3RpbWlub255LXdlYjFfMTAtbWFpbi9ub2RlX21vZHVsZXMvQHRpcHRhcC9zdGFydGVyLWtpdC9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdW5kZXJsaW5lL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3VuZGVybGluZS50c1xuaW1wb3J0IHsgTWFyaywgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xudmFyIFVuZGVybGluZSA9IE1hcmsuY3JlYXRlKHtcbiAgbmFtZTogXCJ1bmRlcmxpbmVcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9XG4gICAgfTtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJ1XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiBcInRleHQtZGVjb3JhdGlvblwiLFxuICAgICAgICBjb25zdW1pbmc6IGZhbHNlLFxuICAgICAgICBnZXRBdHRyczogKHN0eWxlKSA9PiBzdHlsZS5pbmNsdWRlcyhcInVuZGVybGluZVwiKSA/IHt9IDogZmFsc2VcbiAgICAgIH1cbiAgICBdO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbXCJ1XCIsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gIH0sXG4gIHBhcnNlTWFya2Rvd24odG9rZW4sIGhlbHBlcnMpIHtcbiAgICByZXR1cm4gaGVscGVycy5hcHBseU1hcmsodGhpcy5uYW1lIHx8IFwidW5kZXJsaW5lXCIsIGhlbHBlcnMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zIHx8IFtdKSk7XG4gIH0sXG4gIHJlbmRlck1hcmtkb3duKG5vZGUsIGhlbHBlcnMpIHtcbiAgICByZXR1cm4gYCsrJHtoZWxwZXJzLnJlbmRlckNoaWxkcmVuKG5vZGUpfSsrYDtcbiAgfSxcbiAgbWFya2Rvd25Ub2tlbml6ZXI6IHtcbiAgICBuYW1lOiBcInVuZGVybGluZVwiLFxuICAgIGxldmVsOiBcImlubGluZVwiLFxuICAgIHN0YXJ0KHNyYykge1xuICAgICAgcmV0dXJuIHNyYy5pbmRleE9mKFwiKytcIik7XG4gICAgfSxcbiAgICB0b2tlbml6ZShzcmMsIF90b2tlbnMsIGxleGVyKSB7XG4gICAgICBjb25zdCBydWxlID0gL14oXFwrXFwrKShbXFxzXFxTXSs/KShcXCtcXCspLztcbiAgICAgIGNvbnN0IG1hdGNoID0gcnVsZS5leGVjKHNyYyk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBjb25zdCBpbm5lckNvbnRlbnQgPSBtYXRjaFsyXS50cmltKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInVuZGVybGluZVwiLFxuICAgICAgICByYXc6IG1hdGNoWzBdLFxuICAgICAgICB0ZXh0OiBpbm5lckNvbnRlbnQsXG4gICAgICAgIHRva2VuczogbGV4ZXIuaW5saW5lVG9rZW5zKGlubmVyQ29udGVudClcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0VW5kZXJsaW5lOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlVW5kZXJsaW5lOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9LFxuICAgICAgdW5zZXRVbmRlcmxpbmU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcIk1vZC11XCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZVVuZGVybGluZSgpLFxuICAgICAgXCJNb2QtVVwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVVbmRlcmxpbmUoKVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gVW5kZXJsaW5lO1xuZXhwb3J0IHtcbiAgVW5kZXJsaW5lLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/starter-kit/node_modules/@tiptap/extension-underline/dist/index.js\n");

/***/ })

};
;